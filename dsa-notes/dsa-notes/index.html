<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Data Structures and Algorithm - Cheatsheets and Notes</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <link href="../../style.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Cheatsheets and Notes</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Cs2103t <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../cs2103t/cs2103t-notes/" class="dropdown-item">CS2103/T Notes</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Dsa notes <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="./" class="dropdown-item active">Data Structures and Algorithm</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../../cs2103t/cs2103t-notes/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" class="nav-link disabled">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#data-structures-and-algorithm" class="nav-link">Data Structures and Algorithm</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#recurrence-relations" class="nav-link">Recurrence Relations</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#binary-search" class="nav-link">Binary Search</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#peak-finding" class="nav-link">Peak Finding</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#sorting" class="nav-link">Sorting</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#trees" class="nav-link">Trees</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#balanced-trees" class="nav-link">Balanced Trees</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#tries" class="nav-link">Tries</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#dynamic-order-statistics" class="nav-link">Dynamic Order Statistics</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#interval-trees" class="nav-link">Interval Trees</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#1d-range-trees" class="nav-link">1D Range Trees</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#2d-range-trees" class="nav-link">2D Range Trees</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#priority-queue" class="nav-link">Priority Queue</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#binary-max-heaps" class="nav-link">Binary (Max) Heaps</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#heapsort" class="nav-link">HeapSort</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#disjoint-set" class="nav-link">Disjoint Set</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#quick-find-using-an-int-componentid" class="nav-link">Quick Find: using an int[] componentId</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="data-structures-and-algorithm">Data Structures and Algorithm</h1>
<ul>
<li><a href="#data-structures-and-algorithm">Data Structures and Algorithm</a><ul>
<li><a href="#recurrence-relations">Recurrence Relations</a></li>
<li><a href="#binary-search">Binary Search</a></li>
<li><a href="#peak-finding">Peak Finding</a></li>
<li><a href="#sorting">Sorting</a><ul>
<li><a href="#bubblesort">BubbleSort</a></li>
<li><a href="#selectionsort">SelectionSort</a></li>
<li><a href="#insertionsort">InsertionSort</a></li>
<li><a href="#mergesort">MergeSort</a></li>
<li><a href="#quicksort">QuickSort</a><ul>
<li><a href="#partition">Partition</a></li>
<li><a href="#quickselect">QuickSelect</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#trees">Trees</a><ul>
<li><a href="#binary-search-trees">Binary Search Trees</a><ul>
<li><a href="#height">Height</a></li>
<li><a href="#search">Search</a></li>
<li><a href="#insert">Insert</a></li>
</ul>
</li>
<li><a href="#traversals">Traversals</a><ul>
<li><a href="#inorder-traversal">Inorder Traversal</a></li>
<li><a href="#preorder-traversal">Preorder Traversal</a></li>
<li><a href="#postorder-traversal">Postorder Traversal</a></li>
</ul>
</li>
<li><a href="#delete">Delete</a></li>
</ul>
</li>
<li><a href="#balanced-trees">Balanced Trees</a><ul>
<li><a href="#avl">AVL</a><ul>
<li><a href="#insert-1">Insert</a></li>
<li><a href="#delete-1">Delete</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tries">Tries</a></li>
<li><a href="#dynamic-order-statistics">Dynamic Order Statistics</a></li>
<li><a href="#interval-trees">Interval Trees</a><ul>
<li><a href="#insert-2">Insert</a></li>
<li><a href="#interval-search">Interval Search</a></li>
</ul>
</li>
<li><a href="#1d-range-trees">1D Range Trees</a><ul>
<li><a href="#query">Query</a></li>
</ul>
</li>
<li><a href="#2d-range-trees">2D Range Trees</a></li>
</ul>
</li>
<li><a href="#priority-queue">Priority Queue</a><ul>
<li><a href="#binary-max-heaps">Binary (Max) Heaps</a><ul>
<li><a href="#insert-3">Insert</a></li>
<li><a href="#decreasekey">DecreaseKey</a></li>
<li><a href="#delete-2">Delete</a></li>
<li><a href="#heap-vs-avl-tree">Heap vs AVL Tree</a></li>
</ul>
</li>
<li><a href="#heapsort">HeapSort</a></li>
</ul>
</li>
<li><a href="#disjoint-set">Disjoint Set</a><ul>
<li><a href="#quick-find-using-an-int-componentid">Quick Find: using an int[] componentId</a><ul>
<li><a href="#quick-union-using-an-int-parent">Quick Union: using an int[] parent</a></li>
<li><a href="#weighted-union">Weighted Union</a></li>
<li><a href="#weighted-union-with-path-compression">Weighted Union with Path Compression</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="recurrence-relations">Recurrence Relations</h2>
<ol>
<li>T(n) = T(n-1) + O(1) = O(n)</li>
<li>T(n) = T(n/2) + O(1) = O(logn)</li>
<li>T(n) = T(n-1) + O(n) = O(n^2)</li>
<li>T(n) = T(n-1) + O(nk) = O(n^(k+1))</li>
<li>T(n) = 2T(n/2) + O(n) = O(nlogn)</li>
<li>T(n) = T(n/2) + O(n) = O(n)</li>
<li>T(n) = 2T(n/2) + O(1) = O(n)</li>
<li>T(n) = 2T(n-1) + O(1) = O(2^n)</li>
</ol>
<h2 id="binary-search">Binary Search</h2>
<ul>
<li>Time complexity: O(logn)</li>
<li>Preconditions:<ul>
<li>Array is of size n</li>
<li>Array is sorted</li>
</ul>
</li>
<li>Postconditions:<ul>
<li>If element is in array: <code>A[left] = key</code></li>
</ul>
</li>
<li>Loop invariant:<ul>
<li><code>A[left] &lt;= key &lt;= A[right]</code></li>
<li>(right - left) &lt;= n/2^k in iteration k</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public int search(int A[], int key, int n) {
    int left = 0;
    int right = n - 1;

    while (left &lt; right) {
        // int mid = (left + right) / 2 can lead to integer overflow
        int mid = left + (right - left) / 2;
        if (key &lt;= A[mid]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return (A[left] == key ? left : -1);
}
</code></pre>
<h2 id="peak-finding">Peak Finding</h2>
<ul>
<li>Output a local maximum in A, where A[i - 1] &lt;= A[i] and A[i + 1] &lt;= A[i]</li>
<li>Time complexity: O(logn)</li>
<li>
<p>Invariant:</p>
<ul>
<li>If we recuse in the right half, then there exists a peak in the right half</li>
<li>There exists a peak in the range [begin, end]</li>
<li>Every peak in [begin, end] is a peak in [1, n]</li>
</ul>
</li>
<li>
<p>T(n) = T(n/2) + θ(1) = O(logn)</p>
</li>
</ul>
<pre><code class="language-java">public int findPeak(int A[], int n) {
    // if right of mid is larger, recurse on right
    if (A[n / 2 + 1] &gt; A[n / 2]) {
        return findPeak(Arrays.copyOfRange(A, n / 2 + 1, n + 1), n / 2)
    // if left of mid is larger, recurse on left
    } else if (A[n / 2 - 1] &gt;  A[n / 2]) {
        return findPeak(Arrays.copyOfRange(A, 0, n / 2), n / 2)
    } else {
        return n / 2;
    }
}
</code></pre>
<h2 id="sorting">Sorting</h2>
<h3 id="bubblesort">BubbleSort</h3>
<ul>
<li>Invariant:<ul>
<li>At the end of iteration i, the biggest j items are correctly sorted in the final j positions of the array.</li>
</ul>
</li>
<li>Best: O(n), when array is already sorted</li>
<li>Worst: <strong>O(n^2)</strong>, when array is reverse sorted</li>
<li>Stable</li>
<li>Description:<ul>
<li>For n loops, if A[j] &gt; A[j + 1], swap(A[j], A[j + 1])</li>
<li><img alt="bubbleSort" src="../bubbleSort.png" /></li>
</ul>
</li>
</ul>
<pre><code class="language-java">void bubbleSort(int arr[], int n) {
    int i, j, temp;
    boolean swapped;
    for (i = 0; i &lt; n - 1; i++) {
        swapped = false;
        for (j = 0; j &lt; n - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {

                // Swap arr[j] and arr[j+1]
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }

        // If no two elements were
        // swapped by inner loop, then break
        if (swapped == false)
            break;
    }
}
</code></pre>
<h3 id="selectionsort">SelectionSort</h3>
<ul>
<li>Invariant:<ul>
<li>At the end of iteration j: the smallest j items are correctly sorted in the first j positions of the array.</li>
</ul>
</li>
<li>Best: O(n^2)</li>
<li>Worst: <strong>O(n^2)</strong></li>
<li>Not stable</li>
<li>Description:<ul>
<li>For n loops, find minimum element A[j] in A[j..n], swap(A[j], A[k])</li>
<li><img alt="selectionSort" src="../selectionSort.png" /></li>
</ul>
</li>
</ul>
<pre><code class="language-java">void selectionSort(int arr[], int n) {
    int min_idx = 0;

    // One by one move boundary of unsorted subarray
    for (int i = 0; i &lt; n - 1; i++) {

        // Find the minimum element in unsorted array
        min_idx = i;
        for (int j = i + 1; j &lt; n; j++) {
            if (arr[j] &lt; arr[min_idx])
                min_idx = j;
        }

        // Swap the found minimum element with the first element
        if (min_idx != i)
            swap(arr[min_idx], arr[i]);
    }
}
</code></pre>
<h3 id="insertionsort">InsertionSort</h3>
<ul>
<li>Invariant:<ul>
<li>At the end of iteration j: the first j items in the array are in sorted order.</li>
</ul>
</li>
<li>Best: O(n), when array is already sorted</li>
<li>Worst: <strong>O(n^2)</strong>, when array is reverse sorted</li>
<li>Stable</li>
<li>Description:<ul>
<li>For n loops, insert key into the sorted array A[1 .. j - 1]</li>
<li><img alt="insertionSort" src="../insertionSort.png" /></li>
</ul>
</li>
</ul>
<pre><code class="language-java">void insertionSort(int arr[]) {
    int n = arr.length;
    for (int i = 1; i &lt; n; ++i) {
        int key = arr[i];
        int j = i - 1;

        /* Move elements of arr[0..i-1], that are
            greater than key, to one position ahead
            of their current position */
        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
</code></pre>
<h3 id="mergesort">MergeSort</h3>
<ul>
<li>Best: <code>O(n logn)</code></li>
<li>Worst: <code>O(n logn)</code></li>
<li>Stable</li>
<li>Memory: <code>O(n logn)</code></li>
<li>Description:<ul>
<li>Divide: split array into two halves</li>
<li>Recurse: sort the two halves</li>
<li>Combine: merge the two sorted halves</li>
<li><img alt="mergeSort" src="https://cdn.educba.com/academy/wp-content/uploads/2021/06/7.png" /></li>
</ul>
</li>
<li>Use InsertionSort instead for n &lt; 1024</li>
</ul>
<pre><code class="language-java">void merge(int arr[], int l, int m, int r) {
    // Find sizes of two subarrays to be merged
    int n1 = m - l + 1;
    int n2 = r - m;

    // Create temp arrays
    int L[] = new int[n1];
    int R[] = new int[n2];

    // Copy data to temp arrays
    for (int i = 0; i &lt; n1; ++i)
        L[i] = arr[l + i];
    for (int j = 0; j &lt; n2; ++j)
        R[j] = arr[m + 1 + j];

    // Merge the temp arrays

    // Initial indices of first and second subarrays
    int i = 0, j = 0;

    // Initial index of merged subarray array
    int k = l;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy remaining elements of L[] if any
    while (i &lt; n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy remaining elements of R[] if any
    while (j &lt; n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int l, int r) {
    if (l &lt; r) {
        // Find the middle point
        int m = l + (r - l) / 2;

        // Sort first and second halves
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);

        // Merge the sorted halves
        merge(arr, l, m, r);
    }
}
</code></pre>
<h3 id="quicksort">QuickSort</h3>
<ul>
<li>Invariant:<ul>
<li>At the end of every loop iteration,</li>
<li>For every i &lt; low: B[i] &lt; pivot</li>
<li>For every j &gt; high: B[j] &gt; pivot</li>
</ul>
</li>
<li>Best: <code>O(n logn)</code>, when median element is chosen as pivot</li>
<li>Worst: <code>O(n^2)</code>, when first element is chosen as pivot/ all elements are the same</li>
<li>Not stable</li>
<li>Description:<ul>
<li><img alt="quickSort" src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*bIJvejLlEshkf-ehYJJlWQ.png" /></li>
<li>Divide: Partition the array into two sub-arrays around a pivot x such that elements in lower subarray ≤ x ≤ elements in upper sub-array.</li>
<li>Conquer: Recursively sort the two sub-arrays.</li>
<li>Combine: Trivial, do nothing.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">void quickSort(int[] arr, int low, int high) {
    if (low &lt; high) {

        // pi is partitioning index, arr[pi]
        // is now at right place
        int pi = partition(arr, low, high);

        // Separately sort elements before
        // partition and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
</code></pre>
<h4 id="partition">Partition</h4>
<ul>
<li>Invariant:<ul>
<li>A[high] &gt; pivot at the end of each loop</li>
<li>At the end of every loop iteration<ul>
<li>For all i &gt;= high, A[i] &gt; pivot</li>
<li>For all 1 &lt; j &lt; low, A[j] &lt; pivot</li>
</ul>
</li>
</ul>
</li>
<li>Time complexity: <code>O(n)</code></li>
</ul>
<pre><code class="language-java">int partition(int[] arr, int low, int high) {
    // Choosing the pivot
    int pivot = arr[high];

    // Index of smaller element and indicates
    // the right position of pivot found so far
    int i = (low - 1);

    for (int j = low; j &lt;= high - 1; j++) {

        // If current element is smaller than the pivot
        if (arr[j] &lt; pivot) {

            // Increment index of smaller element
            i++;
            swap(arr, i, j);
        }
    }
    swap(arr, i + 1, high);
    return (i + 1);
}
</code></pre>
<h4 id="quickselect">QuickSelect</h4>
<ul>
<li>Invariant:<ul>
<li>After partioning, arr[partition] is now at right place</li>
</ul>
</li>
<li>Time complexity: <code>O(n)</code></li>
<li>Description: Find the k-th smallest element in an unordered list<ul>
<li>partition the array</li>
<li>if partition is at position k, the partition is the k-th smallest element</li>
<li>else continue searching in the correct half</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// ASSUMPTION: all elements in arr[] are distinct
int kthSmallest(int[] arr, int low,
                            int high, int k) {
    // find the partition
    int partition = partition(arr, low, high);

    // if partition value is equal to the kth position, return value at k
    if (partition == k - 1) {
        return arr[partition];
    }
    // if partition value is less than kth position, search right side of the array
    else if (partition &lt; k - 1) {
        return kthSmallest(arr, partition + 1, high, k);
    }
    // if partition value is more than kth position, search left side of the array
    else {
        return kthSmallest(arr, low, partition - 1, k);
    }
}
</code></pre>
<h2 id="trees">Trees</h2>
<h3 id="binary-search-trees">Binary Search Trees</h3>
<ul>
<li>All in left sub-tree &lt; key &lt; all in right sub-tree</li>
</ul>
<h4 id="height">Height</h4>
<ul>
<li>Number of edges on longest path from root to leaf</li>
<li><code>h(v) = 0</code> (if v is a leaf)</li>
<li><code>h(v) = max(h(v.left), h(v.right)) + 1</code></li>
<li>Time complexity: <code>O(logn)</code></li>
</ul>
<pre><code class="language-java">int height() {
    int leftHeight = -1;
    int rightHeight = -1;

    if (leftTree != null) {
        leftHeight = leftTree.height();
    }
    if (rightTree != null) {
        rightHeight = rightTree.height();
    }
    return max(leftHeight, rightHeight) + 1;
}
</code></pre>
<h4 id="search">Search</h4>
<ul>
<li>Worst case: <code>O(n)</code>, (when n = h)</li>
<li>
<p>Time complexity: <code>O(h)</code></p>
</li>
<li>
<p>searchMax()</p>
</li>
</ul>
<pre><code class="language-java">TreeNode searchMax() {
    if (rightTree != null) {
        return rightTree.searchMax();
    } else {
        return this;
    }
}
</code></pre>
<ul>
<li>searchMin()</li>
</ul>
<pre><code class="language-java">TreeNode searchMin() {
    if (leftTree != null) {
        return leftTree.searchMin();
    } else {
        return this;
    }
}
</code></pre>
<ul>
<li>search(int queryKey)</li>
</ul>
<pre><code class="language-java">public TreeNode search(int queryKey){
    if (queryKey &lt; key) {
        if (leftTree != null) {
            return leftTree.search(key);
        } else {
            return null;
        }
    } else if (queryKey &gt; key) {
        if (rightTree != null) {
            return rightTree.search(key);
        } else {
            return null;
        }
    } else {
        return this; // Key is here!
    }
}
</code></pre>
<h4 id="insert">Insert</h4>
<pre><code class="language-java">void insert(int insKey, int intValue) {
    if (insKey &lt; key) {
        if (leftTree != null) {
            leftTree.insert(insKey);
        } else {
            leftTree = new TreeNode(insKey,insValue)
        }
    } else if (insKey &gt; key) {
        if (rightTree != null) {
            rightTree.insert(insKey);
        } else {
            rightTree = new TreeNode(insKey, insValue);
        }
    } else {
        return; // Key is already in the tree!
    }
}
</code></pre>
<h3 id="traversals">Traversals</h3>
<h4 id="inorder-traversal">Inorder Traversal</h4>
<ul>
<li>Left, self, right</li>
<li>Running time: <code>O(n)</code></li>
</ul>
<pre><code class="language-java">void inOrder(Node node) {
    if (node == null)
        return;

    // First recur on left child
    inOrder(node.left);

    // Then print the data of node
    System.out.print(node.key + &quot; &quot;);

    // Now recur on right child
    inOrder(node.right);
}
</code></pre>
<h4 id="preorder-traversal">Preorder Traversal</h4>
<ul>
<li>Self, left, right</li>
<li>Running time: <code>O(n)</code></li>
</ul>
<pre><code class="language-java">void preOrder(Node node) {
    if (node == null)
        return;

    // Print the data of node
    System.out.print(node.key + &quot; &quot;);

    // Then recur on left child
    preOrder(node.left);

    // Now recur on right child
    preOrder(node.right);
}
</code></pre>
<h4 id="postorder-traversal">Postorder Traversal</h4>
<ul>
<li>Left, right, self</li>
<li>Running time: <code>O(n)</code></li>
</ul>
<pre><code class="language-java">void postOrder(Node node) {
    if (node == null)
        return;

    // First recur on left child
    postOrder(node.left);

    // Then recur on right child
    postOrder(node.right);

    // Now print the data of node
    System.out.print(node.key + &quot; &quot;);
}
</code></pre>
<h3 id="delete">Delete</h3>
<ul>
<li>Successor<ul>
<li>Running time: <code>O(h)</code></li>
<li>Idea:<ol>
<li>Search for key in the tree.</li>
<li>If (result &gt; key), then return result.</li>
<li>If (result &lt;= key), then search for successor of result.</li>
</ol>
</li>
<li>Case 1: node has a right child</li>
<li>Case 2: node has no right child</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public TreeNode successor() {
    if (rightTree != null) {
        return rightTree.searchMin();
    }
    TreeNode parent = parentTree;
    TreeNode child = this;
    while ((parent != null) &amp;&amp; (child == parent.rightTree)) {
        child = parent;
        parent = child.parentTree;
    }
    return parent;
}
</code></pre>
<ul>
<li>Delete<ul>
<li>Running time: <code>O(h)</code></li>
<li>Case 1: no children<ul>
<li>Remove v</li>
</ul>
</li>
<li>Case 2: 1 child<ul>
<li>Remove v</li>
<li>Connect child(v) to parent(v)</li>
</ul>
</li>
<li>Case 3: 2 children<ul>
<li>x = successor(v)</li>
<li>Delete(x)</li>
<li>Remove v</li>
<li>Connect x to left(v), right(v), parent(v)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="balanced-trees">Balanced Trees</h2>
<ul>
<li>BST is balanced if <code>h = O(logn)</code></li>
<li>All operations run in <code>O(logn)</code> time</li>
<li>Maxmimum height: <code>h &lt; 2logn</code></li>
<li>
<p>Mininimum nodes: <code>n &gt; 2^(h/2)</code></p>
</li>
<li>
<p>In every node v, store height (augment)</p>
<ul>
<li>On insert and delete, update height: <code>height = max(left.height, right.height) + 1</code></li>
</ul>
</li>
<li>
<p>Define Invariant</p>
<ul>
<li>A node v is <strong>height-balanced</strong> if <code>|v.left.height - v.right.height| &lt;= 1</code></li>
<li>A BST is height-balanced if every node is height-balanced</li>
</ul>
</li>
<li>
<p>Maintain balance</p>
</li>
</ul>
<pre><code class="language-java">// assume v has left != null
void rightRotate(TreeNode v) {
    TreeNode w = v.left;
    w.parent = v.parent;
    v.parent = w;
    v.left = w.right;
    w.right = v;
}
</code></pre>
<pre><code class="language-java">// assume v has right != null
void leftRotate(TreeNode v) {
    TreeNode w = v.right;
    w.parent = v.parent;
    v.parent = w;
    v.right = w.left;
    w.left = v;
}
</code></pre>
<p>If v is out of balanced and left-heavy:</p>
<ul>
<li>Case 1: v.left is balanced -&gt; rightRotate(v)
    <img alt="equivBST" src="../equivBST.png" /></li>
<li>Case 2: v.left is left-heavy -&gt; rightRotate(v)
    <img alt="leftHeavyBST" src="../leftHeavyBST.png" /></li>
<li>Case 3: v.left is right-heavy -&gt; leftRotate(v.left), rightRotate(v)
    <img alt="rightHeavyBST1" src="../rightHeavyBST1.png" />
    <img alt="rightHeavyBST2" src="../rightHeavyBST2.png" /></li>
</ul>
<p>If v is out of balanced and right-heavy:</p>
<ul>
<li>Case 1: v.right is balanced -&gt; leftRotate(v)</li>
<li>Case 2: v.right is left-heavy -&gt; leftRotate(v)</li>
<li>Case 3: v.right is right-heavy -&gt; rightRotate(v.right), leftRotate(v)</li>
</ul>
<pre><code class="language-java">import java.util.TreeSet;

TreeSet&lt;IntegerNode&gt; leftHalf;
TreeSet&lt;IntegerNode&gt; rightHalf;

void rebalance() {
    int leftSize = this.leftHalf.size();
    int rightSize = this.rightHalf.size();

    int diff = Math.abs(leftSize - rightSize);
    if (diff &gt; 1) {
        if (leftSize &gt; rightSize) {
            // Left is bigger, move the biggest item to right
            this.rightHalf.add(this.leftHalf.pollLast());
        } else {
            // Right is bigger, move the smallest item to left
            this.leftHalf.add(this.rightHalf.pollFirst());
        }
    }
}
</code></pre>
<h3 id="avl">AVL</h3>
<h4 id="insert_1">Insert</h4>
<ul>
<li>
<p>Summary:</p>
<ul>
<li>Insert key in BST</li>
<li>Walk up tree:<ul>
<li>At every step, check for balance</li>
<li>If out-of-balance, use rotations to rebalance and return</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Key observation:</p>
<ul>
<li>Only need to fix lowest out-of-balance node</li>
<li>Only need at most two rotations to fix</li>
</ul>
</li>
</ul>
<h4 id="delete_1">Delete</h4>
<ul>
<li>If v has two children, swap it with its successor</li>
<li>Delete node v from binary tree (and reconnect children)</li>
<li>For every ancestor of the deleted node:<ul>
<li>Check if it is height-balanced</li>
<li>If not, perform a rotation</li>
<li>Continue to the root</li>
</ul>
</li>
<li>Summary:<ul>
<li>Delete key from BST</li>
<li>Walk up tree:<ul>
<li>At every step, check for balance</li>
<li>If out-of-balance, use rotations to rebalance</li>
<li>continue to root</li>
</ul>
</li>
</ul>
</li>
<li>Key observation:<ul>
<li>Needs at most O(logn) rotations</li>
</ul>
</li>
</ul>
<pre><code class="language-java">import java.util.*;
import java.io.*;

class Node {
   int key, height;
   Node left, right;
   Node (int d) {
      key = d;
      height = 1;
   }
}

class AVLTree {
   Node root;
   int height (Node N) {
      if (N == null)
         return 0;
      return N.height;
   }

   int max (int a, int b) {
      return (a &gt; b) ? a : b;
   }

   Node rightRotate (Node y) {
      Node x = y.left;
      Node T2 = x.right;
      x.right = y;
      y.left = T2;
      y.height = max (height (y.left), height (y.right)) + 1;
      x.height = max (height (x.left), height (x.right)) + 1;
      return x;
   }

   Node leftRotate (Node x) {
      Node y = x.right;
      Node T2 = y.left;
      y.left = x;
      x.right = T2;
      x.height = max (height (x.left), height (x.right)) + 1;
      y.height = max (height (y.left), height (y.right)) + 1;
      return y;
   }

   int getBalance (Node N) {
      if (N == null)
         return 0;
      return height (N.left) - height (N.right);
   }

   Node insert (Node node, int key) {
      if (node == null)
         return (new Node (key));
      if (key &lt; node.key)
         node.left = insert (node.left, key);
      else if (key &gt; node.key)
         node.right = insert (node.right, key);
      else
         return node;
      node.height = 1 + max (height (node.left), height (node.right));
      int balance = getBalance (node);
      if (balance &gt; 1 &amp;&amp; key &lt; node.left.key)
         return rightRotate (node);
      if (balance &lt; -1 &amp;&amp; key &gt; node.right.key)
         return leftRotate (node);
      if (balance &gt; 1 &amp;&amp; key &gt; node.left.key) {
         node.left = leftRotate (node.left);
         return rightRotate (node);
      }
      if (balance &lt; -1 &amp;&amp; key &lt; node.right.key) {
         node.right = rightRotate (node.right);
         return leftRotate (node);
      }
      return node;
   }
}
</code></pre>
<h2 id="tries">Tries</h2>
<ul>
<li>Cost of comparing two strings in a tree: O(hL)</li>
<li>Cost in trie: O(L)</li>
<li>Space for storing a try: O(size of text * overhead)</li>
</ul>
<h2 id="dynamic-order-statistics">Dynamic Order Statistics</h2>
<ul>
<li>Select(k) : finds the node with rank k</li>
</ul>
<pre><code class="language-java">// augmented tree with weight
// O(logn)
Node select(k) {
    rank = m_left.weight + 1;
    if (k == rank) {
        return v;
    } else if (k &lt; rank) {
        return m_left.select(k);
    } else if (k &gt; rank) {
        return m_right.select(k–rank);
    }
}


// in-order traversal method
// O(n)
Node kthSmallest(int k) {
    Result result = new Result(0, null);
    inOrderTraversal(root, k, result);
    return result.result;
}

void inOrderTraversal(Node node, int k, Result result) {
    if (node == null || result.count &gt;= k) {
        return;
    }

    inOrderTraversal(node.left, k, result);

    result.count++;
    if (result.count == k) {
        result.result = node;
        return;
    }

    inOrderTraversal(node.right, k, result);
}

class Result {
    int count;
    Node result;

    Result(int count, Node result) {
        this.count = count;
        this.result = result;
    }
}
</code></pre>
<ul>
<li>Rank(v) : computes the rank of a node v</li>
</ul>
<pre><code class="language-java">// augmented tree with weight
// O(logn)
int rank(TreeNode node) {
    rank = node.left.weight + 1;
    while (node != null) {
        if (node.parent.left == node) {
            continue;
        } else {
            rank += node.parent.left.weight + 1;
        }
        node = node.parent;
    }
    return rank;
}

// recursion method
// worst case: O(n)
int rank(TreeNode node, int x) {
    if (node == null) {
        return 0;
    }
    if (node.value &lt;= x) {
        return 1 + rank(node.left, x) + rank(node.right,x);
    } else {
        return rank(node.left, x)
    }
}
</code></pre>
<h2 id="interval-trees">Interval Trees</h2>
<ul>
<li>Augment tree with maximum endpoint in subtree
    <img alt="intervalTree" src="../intervalTree.png" /></li>
</ul>
<pre><code class="language-java">class Node {
    int[] interval;
    int maxEnd;
    Node left, right;
    int height;

    Node(int[] interval) {
        this.interval = interval;
        this.maxEnd = interval[1];
        this.left = this.right = null;
        this.height = 1;
    }
}
</code></pre>
<h3 id="insert_2">Insert</h3>
<pre><code class="language-java">class IntervalTree {
    private int height(Node node) {
        return (node == null) ? 0 : node.height;
    }

    private int maxEnd(Node node) {
        return (node == null) ? Integer.MIN_VALUE : node.maxEnd;
    }

    private int getBalance(Node node) {
        return (node == null) ? 0 : height(node.left) - height(node.right);
    }

    private Node insert(Node root, int[] interval) {
        if (root == null) {
            return new Node(interval);
        }

        if (interval[0] &lt; root.interval[0]) {
            root.left = insert(root.left, interval);
        } else {
            root.right = insert(root.right, interval);
        }

        root.height = Math.max(height(root.left), height(root.right)) + 1;
        root.maxEnd = Math.max(root.interval[1], Math.max(maxEnd(root.left), maxEnd(root.right)));

        int balance = getBalance(root);

        // Left Heavy
        if (balance &gt; 1) {
            if (interval[0] &lt; root.left.interval[0]) {
                return rotateRight(root);
            } else {
                root.left = rotateLeft(root.left);
                return rotateRight(root);
            }
        }

        // Right Heavy
        if (balance &lt; -1) {
            if (interval[0] &gt; root.right.interval[0]) {
                return rotateLeft(root);
            } else {
                root.right = rotateRight(root.right);
                return rotateLeft(root);
            }
        }

        return root;
    }
}
</code></pre>
<h3 id="interval-search">Interval Search</h3>
<ul>
<li>Find interval containing x</li>
<li>Running time: O(logn)</li>
</ul>
<pre><code class="language-java">boolean isInInterval(Node c, int x) {
    return x &gt;= c.interval[0] &amp;&amp; x &lt;= c.interval[1];
}

int[] intervalSearch(int x) {
    Node c = root;
    while (c != null &amp;&amp; !isInInterval(c, x)) {
        if (c.left == null) {
            c = c.right;
        } else if (x &gt; c.left.maxEnd) {
            c = c.right;
        } else {
            c = c.left;
        }
    }
    return c.interval;
}
</code></pre>
<ul>
<li>All-Overlaps:</li>
<li>List all intervals that overlap with point</li>
<li>Running time if there are k overlapping intervals: O(k logn)</li>
<li>Repeat until no more intervals:<ul>
<li>Search for interval.</li>
<li>Add to list.</li>
<li>Delete interval.</li>
</ul>
</li>
<li>Repeat for all intervals on list:<ul>
<li>Add interval back to tree.</li>
</ul>
</li>
</ul>
<h2 id="1d-range-trees">1D Range Trees</h2>
<ul>
<li>Strategy:<ol>
<li>Use a binary search tree.</li>
<li>Store all points in the leaves of the tree. (Internal nodes store only copies.)</li>
<li>Each internal node v stores the MAX of any leaf in the left sub-tree.</li>
</ol>
</li>
</ul>
<h3 id="query">Query</h3>
<ul>
<li>Invariant:<ul>
<li>The search interval for a left-traversal at node v includes the maximum item in the subtree rooted at v.</li>
</ul>
</li>
<li>Algorithm:<ul>
<li>Find split node, takes O(logn)</li>
<li>Do left traversal</li>
<li>Do right traversal</li>
</ul>
</li>
<li>Query time complexity: O(k + logn), where k is number of points found</li>
<li>Preprocessing (buildtree) time complexity: O(n logn)</li>
<li>Total space complexity: O(n)</li>
</ul>
<p><img alt="rangeQuery1D" src="../rangeQuery1D.png" /></p>
<pre><code class="language-java">Node FindSplit(int low, int high) {
    Node v = root;
    done = false;
    while (!done) {
        if (high &lt;= v.key) {
            v = v.left;
        } else if (low &gt; v.key) {
            v = v.right;
        } else {
            done = true
        }
    }
    return v;
}

// LeftTraversal either:
// 1. Output all right sub-tree and recurse left.
// 2. Recurse right.

void LeftTraversal(Node v, int low, int high) {
    boolean isInRange = low &lt;= v.key;
    boolean isLeafNode = v.left == null &amp;&amp; v.right == null;

    if (isLeafNode &amp;&amp; isInRange) {
        System.out.println(v.key);
    }
    if (isInRange) {
        // if in range, take the all of right subtree's leafs
        AllLeafTraversal(v.right);
        LeftTraversal(v.left, low, high);
    } else {
        LeftTraversal(v.right, low, high);
    }
}

void RightTraversal(Node v, int low, int high) {
    boolean isInRange = v.key &lt;= high;
    boolean isLeafNode = v.left == null &amp;&amp; v.right == null;

    if (isLeafNode &amp;&amp; isInRange) {
        System.out.println(v.key);
    }

    if (isInRange) {
        // if in range, take the all of left subtree's leafs
        AllLeafTraversal(v.left);
        RightTraversal(v.right, low, high);
    } else {
        RightTraversal(v.left, low, high);
    }
}

void AllLeafTraversal(Node v) {
    if (v == null) {
        return;
    }

    // only leaf nodes are printed
    if (v.left == null &amp;&amp; v.right == null) {
        System.out.println(v.key);
    }
    AllLeafTraversal(v.left);
    AllLeafTraversal(v.right);
}

void Query(low, high) {
    Node v = FindSplit(low, high);
    LeftTraversal(v.left, low, high);
    RightTraversal(v.right, low, high);
}
</code></pre>
<h2 id="2d-range-trees">2D Range Trees</h2>
<ul>
<li>Build an x-tree using only x-coordinates.</li>
<li>For every node in the x-tree, build a y-tree out of nodes in subtree using only y-coordinates.</li>
<li>Query time: O((logn)^2 + k)<ul>
<li>O(logn) to find split node</li>
<li>O(logn) recursing steps</li>
<li>O(logn) y-tree-searches of cost O(logn)</li>
<li>O(k) enumerating output</li>
</ul>
</li>
<li>Space complexity: O(n logn)<ul>
<li>Each point appears in at most one y-tree per level</li>
<li>There are O(log n) levels</li>
</ul>
</li>
<li>Query cost: O((logn)^d + k)</li>
<li>buildTree cost: O(n (logn)^d-1)</li>
<li>Space: O(n (logn)^d-1)</li>
</ul>
<h1 id="priority-queue">Priority Queue</h1>
<table>
<thead>
<tr>
<th>Return Type</th>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>void</td>
<td>insert(Key k, Priority p)</td>
<td>insert k with priority p</td>
</tr>
<tr>
<td>Data</td>
<td>extractMin()</td>
<td>remove key with min. priority</td>
</tr>
<tr>
<td>void</td>
<td>decreaseKey(Key k, Priority p)</td>
<td>reduce the priority of key k to priority p</td>
</tr>
<tr>
<td>boolean</td>
<td>contains(Key k)</td>
<td>whether queue contains key k</td>
</tr>
<tr>
<td>boolean</td>
<td>isEmpty()</td>
<td>whether queue is empty</td>
</tr>
</tbody>
</table>
<ul>
<li>Sorted array<ul>
<li>Insert: O(n)</li>
<li>extractMax: O(1)</li>
</ul>
</li>
<li>Unsorted array<ul>
<li>insert: O(1)</li>
<li>extractMax: O(n)</li>
</ul>
</li>
<li>AVL tree (indexed by priority)<ul>
<li>insert: O(logn)</li>
<li>extractMax: O(logn)</li>
</ul>
</li>
<li>AVL tree and dictionary<ul>
<li>contains: O(1)</li>
<li>decreaseKey: O(logn)</li>
</ul>
</li>
</ul>
<h2 id="binary-max-heaps">Binary (Max) Heaps</h2>
<p><img alt="binaryHeap" src="../binaryHeap.png" /></p>
<ul>
<li>Heap ordering: <code>priority[parent] &gt;= priority[child]</code></li>
<li>Complete binary tree<ul>
<li>Every level is full, except possibly the last</li>
<li>All nodes are as far left as possible</li>
</ul>
</li>
<li>Height: O(logn) (maximum height is floor(logn))</li>
<li>Operations: O(logn)</li>
<li>Implements a max priority queue</li>
</ul>
<table>
<thead>
<tr>
<th>Return Type</th>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>void</td>
<td>insert(Key k, Priority p)</td>
<td>insert k with priority p</td>
</tr>
<tr>
<td>Data</td>
<td>extractMax()</td>
<td>remove key with max priority</td>
</tr>
<tr>
<td>void</td>
<td>increaseKey(Key k, Priority p)</td>
<td>increase the priority of key k to priority p</td>
</tr>
<tr>
<td>void</td>
<td>decreaseKey(Key k, Priority p)</td>
<td>reduce the priority of key k to priority p</td>
</tr>
<tr>
<td>Data</td>
<td>delete(Key k)</td>
<td>delete k from heap</td>
</tr>
</tbody>
</table>
<ul>
<li>left(x) = 2 * x + 1</li>
<li>right(x) = 2 * x + 2</li>
<li>parent(x) = floor((x - 1) / 2)</li>
<li>Where x is the position of the node in the array</li>
</ul>
<h3 id="insert_3">Insert</h3>
<ol>
<li>Add leaf of new node at leftmost position</li>
<li>Bubble up (swap with parent) until condition <code>priority[parent] &gt;= priority[child]</code> fulfilled</li>
</ol>
<pre><code class="language-java">bubbleUp(Node v) {
    while (v != null) {
        if (priority(v) &gt; priority(parent(v))) {
            swap(v, parent(v));
        } else {
            return;
        }
        v = parent(v);
    }
}


insert(Priority p, Key k) {
    Node v = tree.insert(p, k);
    bubbleUp(v);
}
</code></pre>
<h3 id="decreasekey">DecreaseKey</h3>
<ol>
<li>Update priority</li>
<li>Bubble down (swap with child that has higher priority)</li>
</ol>
<pre><code class="language-java">bubbleDown(Node v) {
    while (!isLeaf(v)) {
        leftP = priority(left(v));
        rightP = priority(right(v));
        maxP = max(leftP, rightP, priority(v));
        if (leftP == max) {
            swap(v, left(v));
            v = left(v);
        } else if (rightP == max) {
            swap(v, right(v));
            v = right(v);
        } else {
            return;
        }
    }
}
</code></pre>
<h3 id="delete_2">Delete</h3>
<ol>
<li>Swap deleted node with last node (which is last element in array)</li>
<li>Remove last node</li>
<li>
<p>Bubble down swapped node
   <img alt="deleteHeap" src="../deleteHeap.png" /></p>
</li>
<li>
<p>ExtractMax:</p>
<ul>
<li>delete(root);</li>
</ul>
</li>
</ol>
<h3 id="heap-vs-avl-tree">Heap vs AVL Tree</h3>
<ul>
<li>Same asymptotic cost for operations</li>
<li>Faster real cost (no constant factors)</li>
<li>Simpler: no rotations</li>
<li>Slightly better concurrency</li>
</ul>
<h2 id="heapsort">HeapSort</h2>
<ul>
<li>Running time: O(n logn)</li>
<li>In-place</li>
<li>Deterministic, and will always take O(n logn)</li>
<li>Faster than MergeSort, a little slower than QuickSort</li>
<li>
<p>Not stable</p>
</li>
<li>
<p>Unsorted list --&gt; heap (running time: O(n)), specifically 2 * O(n)</p>
<ul>
<li>Base case: each leaf is a heap</li>
<li>Recursion: siblings + parent nodes = heap (bubbleDown)</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// int[] A = array of unsorted integers
for (int i = n - 1; i &gt;= 0; i--) {
    bubbleDown(i, A); // O(height), but more than n/2 of nodes are leaves with height = 0
}

</code></pre>
<ol>
<li>Heap --&gt; sorted list () (running time: O(n logn))<ul>
<li>Fill array from last position to first position, by recursively calling extractMax()</li>
</ul>
</li>
</ol>
<pre><code class="language-java">//int[] A = array stored as a heap
for (int i = n - 1; i &gt;= 0; i--) {
    int value = extractMax(A); //O(logn)
    A[i] = value;
}
</code></pre>
<h1 id="disjoint-set">Disjoint Set</h1>
<ul>
<li>Determine if objects are connected</li>
</ul>
<h2 id="quick-find-using-an-int-componentid">Quick Find: using an int[] componentId</h2>
<ul>
<li>Store component identifier of each object</li>
<li>Find: O(1)<ul>
<li>Finds whether p and q are connected</li>
</ul>
</li>
</ul>
<pre><code class="language-java">boolean find(int p, int q) {
    return(componentId[p] == componentId[q]);
}
</code></pre>
<ul>
<li>Union: O(n)<ul>
<li>Make p and q have the same componentId</li>
<li>Traverse the component identifier array: if id = q's id, update to be p's id</li>
</ul>
</li>
</ul>
<pre><code class="language-java">void union(int p, int q) {
    updateComponent = componentId[q];
    for (int i=0; i&lt;componentId.length; i++) {
        if (componentId[i] == updateComponent) {
            componentId[i] = componentId[p];
        }
    }
}
</code></pre>
<h3 id="quick-union-using-an-int-parent">Quick Union: using an int[] parent</h3>
<ul>
<li>
<p>Two objects are connected if they are part of the same tree</p>
</li>
<li>
<p>Find: O(n)</p>
<ul>
<li>Traverse up the tree from given node, to find parent</li>
<li>If final parents are the same, they are connected</li>
</ul>
</li>
</ul>
<pre><code class="language-java">boolean find(int p, int q) {
    while (parent[p] != p) {
        p = parent[p];
    }
    while (parent[q] != q) {
        q = parent[q];
    }
    return (p == q);
}
</code></pre>
<ul>
<li>Union: O(n), height of tree can be n<ul>
<li>Traverse up the tree from given node, to find parent</li>
<li>Set parent of p to be q</li>
</ul>
</li>
</ul>
<pre><code class="language-java">void union(int p, int q) {
    while (parent[p] != p) {
        p = parent[p];
    }
    while (parent[q] != q) {
        q = parent[q];
    }
    parent[p] = q;

}
</code></pre>
<h3 id="weighted-union">Weighted Union</h3>
<ul>
<li>Choose the larger element to be the parent during union</li>
<li>Maximum depth of tree: O(logn)</li>
<li>Running time of <strong>find</strong>: O(logn)</li>
<li>Running time of <strong>union</strong>: O(logn)</li>
</ul>
<pre><code class="language-java">union(int p, int q) {
    while (parent[p] !=p) {
        p = parent[p];
    }
    while (parent[q] !=q) {
        q = parent[q];
    }
    if (size[p] &gt; size[q]) {
        parent[q] = p;   // Link q to p
        size[p] = size[p] + size[q];
    } else {
        parent[p] = q; // Link p to q
        size[q] = size[p] + size[q];
    }
}
</code></pre>
<h3 id="weighted-union-with-path-compression">Weighted Union with Path Compression</h3>
<ul>
<li>After finding root, set the parent of each traversed node to the root</li>
<li><img alt="pathCompression" src="../pathCompression.png" /><ul>
<li>Tree height is compressed</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Takes O(logn) time
findRoot(int p) {
    root = p;
    while (parent[root] != root) {
        root = parent[root];
    }

    while (parent[p] != p) {
        temp = parent[p];
        parent[p] = root;
        p = temp;
    }
    return root;
}

union(int p, int q) {
    p = findRoot(p);
    q = findRoot(q);

    if (size[p] &gt; size[q]) {
        parent[q] = p;   // Link q to p
        size[p] = size[p] + size[q];
    } else {
        parent[p] = q; // Link p to q
        size[q] = size[p] + size[q];
    }
}
</code></pre>
<ul>
<li>Starting from empty, any sequence of m union/find operations on n objects takes: O(n + mα(m, n))time.<ul>
<li>Path compression is helpful with more union/ find operations</li>
<li>First operation will still take the same amount of time (+ path compression for future operations)</li>
</ul>
</li>
<li>α = ackermann function (between O(1) and O(logn))</li>
<li>Running time of <strong>find</strong>: α(m, n)</li>
<li>Running time of <strong>union</strong>: α(m, n)</li>
<li><img alt="unionFindSummary" src="../unionFindSummary.png" /></li>
</ul></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/jquery-3.6.0.min.js"></script>
        <script src="../../js/bootstrap.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>

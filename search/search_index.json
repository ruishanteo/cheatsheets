{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home This is a list of cheatsheets and notes. Links: GEA1000 midterms cheatsheet GEA1000 finals cheatsheet CS2040S midterms cheatsheet CS2040S finals cheatsheet CS2103/T notes DSA notes CS2106 notes CS2106 finals cheatsheet CS3213 notes UNC PSYC101 notes","title":"Home"},{"location":"#home","text":"This is a list of cheatsheets and notes. Links: GEA1000 midterms cheatsheet GEA1000 finals cheatsheet CS2040S midterms cheatsheet CS2040S finals cheatsheet CS2103/T notes DSA notes CS2106 notes CS2106 finals cheatsheet CS3213 notes UNC PSYC101 notes","title":"Home"},{"location":"cs2103t/cs2103t-notes/","text":"CS2103/T Notes CS2103/T Notes Java Varargs Programming Paradigm Object-Oriented Programming (OOP) Requirements Non-functional Requirements Quality of Requirements Gathering Requirements Specifying Requirements Design Design Fundamentals Modeling Design Patterns Singleton Pattern Abstraction Occurrence Pattern Facade Pattern Command Pattern Model View Controller (MVC) Pattern Observer Pattern Design Approaches Principles S ingle Responsibility Principle O pen-Closed Principle L iskov Substitution Principle I nterface Segregation Principle D ependency Inversion Principle Separation of Concerns Principle Law of Demeter YAGNI Principle DRY Principle Brooks' Law UML Class Diagrams Notation \u2014 Class Diagrams Associations \u2014 Class Diagrams Navigability Multiplicity Dependencies Composition (Has-A) Aggregation Inheritance (Is-A) Objects Diagrams Notation \u2014 Objects Diagrams Sequence Diagrams Notation \u2014 Sequence Diagrams OODM Activity Diagrams Notation \u2014 Activity Diagrams Project Management Revision Control Project Planning Work Breakdown Structure Milestones Buffers Issue Trackers GANTT Charts PERT Charts SDLC Process Models Sequential Models Iterative Models Agile Models XP Scrum Unified Process CMMI Coding Standards Naming Layout Statements Classes and interfaces Methods Types Variables Loops Conditionals Comments Implementation Coding Quality Refactoring Documentation Types Guidelines Error Handling Integration Reuse Quality Assurance Code Reviews Static Analysis Formal Verification Test Case Design Testing Regression Testing Developer Testing Unit Testing Integration Testing System Testing Alpha and Beta Testing Dogfooding Exploratory and Scripted Testing User Acceptance Testing Test Automation Testing Java Varargs Syntactic sugar type feature that allows writing a method that can take a variable number of arguments. public static void search(String ... keywords){ // method body } Programming Paradigm Guides programmers to analyse programmig problems ad structure programmig solutions in a specific way Object-Oriented Programming (OOP) Views the world as a network of interacting objects Tries to create a similar object network inside the computer's memory so that a similar result can be achieved programmtically Requirements A software requirement specifies a need to be fulfilled by the software product. A software project may be Brownfield project i.e., develop a product to replace/update an existing software product Greenfield project i.e., develop a totally new system from scratch Requirements come from stakeholders Requirements can be divided into: Functional requirements specify what the system should do Non-functional requirements specify the constraints under which the system is developed and operated Non-functional Requirements Specify the constraints under which the system is developed and operated NFRs are easier to miss Sometimes NFRs are critical to the success of the software Quality of Requirements Characteristics of well-defined requirements: Unambiguous Testable (verifiable) Clear (concise, terse, simple, precise) Correct Understandable Feasible (realistic, possible) Independent Atomic Necessary Implementation-free (i.e. abstract) Set of requirements as a whole should be: Consistent Non-redundant Complete Gathering Requirements Brainstorming session No \"bad\" ideas (aim is to generate ideas; not to validate them) Product surveys Studying existing products can unearth shortcomings of existing solutions that can be addressed by a new product Observation Observing users in their natural work environment can uncover product requirements User surveys Surveys can be used to solicit responses and opinions from a large number of stakeholders regarding a current product or a new product Interviews Interviewing stakeholders and domain experts can produce useful information about project requirements Focus groups Focus groups are a kind of informal interview within an interactive group setting Prototyping A prototype is a mock up, a scaled down version, or a partial system constructed to get users feedback to validate a technical concept (a \"proof-of-concept\" prototype) to give a preview of what is to come, or to compare multiple alternatives on a small scale before committing fully to one alternative for early field-testing under controlled conditions Specifying Requirements Feature list A list of features of a product grouped according to some criteria such as aspect, priority, order of delivery, etc User stories Short, simple descriptions of a feature told from the perspective of the person who desires the new capability, usually a user or customer of the system Format: As a {user type/role} I can {function} so that {benefit} {benefit} can be omitted if it is obvious Can: Add more characteristics to the {user role} , e.g. As a forgetful user, ... Write user stories at various levels (epic/theme) Add conditions of satisfaction to a user story Include: Priority: how important the user story is Size: the estimated effort to implement the user story Urgency: how soon the feature is needed Convenient for scoping, estimation, and scheduling Less details compared to traditional requirements specifications Captures non-functional requirements too because even NFRs must benefit some stakeholder Handy for recording requirements during early stages of requirements gathering Use cases Set of sequences of actions, including variants, that a system performs to yield an observable result of value to an actor Describes an interaction between the user and the system for a specific functionality of the system Only externally visible behavior (omit UI details) Actor : An actor (in a use case) is a role played by a user. can be a human or another system. not part of the system; they reside outside the system. Main Success Scenario (MSS) describes the most straightforward interaction for a given use case, which assumes that nothing goes wrong Extensions are \"add-on\"s to the MSS that describe exceptional/alternative flow of events Glossary Serves to ensure that all stakeholders have a common understanding of the noteworthy terms, abbreviations, acronyms etc Supplementary requirements This section can be used to capture requirements that do not fit elsewhere Typically, this is where most Non-Functional Requirements will be listed Design Design Fundamentals Abstraction Data abstraction: abstracting away the lower level data items and thinking in terms of bigger entities Control abstraction: abstracting away details of the actual control flow to focus on tasks at a higher level Coupling Coupling is a measure of the degree of dependence between components, classes, methods, etc. Low coupling indicates that a component is less dependent on other components High coupling is discouraged: maintenance, integration, testing and reuse of module is harder. Zero coupling is not possible for non-trivial software. Types: content, common/ global, data, external, subclass, temporal Modeling A model provides a simpler view of a complex entity because a model captures only a selected aspect. This omission of some aspects implies models are abstractions. Multiple models of the same entity may be needed to capture it fully. Models can be used as a blueprint for creating software. Design Patterns An elegant reusable solution to a commonly recurring problem within a given context in software design Common format to describe a pattern: Context: The situation or scenario where the design problem is encountered Problem: The main difficulty to be resolved Solution: The core of the solution. It is important to note that the solution presented only includes the most general details, which may need further refinement for a specific context Anti-patterns (optional): Commonly used solutions, which are usually incorrect and/or inferior to the Design Pattern. Consequences (optional): Identifying the pros and cons of applying the pattern Other useful information (optional): Code examples, known uses, other related patterns, etc 23 Design Patterns divided into 3 categories: Creational: About object creation. They separate the operation of an application from how its objects are created. Abstract Factory, Builder, Factory Method, Prototype, Singleton Structural: About the composition of objects into larger structures while catering for future extension in structure. Adapter, Bridge, Composite, Decorator, Facade , Flyweight, Proxy Behavioral: Defining how objects interact and how responsibility is distributed among them. Chain of Responsibility, Command , Interpreter, Template Method, Iterator, Mediator, Memento, Observer , State, Strategy, Visitor Singleton Pattern When to use: Requires only one instance of a class There is a risk of creating multiple objects by mistake Creating such multiple objects has real negative consequences How to use: Private constructor with a public class-level method to access the single instance Optional <<Singleton>> UML stereotype to indicate role Pros: Easy to apply Effective in achieving its goal with minimal extra work Provides an easy way to access the singleton object from anywhere in the code base Cons: Acts like a global variable that increases coupling across the code base In testing, its difficult to replace Singleton objects with stubs (static methods cannot be overridden). In testing, singleton objects carry data from one test to another Abstraction Occurrence Pattern When to use: Group of similar entities with common information Also differing in significant ways How to use: Split entity into 2 classes 1 object for common information ( Abstraction ) and many for unique information ( Occurrence ) Facade Pattern When to use: Components need to access functionality deep inside other components. How to use: Create a Facade class that sits between users of component and component internals All access to the component happens through the Facade class Command Pattern When to use: Have a system is required to execute a number of commands Each doing a different task How to use: Create a general Command object such that it can be used without knowing the exact type of command (using polymorphism) Example: Command interface in AB3 where all Commands implement this interface and have an execute method Model View Controller (MVC) Pattern When to use: Support storage/retrieval of information Displaying of information to the user (often via multiple UIs having different formats) Changing stored information based on external inputs How to use: Split the data, presentation and control logic into 3 parts: View: Displays data, interacts with the user, and pulls data from the model if necessary. Controller: Detects UI events such as mouse clicks and button pushes, and takes follow up action. Updates/changes the model/view when necessary. Model: Stores and maintains data. Updates the view if necessary. In a simple UI where there is only one view, Controller and View can be combined as one class. Observer Pattern When to use: An object (possibly more than one) needs to be notified when a change happens to another object How to use: Force the communication through an interface known to both parties Have all observers implement an Observer interface Add all observers to the observee's observer list When there is an update, notify all added observers Design Approaches Top-down: Design the high-level design first and flesh out the lower levels later Useful when designing big and novel systems where the high-level design needs to be stable before lower levels can be designed Bottom-up: Design lower level components first and put them together to create the higher-level systems later. Not usually scalable for bigger systems. One instance where this approach might work is when designing a variation of an existing system or re-purposing existing components to build a new system Mix: Design the top levels using the top-down approach but switch to a bottom-up approach when designing the bottom levels Agile: Emergent and not defined up front Overall system design will emerge over time, evolving to fulfill new requirements and take advantage of new technologies as appropriate Just enough initial architectural modeling at the very beginning of a project to get your team going Does not produce a fully documented set of models in place before you may begin coding Principles S ingle Responsibility Principle Definition: A class should have one, and only one, reason to change If a class has only one responsibility, it needs to change only when there is a change to that responsibility Good way of identifying classes during the design phase O pen-Closed Principle Definition: A module should be open for extension but closed for modification. That is, modules should be written so that they can be extended, without requiring them to be modified Aims to make a code entity easy to adapt and reuse without needing to modify the code entity itself Separating the specification (i.e. interface) of a module from its implementation L iskov Substitution Principle Definition: Derived classes must be substitutable for their base classes Subclass should not be more restrictive than the behavior specified by the superclass LSP is not followed when substituting a subclass object for a superclass object breaks the functionality of the code I nterface Segregation Principle Definition: No client should be forced to depend on methods it does not use Can depend on an interface with just the methods it need, instead of the entire class D ependency Inversion Principle Definition: High-level modules should not depend on low-level modules. Both should depend on abstractions Abstractions should not depend on details. Details should depend on abstractions Separation of Concerns Principle Definition: To achieve better modularity, separate the code into distinct sections, such that each section addresses a separate concern A concern is a set of information that affects the code of a computer program Reduces functional overlaps Limits ripple effect when changes are introduced to a specific part of system Can be applied at the class level as well as higher levels Lead to higher cohesion and lower coupling Law of Demeter Definition: An object should have limited knowledge of another object An object should only interact with objects that are closely related to it Aims to prevent objects from navigating the internal structures of other objects Method foo of an object obj should invoke only the methods of the following kinds of objects: Object obj itself Objects passed as parameters of foo Objects created/instantiated in foo (directly or indirectly) Objects from the direct association of obj YAGNI Principle Definition: You Aren't Gonna Need It! Do not add code simply because 'you might need it in the future' Some capability you presume your software needs in the future should not be built now Do not have perfect information about the future The extra work might go to waste when some of your predictions fail to materialize DRY Principle Definition: Don't Repeat Yourself Every piece of knowledge must have a single, unambiguous, authoritative representation within a system Guards against the duplication of information Examples of violations: Functionality being implemented twice even if the two implementations are different Value of a system-wide timeout being defined in multiple places Brooks' Law Definition: Adding people to a late project will make it later The additional communication overhead will outweigh the benefit of adding extra manpower, especially if done near a deadline UML Class Diagrams Used to model class structures of an OO solution Describe the structure (but not behaviour) of OOP solution Notation \u2014 Class Diagrams Visibility: + for public | - for private | # for protected | ~ package private (default) Class-level methods/ attributes are underlined <<interface>> <<enumeration>> {abstract} or abstract OK to omit: Methods Associations \u2014 Class Diagrams Association roles appears on end that plays that role An association can be shown as a line between the two classes or as an attribute in one of the classes (but not both). Navigability Solid arrow The concept of which object in the association knows about the other object. E.g. Navigability is from Box to Rope , b will have reference to r but not vice versa. One can navigate from b to r using b 's object reference of r . Multiplicity 0..X Number of X is on end nearer X. The aspect of an OOP solution that dictates how many objects take part in each association. Dependencies Dotted line A need for one class to depend on another without having a direct association in the same direction. Composition (Has-A) Shaded diamond Diamond is on the end of the whole. A composition is an association that represents a strong whole-part relationship. When the whole is destroyed, parts are destroyed too (parts cannot exist without whole). Cannot be cyclical links. Aggregation Non-shaded/hollow diamond Diamond is on the end of the container. An aggregation is an association that represents a container-contained relationship. Similar to that of composition except the containee object can exist even after the container object is deleted. Weaker relationship than composition. Aggregation represents a container-contained relationship. It is a weaker relationship than composition. Inheritance (Is-A) Triangle arrow (inheriting class - class or interface - interface) Triangle arrow with dotted line: implementing an interface Does not matter whether the triangle is filled or empty Points to parent class Inheritance implies the derived class can be considered as a sub-type of the base class (and the base class is a super-type of the derived class), resulting in an is a relationship. Objects Diagrams Used to model object structure of an OO solution Multiple object diagrams can correspond to a single class diagram Notation \u2014 Objects Diagrams Object names are underlined If there is inheritance, show either parent class or child class (not both) MUST omit: Methods Multiplicities OK to omit: Object name Variable name/ value Attributes compartment (if not relevant) Association labels/ roles (if not relevant) Sequence Diagrams Notation \u2014 Sequence Diagrams Arrows representing method calls: solid lined arrows Arrows representing method returns: dashed lined arrows Class/object name is not underlined Use an X at the end of the lifeline of an object to show its deletion Self-invocation calls is denoated by an arrow from the bar to itself Method calls to static methods are received by the class itself You can use <<class>> to show that a participant is the class itself All frames should use a rectangle with a clip on the bottom-right corner loop frame: indicate a loop (can execute 0 times) loop [condition] alt frame: indicate alternative paths alt [condition] No more than one alternative partitions be executed in an alt frame opt frame: indicate optional paths opt [condition] ref frame: allow a segment of the interaction to be omitted and shown as a separate sequence diagram ref diagram title (in the original diagram) sd diagram title (sub-sequence diagram shown in this frame) par frame: indicate parallel paths (can happen in any order) The corresponding Java implementation is likely to be multi-threaded- Keywords are loop (while), opt (if) and alt (if elseif) OK to omit: Activation bar Return arrows Activation bar of self-invocation OODM Similar to class diagram notation but must omit: methods navigability Do not contain solution-specific classes (classes that do not exist in the problem domain e.g. DatabaseConnection) Activity Diagrams Models workflows Notation \u2014 Activity Diagrams Action : rounded corners rectangle Denotes a single step in an activity. Control flow : arrow-head line Denotes the flow of control from one action to the next. Start node : shaded circle Denotes the start of the activity End node : inner shaded circle with with a surrounding circle Denotes the end of the activity Branch node : diamond square with two [conditions] Denotes the start of alternate path. Exactly one of the guard conditions should be true. Merge node : diamond square Denotes the end of alternative paths Fork node : bar Denotes the start of concurrent flows of cotntrol. Join node : bar Denotes the end of parallel paths Rake : rake symbol Denotes that the action is described in another subsidiary activity diagram Swim lanes : partition Denotes who is doing which action (also called swimlane diagrams) OK to do: Multiple arrows can start from the same corner of a branch node Omit merge node if it there's no ambiguity Omit [Else] condition. Project Management Revision Control Process of managing multiple versions of a piece of information Will track the history and evolution of your project Makes it easier for to collaborate Repository is the database that stores the revision history. Using History Tag a specific commit to identify To see what changed: diff To restore the state of the working directory at point in the past: checkout the commit Remote Repositories git clone a repo to create a (local) copy Original repo is referred to as upstream repo git pull from one repo to another git push new commits in one repo to another Fork is a remote copy of a remote repo Pull request is a mechanism for contributing code to a remote repo Branching is the process of evolving multiple versions of the software in parallel. Merge conflicts happen when you try to merge two branches that had changed the same part of the code and the revision control software (RCS) cannot decide which changes to keep. Centralized RCS uses a central remote repo that is shared by the team. Distributed RCS allows multiple remote repos and pulling and pushing can be done among them in arbitrary ways. Forking flow : the 'official' version of the software is kept in a remote repo designated as the 'main repo'. All team members fork the main repo and create pull requests from their fork to the main repo. Feature branch workflow is similar to forking workflow except there are no forks. Centralized flow is similar to the feature branch workflow except all changes are done in the master branch. Project Planning Work Breakdown Structure Depicts information about tasks and their details in terms of subtasks Can also include prerequisite tasks and effort estimates for each task Effort is traditionally measured in man hour/day/month All tasks should be well-defined Task ID Task Estimated Effort Prerequisite Task A Analysis 1 man hour - B Design 2 man day A Milestones End of a stage which indicates significant progress Should account for dependencies and priorities when deciding on the features to be delivered at a certain milestone Each intermediate product release is a milestone Buffers Time set aside to absorb unforeseen delays Very important to include because effort/time estimations are notoriously hard Do not inflate task estimates to create hidden buffers (have explicit buffers instead) Reason: With explicit buffers, it is easier to detect incorrect effort estimates which can serve as feedback to improve future estimates Issue Trackers Issue trackers (sometimes called bug trackers) are commonly used to track task assignment and progress GANTT Charts 2-D bar-chart Drawn as time vs tasks Solid bar represents the main task (composed of a number of subtasks) Grey bars represent subtasks Diamond shape indicates an important deadline/deliverable/milestone PERT Charts Program Evaluation Review Technique Shows the order/sequence of tasks Directed graph: Nodes or vertices capture the effort estimations of tasks Arrows depict the precedence between tasks Helps determine the following: Order of tasks Which tasks can be done concurrently Shortest possible completion time Critical path (path where any delay can directly affect the project duration, hence it is important to ensure tasks on the critical path are completed on time) SDLC Process Models Software development goes through different stages such as requirements, analysis, design, implementation and testing Collectively known as the software development life cycle (SDLC) Sequential Models Views software development as a linear process Also called waterfall model When one stage of the process is completed, it produces some artifacts to be used in the next stage A strict sequential model project moves only in the forward direction Pros: Work well for a project that produces software to solve a well-understood problem Cons: Real-world projects often tackle problems that are not well-understood at the beginning Iterative Models Advocates producing the software by going through several iterations Each iteration produces a new version of the product that builds on the version produced in previous iteration Breadth-first An iteration evolves all major components and all functionality areas in parallel Depth-first An iteration focuses on fleshing out only some components or some functionality area. Early depth-first iterations might not produce a working product. A project can be done as a mixture of breadth-first and depth-first iterations Agile Models XP Extreme programming Stresses customer satisfaction Aims to make developers confidently respond to changing requirements (even late in life cycle) Emphasizes teamwork Improve in: communication, simplicity, feedback, respect and courage Has a set of simple rules Scrum Scrum is a process skeleton that contains sets of practices and predefined roles. The main roles in Scrum are: The Scrum Master , who maintains the processes (typically in lieu of a project manager). The Product Owner , who represents the stakeholders and the business. The Team, a cross-functional group who do the actual analysis, design, implementation, testing, etc. A Scrum project is divided into iterations called Sprints . A key principle of Scrum is its recognition that during a project the customers can change their minds about what they want and need. The daily scrum meeting is not used as a problem-solving or issue resolution meeting. Issues that are raised are taken offline and usually dealt with by the relevant subgroup immediately after the meeting. Members answer these questions What did you do yesterday? What will you do today? Are there any impediments in your way? Unified Process Flexible and customizable process model framework Consists of four phases: inception, elaboration, construction and transition Phase Activities Typical Artifacts Inception Understand the problem and requirements Communicate with customer Plan the development effort Basic use case model Rough project plan Project vision and scope Elaboration Refine and expand requirements Determine a high-level design System architecture Various design models Prototype Construction Major implementation effort to support the use cases identified Design models are refined and fleshed out Testing of all levels are carried out Multiple releases of the system Test cases of all levels System release Transition Ready the system for actual production use Familiarize end users with the system Final system release Instruction manual CMMI Capability Maturity Model Integration Defines 5 maturity levels for a process (specifies criteria): Level 1: Initial Processes unpredictable, poorly controlled and reactive Level 2: Managed Processes characterised for projects and is often reactive Level 3: Defined Processes characterised for organisations and is proactive Level 4: Quantitatively Managed Processes measured and controlled Level 5: Optimizing Focus on process improvement Coding Standards Naming Names representing packages should be in all lower case. Class/ enum names must be nouns and written in PascalCase. Variable names must be in camelCase. Constant names must be in SCREAMING_SNAKE_CASE. Names representing methods must be verbs and written in camelCase. Abbreviation and acronyms should not be uppsercase when used as part of a name. All names should be written in English. Variables with a large scope should have long names, variables with a small scope can have short names. Boolean variables/ methods should be named to sound like booleans. Plural form should be used on names representing a collection of objects. Iterator variables can be called i, j, k. Associated constants should have a common prefix. Layout Basic indentation should be 4 spaces. Line length should be no longer than 120 characters. Place line break to improve readability. Use egyptian style brackets. Method definitions should have the following form: public void someMethod() throws SomeException { ... } if-else class of statements should have the following form: if (condition) { statements; } for statement should have the following form: for (initialization; condition; update) { statements; } while statement should have the following form: while (condition) { statements; } switch statement should have the following form: switch (condition) { case ABC: statements; //Fallthrough case DEF: statements; break; } try-catch statement should have the following form: try { statements; } catch (Exception exception) { statements; } White space within a statement Operators should be surrounded by a space character Java reserved words should be followed by a white space Commas should be followed by a white space Colons should be surrounded by white space when used as binary/ ternary operator Logical units within a block should be separated by one blank line Statements Put every class in a package Put related classes in a single package The ordering of import statements must be consistent Imported classes should always be listed explicity (not *) Classes and interfaces Class/Interface documentation (Comments) class or interface statement Class (static) variables in the order public, protected, package (no access modifier), private Instance variables in the order public, protected, package (no access modifier), private Constructors Methods (no specific order) Methods Method modifiers should be given in the following order: <access> static abstract synchronized <unusual> final native Types Array specifiers must be attached to the type not the variable int[] a = new int[20]; Variables Variables should be initialized where they are declared and they should be declared in the smallest scope possible. Class variables should never be declared public. Avoid unnecessary use of this with fields. Loops Loop body should be wrapped by curly brackets irrespective of how many lines there are in the body. Conditionals Conditional should be put on a separate line. Single statement conditionals should still be wrapped by curly brackets. Comments All comments should be written in English. Write descriptive header comments for all public classes/ methods. All non-trivial private methods should carry header comments. Javadoc comments should have the following form: /** * Returns lateral location of the specified position. * If the position is unset, NaN is returned. * * @param x X coordinate of position. * @param y Y coordinate of position. * @param zone Zone of position. * @return Lateral location. * @throws IllegalArgumentException If zone is <= 0. */ public double computeLocation(double x, double y, int zone) throws IllegalArgumentException { //... } Comments should be indented relative to their position in the code. while (true) { // Do something something(); } Implementation Coding Quality Avoid long methods Avoid deep nesting Avoid complicated expressions Avoid magic numbers Make the code obvious Structure code logically Do not 'trip up' reader Avoid unused paramters in method signature Similar things that look different Different things that look similar Multiple statements in the same line Practice KISSing Keep it simple, stupid Do not try to write 'clever' code Avoid premature optimizations SLAP hard Single Level of Abstraction Principle Avoid having multiple levels of abstraction within a code fragment Make the happy path prominent Naming: Use nouns for things and verbs for actions Use standard words Use name to explain Not too long, not too short Avoid misleading names Refactoring The process of improving a program's internal structure in small steps without modifying its external behavior is called refactoring Refactoring is not rewriting and not bug fixing (alters external behaviour). Benefits: hidden bugs become easier to spot improve performance Refactoring can result in regression Consolidate Duplicate Conditional Fragments // BEFORE if (isSpecialDeal()) { total = price * 0.95; send(); } else { total = price * 0.98; send(); } // AFTER if (isSpecialDeal()) { total = price * 0.95; } else { total = price * 0.98; } send(); Extract Method (opposite of this is inline method) from: //BEFORE void printOwing() { printBanner(); // print details System.out.println(\"name: \" + name); System.out.println(\"amount \" + getOutstanding()); } //AFTER void printOwing() { printBanner(); printDetails(getOutstanding()); } void printDetails(double outstanding) { System.out.println(\"name: \" + name); System.out.println(\"amount \" + outstanding); } Documentation Developer-as-user: API documentaion or tutorial-style instructional documentation Developer-as-maintainer: how a system or component is designed implemented and tested Types Tutorials (learning-oriented) How-to guides (goal-oriented) Explanation (understanding-oriented) Reference (information-oriented) Guidelines Top-down, not bottom-up The reader can travel down a path she is interested in until she reaches the component she is interested to learn in-depth Comprehensibility Use plenty of diagrams, examples, simple and direct explanations Document minimally but sufficiently 'just enough' developer documentation Error Handling Exceptions are used to deal with 'unusual' but not entirely unexpected situations that the program might encounter at runtime. After a method throws an exception, the runtime system attempts to find something to handle it in the call stack. Assertions are used to define assumptions about the program state so that the runtime can verify them. Assertions can be disabled without modifying the code. Java disables assertions by default. Assertions are used to define assumptions about the program state so that the runtime can verify them. Recommended that assertions be used liberally in the code. assertEquals is a JUnit method and only used in test classes. Logging is the deliberate recording of certain information during a program execution for future reference. Defensive programming is proactively eliminating any room for things to go wrong. Enforcing compulsory associations Enforcing 1-to-1 association Enforcing referential integrity (prevents case where A says B is X but B says B is Y) Design-by-contract approach is an approach for designing software that requires defining formal, precise and verifiable interface specifications for software components. Code first checks if the preconditions have been met. Integration Timing and frequency: Late and One Time : wait till all components are completed and integrate all finished components near the end of the project Not reccommended because integration often causes many component incompatibilities which can lead to delivery delays Early and Frequent : integrate early and evolve each part in parallel, in small steps, re-integrating frequently Extent: Big-bang integration : integrate all components at the same time Not reccommended because it will uncover too many problems at the same time Incremental integration : integrate a few components at a time (integration problems surface in a more manageable way) Direction: Top-down integration : higher-level components are integrated before bringing in the lower-level components +: Higher-level problems can be discovered early -: Requires the use of stubs in place of lower level components Bottom-up integration : the reverse of top-down integration When integrating lower level components, drivers may be needed to test the integrated components, because UI may not be integrated yet Sandwich integration : a mix of top-down and bottom-up approaches, do both and meet in the middle Reuse API : An Application Programming Interface (API) specifies the interface through which other programs can interact with a software component. It is a contract between the component and its clients. Library : A library is a collection of modular code that is general and can be used by other programs. Frameworks : A software framework is a reusable implementation of a software (or part thereof) providing generic functionality that can be selectively customized to produce a specific application. Some frameworks provide a complete implementation of a default behavior which makes them immediately usable. (e.g. Eclipse) Platforms : A platform provides a runtime environment for applications. Cloud computing : Cloud computing is the delivery of computing as a service over the network, rather than a product running on a local machine. Infrastructure as a service (IaaS) delivers computer infrastructure as a service. Platform as a service (PaaS) provides a platform on which developers can build applications. Software as a service (SaaS) allows applications to be accessed over the network instead of installing them on a local machine. Quality Assurance Quality Assurance = Validation + Verification Code Reviews Systematic examination of code with the intention of finding where the code can be improved Three types covered: PR reviews In pair programming Formal inspections Advantages over testing: It can detect functionality defects as well as other problems such as coding standard violations. It can verify non-code artifacts and incomplete code. It does not require test drivers or stubs. Disadvantages: It is a manual process and therefore, error prone. Static Analysis Analysis of code without actually executing the code Find useful info like: unused variables unhandled exceptions style errors statistics Linters are a subset of static analyzers Formal Verification Uses mathematical techniques to prove the correctness of a program Advantages over testing: Prove the absence of errors (testing can only prove the presence of errors, not their absence) Disadvantages: Only proves the compliance with the specification, but not the actual utility of the software Requires highly specialized notations and knowledge which makes it an expensive technique to administer (more commonly used in safety-critical software such as flight control systems) Test Case Design Postive test case : is designed to produce valid behaviour. Negative test case : is designed to produce an invalid behaviour. Black-box (aka specification-based or responsibility-based): test cases are designed exclusively based on the SUT's specified external behaviour. White-box (aka glass-box or structured or implementation-based): test cases are designed based on what is known about the SUT's implementation. Gray-box : mix of both Equivalence partitions (aka equivalence class): A group of test inputs that are likely to be processed by the SUT in the same way. Avoid testing too many inputs from one partition Ensure all partitions are tested Boundary value analysis (BVA) is a test case design heuristic that is based on the observation that bugs often result from incorrect handling of boundaries of equivalence partitions. Choose 3 values to test: below, in and above boundary Combining test inputs Testing all possible combinations is effective but not efficient Combination strategies: The all combinations strategy generates test cases for each unique combination of test inputs. The at least once strategy includes each test input at least once. The all pairs strategy creates test cases so that for any given pair of inputs, all combinations between them are tested. Heuristic: Each valid input at least once in a positive test case Heuristic: No more than one invalid input in a test case Testing Regression Testing Regression testing is the re-testing of the software to detect regressions. When you modify a system, the modification may result in some unintended and undesirable effects on the system. Such an effect is called a regression. Developer Testing Developer testing is the testing done by the developers themselves as opposed to dedicated testers or end-users. Early testing is better: earlier a bug is found, easier and cheaper to have it fixed. Unit Testing Unit testing is testing individual units (methods, classes, subsystems) to ensure each piece works correctly. Stubs: a stub has the same interface as the component it replaces, but its implementation is so simple that it is unlikely to have any bugs. Can isolate the SUT from its dependencies Typically these mimicked responses are hard-coded Integration Testing Integration testing is testing whether different parts of the software work together as expected. Not simply a case of repeating the unit test cases using the actual dependencies, but are additional test cases that focus on interactions between the parts. Pure unit/ integration testing has one extra step than hybrid Hybrid skips the steps that requires stubs System Testing System testing is testing that takes the whole system and tests it against the system specification. Based on specified external behaviour of the system Includes testing against non-functional requirements: Usability, portability, performance, security, load, compatibility testing Alpha and Beta Testing Alpha testing is performed by the users, under controlled conditions set by the software development team. Beta testing is performed by a selected subset of target users of the system in their natural work setting. Dogfooding Creators use their own product to test it. Exploratory and Scripted Testing Scripted testing: first write a set of test cases based on the expected behavior of the SUT, and then perform testing based on that set of test cases. Exploratory: Devise test cases on-the-fly, creating new test cases based on the results of the past test cases. Known as reactive testing, error guessing technique, attack-based testing and bug hunting User Acceptance Testing User acceptance testing is testing the system to ensure it meets the user requirements. System Testing Acceptance Testing Done against the system specifications Done against the requirements specification Done by testers of the project team Done by a team that represents the customer Done on the development environment or a test bed Done on the deploymet site or on a close simulation of the deployment site Both negative and positive test cases More focus on positive test cases Test Automation Testing An automated test case can be run programmatically and the result of the test case (pass or fail) is determined programmatically. Automated testing of CLI apps : A simple way to semi-automate testing of a CLI (Command Line Interface) app is by using input/output re-direction. Test automation using test drivers : JUnit is a tool for automated testing of Java programs. Automated testing of GUIs : testing tools like TestFX, Visual Studio, Selenium Test coverage : Test coverage is a metric used to measure the extent to which testing exercises the code. Function/ method coverage: based on functions executed e.g., testing executed 90 out of 100 functions. Statement coverage: based on the number of lines of code executed e.g., testing executed 23k out of 25k LOC. Decision/branch coverage: based on the decision points exercised e.g., an if statement evaluated to both true and false with separate test cases during testing is considered 'covered'. Condition coverage: based on the boolean sub-expressions, each evaluated to both true and false with different test cases. Condition coverage is not the same as the decision coverage. Path coverage: measures coverage in terms of possible paths through a given part of the code executed. 100% path coverage means all possible paths have been executed. A commonly used notation for path analysis is called the Control Flow Graph (CFG). Entry/exit coverage: measures coverage in terms of possible calls to and exits from the operations in the SUT. Entry points refer to all places from which the method is called from the rest of the code i.e., all places where the control is handed over to the method in concern. Exit points refer to points at which the control is returned to the caller e.g., return statements, throwing of exceptions. Dependency injection : Dependency injection is the process of 'injecting' objects to replace current dependencies with a different object. Often used to inject stubs to isolate the SUT from its dependencies so that it can be tested in isolation. Polymorphism can be used to implement dependency injection. Test-driven development (TDD) : Advocates writing the tests before writing the SUT, while evolving functionality and tests in small increments.","title":"CS2103/T Notes"},{"location":"cs2103t/cs2103t-notes/#cs2103t-notes","text":"CS2103/T Notes Java Varargs Programming Paradigm Object-Oriented Programming (OOP) Requirements Non-functional Requirements Quality of Requirements Gathering Requirements Specifying Requirements Design Design Fundamentals Modeling Design Patterns Singleton Pattern Abstraction Occurrence Pattern Facade Pattern Command Pattern Model View Controller (MVC) Pattern Observer Pattern Design Approaches Principles S ingle Responsibility Principle O pen-Closed Principle L iskov Substitution Principle I nterface Segregation Principle D ependency Inversion Principle Separation of Concerns Principle Law of Demeter YAGNI Principle DRY Principle Brooks' Law UML Class Diagrams Notation \u2014 Class Diagrams Associations \u2014 Class Diagrams Navigability Multiplicity Dependencies Composition (Has-A) Aggregation Inheritance (Is-A) Objects Diagrams Notation \u2014 Objects Diagrams Sequence Diagrams Notation \u2014 Sequence Diagrams OODM Activity Diagrams Notation \u2014 Activity Diagrams Project Management Revision Control Project Planning Work Breakdown Structure Milestones Buffers Issue Trackers GANTT Charts PERT Charts SDLC Process Models Sequential Models Iterative Models Agile Models XP Scrum Unified Process CMMI Coding Standards Naming Layout Statements Classes and interfaces Methods Types Variables Loops Conditionals Comments Implementation Coding Quality Refactoring Documentation Types Guidelines Error Handling Integration Reuse Quality Assurance Code Reviews Static Analysis Formal Verification Test Case Design Testing Regression Testing Developer Testing Unit Testing Integration Testing System Testing Alpha and Beta Testing Dogfooding Exploratory and Scripted Testing User Acceptance Testing Test Automation Testing","title":"CS2103/T Notes"},{"location":"cs2103t/cs2103t-notes/#java","text":"","title":"Java"},{"location":"cs2103t/cs2103t-notes/#varargs","text":"Syntactic sugar type feature that allows writing a method that can take a variable number of arguments. public static void search(String ... keywords){ // method body }","title":"Varargs"},{"location":"cs2103t/cs2103t-notes/#programming-paradigm","text":"Guides programmers to analyse programmig problems ad structure programmig solutions in a specific way","title":"Programming Paradigm"},{"location":"cs2103t/cs2103t-notes/#object-oriented-programming-oop","text":"Views the world as a network of interacting objects Tries to create a similar object network inside the computer's memory so that a similar result can be achieved programmtically","title":"Object-Oriented Programming (OOP)"},{"location":"cs2103t/cs2103t-notes/#requirements","text":"A software requirement specifies a need to be fulfilled by the software product. A software project may be Brownfield project i.e., develop a product to replace/update an existing software product Greenfield project i.e., develop a totally new system from scratch Requirements come from stakeholders Requirements can be divided into: Functional requirements specify what the system should do Non-functional requirements specify the constraints under which the system is developed and operated","title":"Requirements"},{"location":"cs2103t/cs2103t-notes/#non-functional-requirements","text":"Specify the constraints under which the system is developed and operated NFRs are easier to miss Sometimes NFRs are critical to the success of the software","title":"Non-functional Requirements"},{"location":"cs2103t/cs2103t-notes/#quality-of-requirements","text":"Characteristics of well-defined requirements: Unambiguous Testable (verifiable) Clear (concise, terse, simple, precise) Correct Understandable Feasible (realistic, possible) Independent Atomic Necessary Implementation-free (i.e. abstract) Set of requirements as a whole should be: Consistent Non-redundant Complete","title":"Quality of Requirements"},{"location":"cs2103t/cs2103t-notes/#gathering-requirements","text":"Brainstorming session No \"bad\" ideas (aim is to generate ideas; not to validate them) Product surveys Studying existing products can unearth shortcomings of existing solutions that can be addressed by a new product Observation Observing users in their natural work environment can uncover product requirements User surveys Surveys can be used to solicit responses and opinions from a large number of stakeholders regarding a current product or a new product Interviews Interviewing stakeholders and domain experts can produce useful information about project requirements Focus groups Focus groups are a kind of informal interview within an interactive group setting Prototyping A prototype is a mock up, a scaled down version, or a partial system constructed to get users feedback to validate a technical concept (a \"proof-of-concept\" prototype) to give a preview of what is to come, or to compare multiple alternatives on a small scale before committing fully to one alternative for early field-testing under controlled conditions","title":"Gathering Requirements"},{"location":"cs2103t/cs2103t-notes/#specifying-requirements","text":"Feature list A list of features of a product grouped according to some criteria such as aspect, priority, order of delivery, etc User stories Short, simple descriptions of a feature told from the perspective of the person who desires the new capability, usually a user or customer of the system Format: As a {user type/role} I can {function} so that {benefit} {benefit} can be omitted if it is obvious Can: Add more characteristics to the {user role} , e.g. As a forgetful user, ... Write user stories at various levels (epic/theme) Add conditions of satisfaction to a user story Include: Priority: how important the user story is Size: the estimated effort to implement the user story Urgency: how soon the feature is needed Convenient for scoping, estimation, and scheduling Less details compared to traditional requirements specifications Captures non-functional requirements too because even NFRs must benefit some stakeholder Handy for recording requirements during early stages of requirements gathering Use cases Set of sequences of actions, including variants, that a system performs to yield an observable result of value to an actor Describes an interaction between the user and the system for a specific functionality of the system Only externally visible behavior (omit UI details) Actor : An actor (in a use case) is a role played by a user. can be a human or another system. not part of the system; they reside outside the system. Main Success Scenario (MSS) describes the most straightforward interaction for a given use case, which assumes that nothing goes wrong Extensions are \"add-on\"s to the MSS that describe exceptional/alternative flow of events Glossary Serves to ensure that all stakeholders have a common understanding of the noteworthy terms, abbreviations, acronyms etc Supplementary requirements This section can be used to capture requirements that do not fit elsewhere Typically, this is where most Non-Functional Requirements will be listed","title":"Specifying Requirements"},{"location":"cs2103t/cs2103t-notes/#design","text":"","title":"Design"},{"location":"cs2103t/cs2103t-notes/#design-fundamentals","text":"Abstraction Data abstraction: abstracting away the lower level data items and thinking in terms of bigger entities Control abstraction: abstracting away details of the actual control flow to focus on tasks at a higher level Coupling Coupling is a measure of the degree of dependence between components, classes, methods, etc. Low coupling indicates that a component is less dependent on other components High coupling is discouraged: maintenance, integration, testing and reuse of module is harder. Zero coupling is not possible for non-trivial software. Types: content, common/ global, data, external, subclass, temporal","title":"Design Fundamentals"},{"location":"cs2103t/cs2103t-notes/#modeling","text":"A model provides a simpler view of a complex entity because a model captures only a selected aspect. This omission of some aspects implies models are abstractions. Multiple models of the same entity may be needed to capture it fully. Models can be used as a blueprint for creating software.","title":"Modeling"},{"location":"cs2103t/cs2103t-notes/#design-patterns","text":"An elegant reusable solution to a commonly recurring problem within a given context in software design Common format to describe a pattern: Context: The situation or scenario where the design problem is encountered Problem: The main difficulty to be resolved Solution: The core of the solution. It is important to note that the solution presented only includes the most general details, which may need further refinement for a specific context Anti-patterns (optional): Commonly used solutions, which are usually incorrect and/or inferior to the Design Pattern. Consequences (optional): Identifying the pros and cons of applying the pattern Other useful information (optional): Code examples, known uses, other related patterns, etc 23 Design Patterns divided into 3 categories: Creational: About object creation. They separate the operation of an application from how its objects are created. Abstract Factory, Builder, Factory Method, Prototype, Singleton Structural: About the composition of objects into larger structures while catering for future extension in structure. Adapter, Bridge, Composite, Decorator, Facade , Flyweight, Proxy Behavioral: Defining how objects interact and how responsibility is distributed among them. Chain of Responsibility, Command , Interpreter, Template Method, Iterator, Mediator, Memento, Observer , State, Strategy, Visitor","title":"Design Patterns"},{"location":"cs2103t/cs2103t-notes/#singleton-pattern","text":"When to use: Requires only one instance of a class There is a risk of creating multiple objects by mistake Creating such multiple objects has real negative consequences How to use: Private constructor with a public class-level method to access the single instance Optional <<Singleton>> UML stereotype to indicate role Pros: Easy to apply Effective in achieving its goal with minimal extra work Provides an easy way to access the singleton object from anywhere in the code base Cons: Acts like a global variable that increases coupling across the code base In testing, its difficult to replace Singleton objects with stubs (static methods cannot be overridden). In testing, singleton objects carry data from one test to another","title":"Singleton Pattern"},{"location":"cs2103t/cs2103t-notes/#abstraction-occurrence-pattern","text":"When to use: Group of similar entities with common information Also differing in significant ways How to use: Split entity into 2 classes 1 object for common information ( Abstraction ) and many for unique information ( Occurrence )","title":"Abstraction Occurrence Pattern"},{"location":"cs2103t/cs2103t-notes/#facade-pattern","text":"When to use: Components need to access functionality deep inside other components. How to use: Create a Facade class that sits between users of component and component internals All access to the component happens through the Facade class","title":"Facade Pattern"},{"location":"cs2103t/cs2103t-notes/#command-pattern","text":"When to use: Have a system is required to execute a number of commands Each doing a different task How to use: Create a general Command object such that it can be used without knowing the exact type of command (using polymorphism) Example: Command interface in AB3 where all Commands implement this interface and have an execute method","title":"Command Pattern"},{"location":"cs2103t/cs2103t-notes/#model-view-controller-mvc-pattern","text":"When to use: Support storage/retrieval of information Displaying of information to the user (often via multiple UIs having different formats) Changing stored information based on external inputs How to use: Split the data, presentation and control logic into 3 parts: View: Displays data, interacts with the user, and pulls data from the model if necessary. Controller: Detects UI events such as mouse clicks and button pushes, and takes follow up action. Updates/changes the model/view when necessary. Model: Stores and maintains data. Updates the view if necessary. In a simple UI where there is only one view, Controller and View can be combined as one class.","title":"Model View Controller (MVC) Pattern"},{"location":"cs2103t/cs2103t-notes/#observer-pattern","text":"When to use: An object (possibly more than one) needs to be notified when a change happens to another object How to use: Force the communication through an interface known to both parties Have all observers implement an Observer interface Add all observers to the observee's observer list When there is an update, notify all added observers","title":"Observer Pattern"},{"location":"cs2103t/cs2103t-notes/#design-approaches","text":"Top-down: Design the high-level design first and flesh out the lower levels later Useful when designing big and novel systems where the high-level design needs to be stable before lower levels can be designed Bottom-up: Design lower level components first and put them together to create the higher-level systems later. Not usually scalable for bigger systems. One instance where this approach might work is when designing a variation of an existing system or re-purposing existing components to build a new system Mix: Design the top levels using the top-down approach but switch to a bottom-up approach when designing the bottom levels Agile: Emergent and not defined up front Overall system design will emerge over time, evolving to fulfill new requirements and take advantage of new technologies as appropriate Just enough initial architectural modeling at the very beginning of a project to get your team going Does not produce a fully documented set of models in place before you may begin coding","title":"Design Approaches"},{"location":"cs2103t/cs2103t-notes/#principles","text":"","title":"Principles"},{"location":"cs2103t/cs2103t-notes/#single-responsibility-principle","text":"Definition: A class should have one, and only one, reason to change If a class has only one responsibility, it needs to change only when there is a change to that responsibility Good way of identifying classes during the design phase","title":"Single Responsibility Principle"},{"location":"cs2103t/cs2103t-notes/#open-closed-principle","text":"Definition: A module should be open for extension but closed for modification. That is, modules should be written so that they can be extended, without requiring them to be modified Aims to make a code entity easy to adapt and reuse without needing to modify the code entity itself Separating the specification (i.e. interface) of a module from its implementation","title":"Open-Closed Principle"},{"location":"cs2103t/cs2103t-notes/#liskov-substitution-principle","text":"Definition: Derived classes must be substitutable for their base classes Subclass should not be more restrictive than the behavior specified by the superclass LSP is not followed when substituting a subclass object for a superclass object breaks the functionality of the code","title":"Liskov Substitution Principle"},{"location":"cs2103t/cs2103t-notes/#interface-segregation-principle","text":"Definition: No client should be forced to depend on methods it does not use Can depend on an interface with just the methods it need, instead of the entire class","title":"Interface Segregation Principle"},{"location":"cs2103t/cs2103t-notes/#dependency-inversion-principle","text":"Definition: High-level modules should not depend on low-level modules. Both should depend on abstractions Abstractions should not depend on details. Details should depend on abstractions","title":"Dependency Inversion Principle"},{"location":"cs2103t/cs2103t-notes/#separation-of-concerns-principle","text":"Definition: To achieve better modularity, separate the code into distinct sections, such that each section addresses a separate concern A concern is a set of information that affects the code of a computer program Reduces functional overlaps Limits ripple effect when changes are introduced to a specific part of system Can be applied at the class level as well as higher levels Lead to higher cohesion and lower coupling","title":"Separation of Concerns Principle"},{"location":"cs2103t/cs2103t-notes/#law-of-demeter","text":"Definition: An object should have limited knowledge of another object An object should only interact with objects that are closely related to it Aims to prevent objects from navigating the internal structures of other objects Method foo of an object obj should invoke only the methods of the following kinds of objects: Object obj itself Objects passed as parameters of foo Objects created/instantiated in foo (directly or indirectly) Objects from the direct association of obj","title":"Law of Demeter"},{"location":"cs2103t/cs2103t-notes/#yagni-principle","text":"Definition: You Aren't Gonna Need It! Do not add code simply because 'you might need it in the future' Some capability you presume your software needs in the future should not be built now Do not have perfect information about the future The extra work might go to waste when some of your predictions fail to materialize","title":"YAGNI Principle"},{"location":"cs2103t/cs2103t-notes/#dry-principle","text":"Definition: Don't Repeat Yourself Every piece of knowledge must have a single, unambiguous, authoritative representation within a system Guards against the duplication of information Examples of violations: Functionality being implemented twice even if the two implementations are different Value of a system-wide timeout being defined in multiple places","title":"DRY Principle"},{"location":"cs2103t/cs2103t-notes/#brooks-law","text":"Definition: Adding people to a late project will make it later The additional communication overhead will outweigh the benefit of adding extra manpower, especially if done near a deadline","title":"Brooks' Law"},{"location":"cs2103t/cs2103t-notes/#uml","text":"","title":"UML"},{"location":"cs2103t/cs2103t-notes/#class-diagrams","text":"Used to model class structures of an OO solution Describe the structure (but not behaviour) of OOP solution","title":"Class Diagrams"},{"location":"cs2103t/cs2103t-notes/#notation-class-diagrams","text":"Visibility: + for public | - for private | # for protected | ~ package private (default) Class-level methods/ attributes are underlined <<interface>> <<enumeration>> {abstract} or abstract OK to omit: Methods","title":"Notation \u2014 Class Diagrams"},{"location":"cs2103t/cs2103t-notes/#associations-class-diagrams","text":"Association roles appears on end that plays that role An association can be shown as a line between the two classes or as an attribute in one of the classes (but not both).","title":"Associations \u2014 Class Diagrams"},{"location":"cs2103t/cs2103t-notes/#navigability","text":"Solid arrow The concept of which object in the association knows about the other object. E.g. Navigability is from Box to Rope , b will have reference to r but not vice versa. One can navigate from b to r using b 's object reference of r .","title":"Navigability"},{"location":"cs2103t/cs2103t-notes/#multiplicity","text":"0..X Number of X is on end nearer X. The aspect of an OOP solution that dictates how many objects take part in each association.","title":"Multiplicity"},{"location":"cs2103t/cs2103t-notes/#dependencies","text":"Dotted line A need for one class to depend on another without having a direct association in the same direction.","title":"Dependencies"},{"location":"cs2103t/cs2103t-notes/#composition-has-a","text":"Shaded diamond Diamond is on the end of the whole. A composition is an association that represents a strong whole-part relationship. When the whole is destroyed, parts are destroyed too (parts cannot exist without whole). Cannot be cyclical links.","title":"Composition (Has-A)"},{"location":"cs2103t/cs2103t-notes/#aggregation","text":"Non-shaded/hollow diamond Diamond is on the end of the container. An aggregation is an association that represents a container-contained relationship. Similar to that of composition except the containee object can exist even after the container object is deleted. Weaker relationship than composition. Aggregation represents a container-contained relationship. It is a weaker relationship than composition.","title":"Aggregation"},{"location":"cs2103t/cs2103t-notes/#inheritance-is-a","text":"Triangle arrow (inheriting class - class or interface - interface) Triangle arrow with dotted line: implementing an interface Does not matter whether the triangle is filled or empty Points to parent class Inheritance implies the derived class can be considered as a sub-type of the base class (and the base class is a super-type of the derived class), resulting in an is a relationship.","title":"Inheritance (Is-A)"},{"location":"cs2103t/cs2103t-notes/#objects-diagrams","text":"Used to model object structure of an OO solution Multiple object diagrams can correspond to a single class diagram","title":"Objects Diagrams"},{"location":"cs2103t/cs2103t-notes/#notation-objects-diagrams","text":"Object names are underlined If there is inheritance, show either parent class or child class (not both) MUST omit: Methods Multiplicities OK to omit: Object name Variable name/ value Attributes compartment (if not relevant) Association labels/ roles (if not relevant)","title":"Notation \u2014 Objects Diagrams"},{"location":"cs2103t/cs2103t-notes/#sequence-diagrams","text":"","title":"Sequence Diagrams"},{"location":"cs2103t/cs2103t-notes/#notation-sequence-diagrams","text":"Arrows representing method calls: solid lined arrows Arrows representing method returns: dashed lined arrows Class/object name is not underlined Use an X at the end of the lifeline of an object to show its deletion Self-invocation calls is denoated by an arrow from the bar to itself Method calls to static methods are received by the class itself You can use <<class>> to show that a participant is the class itself All frames should use a rectangle with a clip on the bottom-right corner loop frame: indicate a loop (can execute 0 times) loop [condition] alt frame: indicate alternative paths alt [condition] No more than one alternative partitions be executed in an alt frame opt frame: indicate optional paths opt [condition] ref frame: allow a segment of the interaction to be omitted and shown as a separate sequence diagram ref diagram title (in the original diagram) sd diagram title (sub-sequence diagram shown in this frame) par frame: indicate parallel paths (can happen in any order) The corresponding Java implementation is likely to be multi-threaded- Keywords are loop (while), opt (if) and alt (if elseif) OK to omit: Activation bar Return arrows Activation bar of self-invocation","title":"Notation \u2014 Sequence Diagrams"},{"location":"cs2103t/cs2103t-notes/#oodm","text":"Similar to class diagram notation but must omit: methods navigability Do not contain solution-specific classes (classes that do not exist in the problem domain e.g. DatabaseConnection)","title":"OODM"},{"location":"cs2103t/cs2103t-notes/#activity-diagrams","text":"Models workflows","title":"Activity Diagrams"},{"location":"cs2103t/cs2103t-notes/#notation-activity-diagrams","text":"Action : rounded corners rectangle Denotes a single step in an activity. Control flow : arrow-head line Denotes the flow of control from one action to the next. Start node : shaded circle Denotes the start of the activity End node : inner shaded circle with with a surrounding circle Denotes the end of the activity Branch node : diamond square with two [conditions] Denotes the start of alternate path. Exactly one of the guard conditions should be true. Merge node : diamond square Denotes the end of alternative paths Fork node : bar Denotes the start of concurrent flows of cotntrol. Join node : bar Denotes the end of parallel paths Rake : rake symbol Denotes that the action is described in another subsidiary activity diagram Swim lanes : partition Denotes who is doing which action (also called swimlane diagrams) OK to do: Multiple arrows can start from the same corner of a branch node Omit merge node if it there's no ambiguity Omit [Else] condition.","title":"Notation \u2014 Activity Diagrams"},{"location":"cs2103t/cs2103t-notes/#project-management","text":"","title":"Project Management"},{"location":"cs2103t/cs2103t-notes/#revision-control","text":"Process of managing multiple versions of a piece of information Will track the history and evolution of your project Makes it easier for to collaborate Repository is the database that stores the revision history. Using History Tag a specific commit to identify To see what changed: diff To restore the state of the working directory at point in the past: checkout the commit Remote Repositories git clone a repo to create a (local) copy Original repo is referred to as upstream repo git pull from one repo to another git push new commits in one repo to another Fork is a remote copy of a remote repo Pull request is a mechanism for contributing code to a remote repo Branching is the process of evolving multiple versions of the software in parallel. Merge conflicts happen when you try to merge two branches that had changed the same part of the code and the revision control software (RCS) cannot decide which changes to keep. Centralized RCS uses a central remote repo that is shared by the team. Distributed RCS allows multiple remote repos and pulling and pushing can be done among them in arbitrary ways. Forking flow : the 'official' version of the software is kept in a remote repo designated as the 'main repo'. All team members fork the main repo and create pull requests from their fork to the main repo. Feature branch workflow is similar to forking workflow except there are no forks. Centralized flow is similar to the feature branch workflow except all changes are done in the master branch.","title":"Revision Control"},{"location":"cs2103t/cs2103t-notes/#project-planning","text":"","title":"Project Planning"},{"location":"cs2103t/cs2103t-notes/#work-breakdown-structure","text":"Depicts information about tasks and their details in terms of subtasks Can also include prerequisite tasks and effort estimates for each task Effort is traditionally measured in man hour/day/month All tasks should be well-defined Task ID Task Estimated Effort Prerequisite Task A Analysis 1 man hour - B Design 2 man day A","title":"Work Breakdown Structure"},{"location":"cs2103t/cs2103t-notes/#milestones","text":"End of a stage which indicates significant progress Should account for dependencies and priorities when deciding on the features to be delivered at a certain milestone Each intermediate product release is a milestone","title":"Milestones"},{"location":"cs2103t/cs2103t-notes/#buffers","text":"Time set aside to absorb unforeseen delays Very important to include because effort/time estimations are notoriously hard Do not inflate task estimates to create hidden buffers (have explicit buffers instead) Reason: With explicit buffers, it is easier to detect incorrect effort estimates which can serve as feedback to improve future estimates","title":"Buffers"},{"location":"cs2103t/cs2103t-notes/#issue-trackers","text":"Issue trackers (sometimes called bug trackers) are commonly used to track task assignment and progress","title":"Issue Trackers"},{"location":"cs2103t/cs2103t-notes/#gantt-charts","text":"2-D bar-chart Drawn as time vs tasks Solid bar represents the main task (composed of a number of subtasks) Grey bars represent subtasks Diamond shape indicates an important deadline/deliverable/milestone","title":"GANTT Charts"},{"location":"cs2103t/cs2103t-notes/#pert-charts","text":"Program Evaluation Review Technique Shows the order/sequence of tasks Directed graph: Nodes or vertices capture the effort estimations of tasks Arrows depict the precedence between tasks Helps determine the following: Order of tasks Which tasks can be done concurrently Shortest possible completion time Critical path (path where any delay can directly affect the project duration, hence it is important to ensure tasks on the critical path are completed on time)","title":"PERT Charts"},{"location":"cs2103t/cs2103t-notes/#sdlc-process-models","text":"Software development goes through different stages such as requirements, analysis, design, implementation and testing Collectively known as the software development life cycle (SDLC)","title":"SDLC Process Models"},{"location":"cs2103t/cs2103t-notes/#sequential-models","text":"Views software development as a linear process Also called waterfall model When one stage of the process is completed, it produces some artifacts to be used in the next stage A strict sequential model project moves only in the forward direction Pros: Work well for a project that produces software to solve a well-understood problem Cons: Real-world projects often tackle problems that are not well-understood at the beginning","title":"Sequential Models"},{"location":"cs2103t/cs2103t-notes/#iterative-models","text":"Advocates producing the software by going through several iterations Each iteration produces a new version of the product that builds on the version produced in previous iteration Breadth-first An iteration evolves all major components and all functionality areas in parallel Depth-first An iteration focuses on fleshing out only some components or some functionality area. Early depth-first iterations might not produce a working product. A project can be done as a mixture of breadth-first and depth-first iterations","title":"Iterative Models"},{"location":"cs2103t/cs2103t-notes/#agile-models","text":"","title":"Agile Models"},{"location":"cs2103t/cs2103t-notes/#xp","text":"Extreme programming Stresses customer satisfaction Aims to make developers confidently respond to changing requirements (even late in life cycle) Emphasizes teamwork Improve in: communication, simplicity, feedback, respect and courage Has a set of simple rules","title":"XP"},{"location":"cs2103t/cs2103t-notes/#scrum","text":"Scrum is a process skeleton that contains sets of practices and predefined roles. The main roles in Scrum are: The Scrum Master , who maintains the processes (typically in lieu of a project manager). The Product Owner , who represents the stakeholders and the business. The Team, a cross-functional group who do the actual analysis, design, implementation, testing, etc. A Scrum project is divided into iterations called Sprints . A key principle of Scrum is its recognition that during a project the customers can change their minds about what they want and need. The daily scrum meeting is not used as a problem-solving or issue resolution meeting. Issues that are raised are taken offline and usually dealt with by the relevant subgroup immediately after the meeting. Members answer these questions What did you do yesterday? What will you do today? Are there any impediments in your way?","title":"Scrum"},{"location":"cs2103t/cs2103t-notes/#unified-process","text":"Flexible and customizable process model framework Consists of four phases: inception, elaboration, construction and transition Phase Activities Typical Artifacts Inception Understand the problem and requirements Communicate with customer Plan the development effort Basic use case model Rough project plan Project vision and scope Elaboration Refine and expand requirements Determine a high-level design System architecture Various design models Prototype Construction Major implementation effort to support the use cases identified Design models are refined and fleshed out Testing of all levels are carried out Multiple releases of the system Test cases of all levels System release Transition Ready the system for actual production use Familiarize end users with the system Final system release Instruction manual","title":"Unified Process"},{"location":"cs2103t/cs2103t-notes/#cmmi","text":"Capability Maturity Model Integration Defines 5 maturity levels for a process (specifies criteria): Level 1: Initial Processes unpredictable, poorly controlled and reactive Level 2: Managed Processes characterised for projects and is often reactive Level 3: Defined Processes characterised for organisations and is proactive Level 4: Quantitatively Managed Processes measured and controlled Level 5: Optimizing Focus on process improvement","title":"CMMI"},{"location":"cs2103t/cs2103t-notes/#coding-standards","text":"","title":"Coding Standards"},{"location":"cs2103t/cs2103t-notes/#naming","text":"Names representing packages should be in all lower case. Class/ enum names must be nouns and written in PascalCase. Variable names must be in camelCase. Constant names must be in SCREAMING_SNAKE_CASE. Names representing methods must be verbs and written in camelCase. Abbreviation and acronyms should not be uppsercase when used as part of a name. All names should be written in English. Variables with a large scope should have long names, variables with a small scope can have short names. Boolean variables/ methods should be named to sound like booleans. Plural form should be used on names representing a collection of objects. Iterator variables can be called i, j, k. Associated constants should have a common prefix.","title":"Naming"},{"location":"cs2103t/cs2103t-notes/#layout","text":"Basic indentation should be 4 spaces. Line length should be no longer than 120 characters. Place line break to improve readability. Use egyptian style brackets. Method definitions should have the following form: public void someMethod() throws SomeException { ... } if-else class of statements should have the following form: if (condition) { statements; } for statement should have the following form: for (initialization; condition; update) { statements; } while statement should have the following form: while (condition) { statements; } switch statement should have the following form: switch (condition) { case ABC: statements; //Fallthrough case DEF: statements; break; } try-catch statement should have the following form: try { statements; } catch (Exception exception) { statements; } White space within a statement Operators should be surrounded by a space character Java reserved words should be followed by a white space Commas should be followed by a white space Colons should be surrounded by white space when used as binary/ ternary operator Logical units within a block should be separated by one blank line","title":"Layout"},{"location":"cs2103t/cs2103t-notes/#statements","text":"Put every class in a package Put related classes in a single package The ordering of import statements must be consistent Imported classes should always be listed explicity (not *)","title":"Statements"},{"location":"cs2103t/cs2103t-notes/#classes-and-interfaces","text":"Class/Interface documentation (Comments) class or interface statement Class (static) variables in the order public, protected, package (no access modifier), private Instance variables in the order public, protected, package (no access modifier), private Constructors Methods (no specific order)","title":"Classes and interfaces"},{"location":"cs2103t/cs2103t-notes/#methods","text":"Method modifiers should be given in the following order: <access> static abstract synchronized <unusual> final native","title":"Methods"},{"location":"cs2103t/cs2103t-notes/#types","text":"Array specifiers must be attached to the type not the variable int[] a = new int[20];","title":"Types"},{"location":"cs2103t/cs2103t-notes/#variables","text":"Variables should be initialized where they are declared and they should be declared in the smallest scope possible. Class variables should never be declared public. Avoid unnecessary use of this with fields.","title":"Variables"},{"location":"cs2103t/cs2103t-notes/#loops","text":"Loop body should be wrapped by curly brackets irrespective of how many lines there are in the body.","title":"Loops"},{"location":"cs2103t/cs2103t-notes/#conditionals","text":"Conditional should be put on a separate line. Single statement conditionals should still be wrapped by curly brackets.","title":"Conditionals"},{"location":"cs2103t/cs2103t-notes/#comments","text":"All comments should be written in English. Write descriptive header comments for all public classes/ methods. All non-trivial private methods should carry header comments. Javadoc comments should have the following form: /** * Returns lateral location of the specified position. * If the position is unset, NaN is returned. * * @param x X coordinate of position. * @param y Y coordinate of position. * @param zone Zone of position. * @return Lateral location. * @throws IllegalArgumentException If zone is <= 0. */ public double computeLocation(double x, double y, int zone) throws IllegalArgumentException { //... } Comments should be indented relative to their position in the code. while (true) { // Do something something(); }","title":"Comments"},{"location":"cs2103t/cs2103t-notes/#implementation","text":"","title":"Implementation"},{"location":"cs2103t/cs2103t-notes/#coding-quality","text":"Avoid long methods Avoid deep nesting Avoid complicated expressions Avoid magic numbers Make the code obvious Structure code logically Do not 'trip up' reader Avoid unused paramters in method signature Similar things that look different Different things that look similar Multiple statements in the same line Practice KISSing Keep it simple, stupid Do not try to write 'clever' code Avoid premature optimizations SLAP hard Single Level of Abstraction Principle Avoid having multiple levels of abstraction within a code fragment Make the happy path prominent Naming: Use nouns for things and verbs for actions Use standard words Use name to explain Not too long, not too short Avoid misleading names","title":"Coding Quality"},{"location":"cs2103t/cs2103t-notes/#refactoring","text":"The process of improving a program's internal structure in small steps without modifying its external behavior is called refactoring Refactoring is not rewriting and not bug fixing (alters external behaviour). Benefits: hidden bugs become easier to spot improve performance Refactoring can result in regression Consolidate Duplicate Conditional Fragments // BEFORE if (isSpecialDeal()) { total = price * 0.95; send(); } else { total = price * 0.98; send(); } // AFTER if (isSpecialDeal()) { total = price * 0.95; } else { total = price * 0.98; } send(); Extract Method (opposite of this is inline method) from: //BEFORE void printOwing() { printBanner(); // print details System.out.println(\"name: \" + name); System.out.println(\"amount \" + getOutstanding()); } //AFTER void printOwing() { printBanner(); printDetails(getOutstanding()); } void printDetails(double outstanding) { System.out.println(\"name: \" + name); System.out.println(\"amount \" + outstanding); }","title":"Refactoring"},{"location":"cs2103t/cs2103t-notes/#documentation","text":"Developer-as-user: API documentaion or tutorial-style instructional documentation Developer-as-maintainer: how a system or component is designed implemented and tested","title":"Documentation"},{"location":"cs2103t/cs2103t-notes/#types_1","text":"Tutorials (learning-oriented) How-to guides (goal-oriented) Explanation (understanding-oriented) Reference (information-oriented)","title":"Types"},{"location":"cs2103t/cs2103t-notes/#guidelines","text":"Top-down, not bottom-up The reader can travel down a path she is interested in until she reaches the component she is interested to learn in-depth Comprehensibility Use plenty of diagrams, examples, simple and direct explanations Document minimally but sufficiently 'just enough' developer documentation","title":"Guidelines"},{"location":"cs2103t/cs2103t-notes/#error-handling","text":"Exceptions are used to deal with 'unusual' but not entirely unexpected situations that the program might encounter at runtime. After a method throws an exception, the runtime system attempts to find something to handle it in the call stack. Assertions are used to define assumptions about the program state so that the runtime can verify them. Assertions can be disabled without modifying the code. Java disables assertions by default. Assertions are used to define assumptions about the program state so that the runtime can verify them. Recommended that assertions be used liberally in the code. assertEquals is a JUnit method and only used in test classes. Logging is the deliberate recording of certain information during a program execution for future reference. Defensive programming is proactively eliminating any room for things to go wrong. Enforcing compulsory associations Enforcing 1-to-1 association Enforcing referential integrity (prevents case where A says B is X but B says B is Y) Design-by-contract approach is an approach for designing software that requires defining formal, precise and verifiable interface specifications for software components. Code first checks if the preconditions have been met.","title":"Error Handling"},{"location":"cs2103t/cs2103t-notes/#integration","text":"Timing and frequency: Late and One Time : wait till all components are completed and integrate all finished components near the end of the project Not reccommended because integration often causes many component incompatibilities which can lead to delivery delays Early and Frequent : integrate early and evolve each part in parallel, in small steps, re-integrating frequently Extent: Big-bang integration : integrate all components at the same time Not reccommended because it will uncover too many problems at the same time Incremental integration : integrate a few components at a time (integration problems surface in a more manageable way) Direction: Top-down integration : higher-level components are integrated before bringing in the lower-level components +: Higher-level problems can be discovered early -: Requires the use of stubs in place of lower level components Bottom-up integration : the reverse of top-down integration When integrating lower level components, drivers may be needed to test the integrated components, because UI may not be integrated yet Sandwich integration : a mix of top-down and bottom-up approaches, do both and meet in the middle","title":"Integration"},{"location":"cs2103t/cs2103t-notes/#reuse","text":"API : An Application Programming Interface (API) specifies the interface through which other programs can interact with a software component. It is a contract between the component and its clients. Library : A library is a collection of modular code that is general and can be used by other programs. Frameworks : A software framework is a reusable implementation of a software (or part thereof) providing generic functionality that can be selectively customized to produce a specific application. Some frameworks provide a complete implementation of a default behavior which makes them immediately usable. (e.g. Eclipse) Platforms : A platform provides a runtime environment for applications. Cloud computing : Cloud computing is the delivery of computing as a service over the network, rather than a product running on a local machine. Infrastructure as a service (IaaS) delivers computer infrastructure as a service. Platform as a service (PaaS) provides a platform on which developers can build applications. Software as a service (SaaS) allows applications to be accessed over the network instead of installing them on a local machine.","title":"Reuse"},{"location":"cs2103t/cs2103t-notes/#quality-assurance","text":"Quality Assurance = Validation + Verification","title":"Quality Assurance"},{"location":"cs2103t/cs2103t-notes/#code-reviews","text":"Systematic examination of code with the intention of finding where the code can be improved Three types covered: PR reviews In pair programming Formal inspections Advantages over testing: It can detect functionality defects as well as other problems such as coding standard violations. It can verify non-code artifacts and incomplete code. It does not require test drivers or stubs. Disadvantages: It is a manual process and therefore, error prone.","title":"Code Reviews"},{"location":"cs2103t/cs2103t-notes/#static-analysis","text":"Analysis of code without actually executing the code Find useful info like: unused variables unhandled exceptions style errors statistics Linters are a subset of static analyzers","title":"Static Analysis"},{"location":"cs2103t/cs2103t-notes/#formal-verification","text":"Uses mathematical techniques to prove the correctness of a program Advantages over testing: Prove the absence of errors (testing can only prove the presence of errors, not their absence) Disadvantages: Only proves the compliance with the specification, but not the actual utility of the software Requires highly specialized notations and knowledge which makes it an expensive technique to administer (more commonly used in safety-critical software such as flight control systems)","title":"Formal Verification"},{"location":"cs2103t/cs2103t-notes/#test-case-design","text":"Postive test case : is designed to produce valid behaviour. Negative test case : is designed to produce an invalid behaviour. Black-box (aka specification-based or responsibility-based): test cases are designed exclusively based on the SUT's specified external behaviour. White-box (aka glass-box or structured or implementation-based): test cases are designed based on what is known about the SUT's implementation. Gray-box : mix of both Equivalence partitions (aka equivalence class): A group of test inputs that are likely to be processed by the SUT in the same way. Avoid testing too many inputs from one partition Ensure all partitions are tested Boundary value analysis (BVA) is a test case design heuristic that is based on the observation that bugs often result from incorrect handling of boundaries of equivalence partitions. Choose 3 values to test: below, in and above boundary Combining test inputs Testing all possible combinations is effective but not efficient Combination strategies: The all combinations strategy generates test cases for each unique combination of test inputs. The at least once strategy includes each test input at least once. The all pairs strategy creates test cases so that for any given pair of inputs, all combinations between them are tested. Heuristic: Each valid input at least once in a positive test case Heuristic: No more than one invalid input in a test case","title":"Test Case Design"},{"location":"cs2103t/cs2103t-notes/#testing","text":"","title":"Testing"},{"location":"cs2103t/cs2103t-notes/#regression-testing","text":"Regression testing is the re-testing of the software to detect regressions. When you modify a system, the modification may result in some unintended and undesirable effects on the system. Such an effect is called a regression.","title":"Regression Testing"},{"location":"cs2103t/cs2103t-notes/#developer-testing","text":"Developer testing is the testing done by the developers themselves as opposed to dedicated testers or end-users. Early testing is better: earlier a bug is found, easier and cheaper to have it fixed.","title":"Developer Testing"},{"location":"cs2103t/cs2103t-notes/#unit-testing","text":"Unit testing is testing individual units (methods, classes, subsystems) to ensure each piece works correctly. Stubs: a stub has the same interface as the component it replaces, but its implementation is so simple that it is unlikely to have any bugs. Can isolate the SUT from its dependencies Typically these mimicked responses are hard-coded","title":"Unit Testing"},{"location":"cs2103t/cs2103t-notes/#integration-testing","text":"Integration testing is testing whether different parts of the software work together as expected. Not simply a case of repeating the unit test cases using the actual dependencies, but are additional test cases that focus on interactions between the parts. Pure unit/ integration testing has one extra step than hybrid Hybrid skips the steps that requires stubs","title":"Integration Testing"},{"location":"cs2103t/cs2103t-notes/#system-testing","text":"System testing is testing that takes the whole system and tests it against the system specification. Based on specified external behaviour of the system Includes testing against non-functional requirements: Usability, portability, performance, security, load, compatibility testing","title":"System Testing"},{"location":"cs2103t/cs2103t-notes/#alpha-and-beta-testing","text":"Alpha testing is performed by the users, under controlled conditions set by the software development team. Beta testing is performed by a selected subset of target users of the system in their natural work setting.","title":"Alpha and Beta Testing"},{"location":"cs2103t/cs2103t-notes/#dogfooding","text":"Creators use their own product to test it.","title":"Dogfooding"},{"location":"cs2103t/cs2103t-notes/#exploratory-and-scripted-testing","text":"Scripted testing: first write a set of test cases based on the expected behavior of the SUT, and then perform testing based on that set of test cases. Exploratory: Devise test cases on-the-fly, creating new test cases based on the results of the past test cases. Known as reactive testing, error guessing technique, attack-based testing and bug hunting","title":"Exploratory and Scripted Testing"},{"location":"cs2103t/cs2103t-notes/#user-acceptance-testing","text":"User acceptance testing is testing the system to ensure it meets the user requirements. System Testing Acceptance Testing Done against the system specifications Done against the requirements specification Done by testers of the project team Done by a team that represents the customer Done on the development environment or a test bed Done on the deploymet site or on a close simulation of the deployment site Both negative and positive test cases More focus on positive test cases","title":"User Acceptance Testing"},{"location":"cs2103t/cs2103t-notes/#test-automation-testing","text":"An automated test case can be run programmatically and the result of the test case (pass or fail) is determined programmatically. Automated testing of CLI apps : A simple way to semi-automate testing of a CLI (Command Line Interface) app is by using input/output re-direction. Test automation using test drivers : JUnit is a tool for automated testing of Java programs. Automated testing of GUIs : testing tools like TestFX, Visual Studio, Selenium Test coverage : Test coverage is a metric used to measure the extent to which testing exercises the code. Function/ method coverage: based on functions executed e.g., testing executed 90 out of 100 functions. Statement coverage: based on the number of lines of code executed e.g., testing executed 23k out of 25k LOC. Decision/branch coverage: based on the decision points exercised e.g., an if statement evaluated to both true and false with separate test cases during testing is considered 'covered'. Condition coverage: based on the boolean sub-expressions, each evaluated to both true and false with different test cases. Condition coverage is not the same as the decision coverage. Path coverage: measures coverage in terms of possible paths through a given part of the code executed. 100% path coverage means all possible paths have been executed. A commonly used notation for path analysis is called the Control Flow Graph (CFG). Entry/exit coverage: measures coverage in terms of possible calls to and exits from the operations in the SUT. Entry points refer to all places from which the method is called from the rest of the code i.e., all places where the control is handed over to the method in concern. Exit points refer to points at which the control is returned to the caller e.g., return statements, throwing of exceptions. Dependency injection : Dependency injection is the process of 'injecting' objects to replace current dependencies with a different object. Often used to inject stubs to isolate the SUT from its dependencies so that it can be tested in isolation. Polymorphism can be used to implement dependency injection. Test-driven development (TDD) : Advocates writing the tests before writing the SUT, while evolving functionality and tests in small increments.","title":"Test Automation Testing"},{"location":"cs2106/cs2106-notes/","text":"CS2106 Notes AY23/24 Sem2 CS2106 Notes AY23/24 Sem2 Operating Systems Operating System Structure Running OSes Process Management Process Abstraction Component Description Basic Instruction Execution Memory Context Function Call Dynamically Allocated Memory OS Context Processes Process Abstraction in Unix Zombie Process Unix System Calls Process Scheduling Concurrent Execution Process Scheduling Algorithms First-Come First-Serve: FCFS Shortest Job First: SJF Shortest Remaining Time: SRT Round Robin: RR Priority Scheduling Multi-level Feedback Queue (MLFQ) Lottery Scheduling Scheduling for Interactive Systems Process Alternative - Threads Motivation for Thread Process and Thread Thread Models User Thread Kernel Thread Hybrid Thread Model POSIX Threads: pthread Inter-Process Communication (IPC) Message Passing Unix Pipes Unix Signal Synchronization Assembly Level Implementation High Level Language Implementation High Level Abstraction Classical Synchronization Problems Synchronization Implementations Memory Abstraction Contiguous Memory Management Memory Partitioning Disjoint Memory Schemes Paging Protection Page Sharing Segmentation Scheme Segmentation with Paging Virtual Memory Management Extended Paging Scheme Issues Page Table Structure Inverted Page Table Page Replacement Algorithms Optimal Page Replacement (OPT) FIFO Page Replacement Algorithm Least Recently Used (LRU) Second-Chance Page Replacement (aka CLOCK) Frame Allocation File Management File Protection File Data File Information Processes and Files Directory File System Implementations File Block Allocation Free Space Management Implementing Directory Operating Systems Operating system: A program that acts as an intermediary between a computer user and the computer hardware. Motivation for OS Abstraction: Hide the different low level details Present the common high level functionality to user Resource Allocator: Manages all resources: CPU,Memory,Input/Outputdevices Arbitrate potentially conflicting requests: for efficient and fair resource use Control Program: Controls execution of programs: prevent errors and improper use of the computer and provides security and protection OS can protect a user program from other malicious applications OS manages hardware resources for user programs Operating System Structure A monolithic kernel is an operating system architecture where the entire operating system is working in kernel space A microkernel architecture is an operating system pattern where only basic functionality is provided in the core of the software system Inter-Process Communication (IPC) Address space management Thread management Layered systems Generalization of monolithic system Organize the components into hierarchy of layers Upper layers make use of the lower layers Lowest layer is the hardware Highest layer is the user interface Client-Server Model Variation of microkernel Two classes of processes: Client process request service from server process Server Process built on top of the microkernel Client and Server process can be on separate machine! Running OSes Motivation Operating system assumes total control of the hardware Operating system is hard to debug/ monitor Definition Virtual machine : a software emulation of hardware, also known as hypervisor Process Management Process Abstraction Information describing an executing program Process/ Task/ Job is a dynamic abstracton for execution program Process Scheduling Deciding which process get to execute Inter-Process Communication & Synchronization Passing information between processes Alternative to Process Light-weight process aka Thread Process Abstraction Component Description Memory Storage for instruction and data Cache Duplicate part of the memory for faster access Usually split into instruction cache and data cache Fetch unit Loads instruction from memory Location indicated by a special register: Program Counter (PC) Functional units Carry out the instruction execution Dedicated to different instruction type Registers Internal storage for the fastest access speed General purpose registers: accessible by user program Special register: program counter Basic Instruction Execution Instruction X is fetched Memory location indicated by Program Counter Instruction X dispatched to the corresponding Functional Unit Read operands if applicable, usually from memory or GPR Result computed Write value if applicable n Usually to memory or GPR Instruction X is completed PC updated for the next instruction Memory Context Function Call Stack memory The new memory region to store information during function invocation Information of function invocation is described by a stack frame Stack frame contains: Return address of the caller Arguments for the function Storage for local variables Top of stack region (first unused location) is indicated by a stack pointer Stack frame is added on top when a function is invoked Stack frame is removed from top when a function call ends Function call convention (example scheme) Frame pointer To facilitate the access of various stack frame items Points to a fixed location in a stack frame Saved register Number of general purpose registers on most processors are limited When GPRs are exhausted, use memory to hold the GPR value, then reuse GPR, value held can be restored afterwards (known as register spilling) Dynamically Allocated Memory Acquire new memory space during execution time - malloc() Observations Memory is allocated only at runtime (size is not known during compilation) -> cannot place in data region No definite deallocation timing (can be explicitly freed by programmer) -> cannot place in stack region Solution: set up a separate heap memory region Memory context: text, data, stack and heap Hardware context: general purpose register, program counter, stack pointer, stack frame pointer OS Context Processes Process Identification & Process States New New process created May still be under initialisation Ready Process is waiting to run Running Process being executed on CPU Blocked Process waiting for event Cannot execute until event is available Terminated Process has finished execution, may require OS cleanup Process Table & Process Control Block: Entire execution context for a process Kernel maintains PCB for all processes Hardware context in PCB is updated only when process swap out Memory context in PCB is not the actual memory space used in process (points to real memory & contains page table) PCBs are part of OS memory space OS context of PCB contains information used for scheduling, e.g. priority, time quantum allocated, etc. System calls System calls are dependent on the operating system Application program interface (API) to OS Provides way of calling facilities/ services in kernel Not the same as normal function call (have to change from user mode to kernel mode) User program invokes the library call (normal function call, which are programming language dependent) Library call (usually in assembly code) places the system call number in a designated location E.g. Register Library call executes a special instruction to switch from user mode to kernel mode (commonly known as TRAP) Now in kernel mode, the appropriate system call handler is determined: Using the system call number as index This step is usually handled by a dispatcher System call handler is executed: Carry out the actual request System call handler ended: Control return to the library call Switch from kernel mode to user mode Library call return to the user program: via normal function return mechanism System calls are more expensive than library calls due to context switching Exception and Interrupt Exception is synchronous : occur due to program execution Have to execute an exception handler Similar to a forced function call Interrupt is asynchronous : events that occur independent of program execution Program execution is suspended Have to execute an interrupt handler Process Abstraction in Unix Identification PID: process ID Information Process state: running, sleeping, stopped, zombie Parent PID Cumulative CPU time Command: ps (process status) Creation: fork() # include <unistd.h> int fork(); Returns: PID of newly created process for parent and 0 for child Child process is a duplicate of current executable image Both parent and child processes continue executing after fork() exec() Replace current executing process image with a new one # include <unistd.h> int execl( const char *path, const char *arg0 ... NULL) Path: location of executable e.g. execl( \"/bin/ls\", \"ls\", \"-l\", NULL); = ls -l Termination #include <stdlib.h> void exit( int status ); 0 = Normal Termination (successful execution) No return Most system resources used by processes are released on exit (files) Some resources are not releaseable (PID & status, process accounting info) Parent-Child Synchronisation #include <sys/types.h> #include <sys/wait.h> int wait( int *status ); Returns the PID of the terminated child process status (passed by address) Parent process blocks until at least one child terminates wait() creates zombie processes Zombie Process Parent process terminates before child process: init process becomes \"pseudo\" parent of child processes Child termination sends signal to init, which utilizes wait() to cleanup Child process terminates before parent but parent did not call wait: Child process become a zombie process Can fill up process table May need a reboot to clear the table on older Unix implementations Unix System Calls Process Scheduling Time quantum is always an integer multiple of interval between timer interrupt Given the same period of time, smaller interval between timer interrupt lengthen task turn-around time Shorter ITI -> More Timer Interrupt -> less time spent on actual user process Concurrent Execution Concurrent processes Logical concept to cover multitasked processes Terminology Scheduler: Part of the OS that makes scheduling decision Scheduling algorithm: The algorithm used by scheduler Processing environment Batch processing No user: no interaction required, no need to be responsive Interactive With active user interacting with system Should be responsive, consistent in response time Real time processing Have deadline to meet Usually periodic process Criteria for all processing environments Fairness Should get a fair share of CPU time No starvation Balance All parts of computing system should be utilised Types of scheduling policies Non-preemptive (cooperative) A process stayed scheduled in running state until it blocks or gives up the CPU voluntarily Preemptive A process is given a fixed time quota to run (possible to block or give up early) Process Scheduling Algorithms Criteria for batch processing Turnaround time : Total time taken, i.e. finish-arrival time Waiting time : Time spent waiting for CPU Throughput : Number of tasks finished per unit time i.e. Rate of task completion CPU utilization : Percentage of time when CPU is working on a task First-Come First-Serve: FCFS Tasks are stored on a First-In-First-Out (FIFO) queue based on arrival time Pick the first task in queue to run until the task is done OR the task is blocked Blocked task is removed from the FIFO queue When it is ready again, it is placed at the back of queue i.e. just like a newly arrive task Guaranteed to have no starvation: The number of tasks in front of task X in FIFO is always decreasing -> task X will get its chance eventually Shortcomings Convoy effect : FCFS algorithm is non-preemptive in nature, that is, once CPU time has been allocated to a process, other processes can get CPU time only after the current process has finished Shortest Job First: SJF Select task with the smallest total CPU time Need to know total CPU time for a task in advance Given a fixed set of tasks, average waiting time is minimised Starvation is possible: biased towards short jobs, such that long job may never get a chance Shortest Remaining Time: SRT Select job with shortest remaining (or expected) time New job with shorter remaining time can preempt currently running job Provide good service for short job even when it arrives late Round Robin: RR Tasks are stored in a FIFO queue Pick the first task from queue front to run until: A fixed time slice (quantum) elapsed The task gives up the CPU voluntarily The task is then placed at the end of queue to wait for another turn Blocked task will be moved to other queue to wait for its request Basically a preemptive version of FCFS Response time guarantee: Given n tasks and quantum q Time before a task get CPU is bounded by (n-1)q Timer interrupt needed: For scheduler to check on quantum expiry The choice of time quantum duration is important: Big quantum: Better CPU utilization but longer waiting time Small quantum: Bigger overhead (worse CPU utilization) but shorter waiting time Priority Scheduling Assign a priority value to all tasks, select task with highest priority value Variants Preemptive version: higher priority process can preempt running process with lower priority Non-preemptive version: late coming high priority process has to wait for next round of scheduling Shortcomings Low priority process can starve (worse in preemptive variant) Possible solutions Decrease the priority of currently running process after every time quantum Give the current running process a time quantum Priority Inversion : Priority inversion is a situation that can occur when a low-priority task is holding a resource such as a semaphore for which a higher-priority task is waiting Multi-level Feedback Queue (MLFQ) If Priority(A) > Priority(B) -> A runs If Priority(A) == Priority(B) -> A and B runs in RR Priority Setting/Changing rules: New job -> Highest priority If a job fully utilized its time slice -> priority reduced If a job give up / blocks before it finishes the time slice -> priority retained Favours IO intensive process Exploitations: Change of heart: A process with a lengthy CPU-intensive phase followed by I/O-intensive phase. The process can sink to the lowest priority during the CPU intensive phase. With the low priority, the process may not receive CPU time in a timely fashion, which degrades the responsiveness. Timely boost: All processes in the system will be moved to the highest priority level periodically. By periodically boosting the priority of all processes (essentially treat all process as \u201cnew\u201d and hence have highest priority), a process with different behavior phases may get a chance to be treated correctly even after it has sunk to the lowest priority. Gaming the system: A process repeatedly gives up CPU just before the time quantum lapses. Accounting matters: The CPU usage of a process is now accumulated across time quanta. Once the CPU usage exceeds a single time quantum, the priority of the task will be decremented. Lottery Scheduling Give out \u201clottery tickets\u201d to processes for various system resources When a scheduling decision is needed, a lottery ticket is chosen randomly among eligible tickets Responsive: a newly created process can participate in the next lottery A process can be given Y lottery tickets to distribute to its child process An important process can be given more lottery tickets Each resource can have its own set of tickets Different proportion of usage per resource per task Scheduling for Interactive Systems Criteria for Interactive Environment Response time : Time between request and response by system Predictability : Variation in response time, lesser variation -> more predictable Preemptive scheduling algorithms are used to ensure good response time Scheduler needs to run periodically Interval of timer interrupt (ITI) OS scheduler is triggered every timer interrupt Time Quantum Execution duration given to a process Could be constant or variable among the processes Must be multiples of interval of timer interrupt Large range of values Process Alternative - Threads Motivation for Thread Process is expensive: Process creation under the fork() model: duplicate memory space, duplicate most of the process context etc Context switch: Requires saving/restoration of process information It is hard for independent processes to communicate with each other: Independent memory space -> no easy way to pass information Requires Inter-Process Communication (IPC) Thread is invented to overcome the problems with process model Started out as a \"quick hack\" and eventually matured to be very popular mechanism Basic Idea: A traditional process has a single thread of control: only one instruction of the whole program is executing at any time Add more threads of control to the same process: multiple parts of the programs is executing at the same time conceptually Process and Thread A single proces can have multiple threads: multithreaded process Threads in the same process shares Memory context: text, data, heap OS context: process id, files Unique information needed for each thread Identification (usually thread id) Registers (general purpose and special) Stack Context Switch Process context switch involves: OS Context Hardware Context Memory Context Thread switch within the same process involves: Hardware context: Registers, \"Stack\" (actually just changing FP and SP registers) Threads: Benefits Economy Multiple threads in the same process requires much less resources to manage compared to multiple processes Resource sharing Threads share most of the resources of a process No need for additional mechanism for passing information around Responsiveness Multithreaded programs can appear much more responsive Scability Multithreaded program can take advantage of multiple CPUs Threads: Problems System call concurrency Parallel execution of multiple threads -> parallel system call possible Process behaviour fork() duplicate process, and thread behaviour is OS specific (the other threads may or may not get duplicated) If a single thread calls exit() in a multithreaded program, it typically terminates the entire process, not just the thread that called exit() When a single thread calls exec(), it replaces the entire process image with a new program. This includes all threads. The new program starts with a single thread, and the previous threads of the calling process are terminated Thread Models User Thread Thread is implemented as a user library; kernel is not aware of the threads in the process Advantages: Can have multithreaded program on ANY OS Thread operations are just library calls Generally more configurable and flexible e.g. Customized thread scheduling policy Disadvantages: OS is not aware of threads, scheduling is performed at process level (can never exploit multi-core processors) One thread blocked -> Process blocked -> All threads blocked Cannot exploit multiple CPUs! Kernel Thread Thread is implemented in the OS Thread operation is handled as system calls Thread-level scheduling is possible Kernel schedule by threads, instead of by process Advantages: Kernel can schedule on thread levels: More than 1 thread in the same process can run simultaneously on multiple CPUs Disadvantages: Thread operations is now a system call! Slower and more resource intensive Generally less flexible: Used by all multithreaded programs If implemented with many features, expensive, overkill for simple program If implemented with few features, not flexible enough for some programs Hybrid Thread Model Have both kernel and user threads OS schedule on kernel threads only User thread can bind to a kernel thread If we use a 1-to-1 binding in a hybrid thread model, the end result is the same as a pure kernel-thread model as each user thread is bounded to a kernel thread that can be scheduled Offer great flexibility Can limit the concurrency of any process/ user POSIX Threads: pthread Header file: # include <pthread.h> Compilation: gcc XXX.c -lpthread Datatypes pthread_t : Data type to represent a thread id pthread_attr : Data type to represent attributes of a thread Creation syntax Returns (0 = success; !0 = errors) Parameters: tidCreated: Thread Id for the created thread threadAttributes: Control the behavior of the new thread startRoutine: Function pointer to the function to be executed by thread argForStartRoutine: Arguments for the startRoutine function Pthread can start on any function as long as the function signature is void f(void ) int pthread_create( pthread_t* tidCreated, const pthread_attr_t* threadAttributes, void* (*startRoutine) (void*), void* argForStartRoutine ); Termination syntax Parameters: exitValue: Value to be returned to whoever synchronize with this thread (more later) If pthread_exit()is not used, a pthread will terminate automatically at the end of the startRoutine int pthread_exit( void* exitValue ); Join To wait for the termination of another pthread Returns (0 = success; !0 = errors) Parameters: threadID: TID of the pthread to wait for status: Exit value returned by the target pthread int pthread_join( pthread_t threadID, void **status ); Inter-Process Communication (IPC) General Idea: Process P1 creates a shared memory region M Process P2 attaches M to its own memory space P1 and P2 can now communicate using M Any writes to M can be seen by all other parties (behaves similar to normal memory region) Same model for multiple processes sharing the same memory region Process P1 1. Create M (implict attach) 2. Read/Write to M Process P2 1. Attach M 2. Read/Write to M Master program int main() { int shmid, i, *shm; // Create shared memory region shmid = shmget( IPC_PRIVATE, 40, IPC_CREAT | 0600); if (shmid == -1) { printf(\"Cannot create shared memory!\\n\"); exit(1); } else printf(\"Shared Memory Id = %d\\n\", shmid); // Attach shared memory region shm = (int*) shmat( shmid, NULL, 0 ); if (shm == (int*) -1) { printf(\"Cannot attach shared memory!\\n\"); exit(1); } // First element is used as control value shm[0] = 0; while(shm[0] == 0) { sleep(3); } for (i = 0; i < 3; i++){ printf(\"Read %d from shared memory.\\n\", shm[i+1]); } // Detach and destroy shared memory region shmdt( (char*) shm); shmctl( shmid, IPC_RMID, 0); return 0; } Slave program //similar header files int main() { int shmid, i, input, *shm; printf(\"Shared memory id for attachment: \"); scanf(\"%d\", &shmid); // Attach to shared memory region shm = (int*)shmat( shmid, NULL, 0); if (shm == (int*)-1) { printf(\"Error: Cannot attach!\\n\"); exit(1); } // Write 3 values for (i = 0; i < 3; i++){ scanf(\"%d\", &input); shm[i+1] = input; } // Let master program know we are done! shm[0] = 1; // Detach shared memory region shmdt( (char*)shm ); return 0; } Advantages Efficient: only create and attach involve OS Ease of use: shared memory region behaves the same as normal memory Disadvantages Synchronisation: shared resource means there is a need to synchronise access Message Passing Process P1 prepares a message M and send it to Process P2 Process P2 receives the message M Message sending and receiving are usually provided as system calls Naming scheme Direct communication Sender/ receiver of message explicitly name the other party Indirect communication Messages are sent to/ received from message storage Synchronisation behaviours Blocking primitives (synchronous) Sender/ receiver is blocked until message is received/ arrived Non-blocking primitives (asynchronous) Sender: resume operation immediately Receiver: either receive the message or some indication that message is not ready Advantages Portable: can be easily implemented Easier synchronisation Disadvantages Inefficient (requires OS intervention) Harder to use, messages are limited in size or format Unix Pipes Piping in shell \"|\" symbol to link the input/output channels of one process to another (known as piping) Output of a process goes directly into another as input Pipe functions as circular bounded byte buffer with implicit synchronization: Writers wait when buffer is full Readers wait when buffer is empty Variants Half-duplex: unidirectional, one write end and one read end Full-duplex: bidirectional, read/ write for both ends System calls #include <unistd.h> int pipe( int fd[] ) Returns 0 to indicate success; !0 for errors Unix Signal A form of inter-process communication An asynchronous notification regarding an event Sent to a process/thread Recipient of the signal must handle the signal by A default set of handlers User supplied handler E.g. kill, stop, continue, memory error, arithmetic error A process can install user-define handler for multiple different signals. [True] We can install user-define handler for all signals. [False: The \"kill -9\" i.e. SIGKIL is not captureable] A parent process can force the child processes to execute any part of their code by sending signal to them. [False: Only the signal handler can be triggered.] The \"kill\" signal (sent by the \"kill\" command) is different from the \"interrupt\" signal (sent by pressing \"ctrl-c\"). [True] Synchronization Designate code segment with race condition as critical section At any point in time, only one process can execute in the critical section Properties of correct critical section implementation: Mutual exclusion: Only one process can enter critical section Progress: If no process is in critical section, one of the waiting processes should be granted access Bounded wait: After process pi requests to enter critical section, there exists an upperbound of number of times other processes can enter the critical section before pi Independence: Process not executing in critical section should never block other process Incorrect synchonization: Deadlock: All processes blocked Livelock: Processes keep changing state to avoid deadlock and make no other progress Starvation: Some processes are blocked forever Implementations overview: Assembly level implementations: mechanisms provided by the processor High level language implementations: utilizes only normal programming constructs High level abstraction: provide abstracted mechanisms that provide additional useful features Assembly Level Implementation TestAndSet Register, MemoryLocation Load the current content at MemoryLocation into Register Stores a 1 into MemoryLocation Performed as a single machine operation (i.e. atomic) It employs busy waiting (keep checking the condition until it is safe to enter critical section) High Level Language Implementation Peterson's Algorithm Keep a turn variable, so process can only run when it is their turn Keep a Want array, so process can only run if they want Disadvantages Busy waiting Low level: more error prone High Level Abstraction Semaphore A generalized synchronization mechanism Only behaviours are specified Provides A way to block a number of processes, known as sleeping process A way to unblock/ wake up one or more sleeping process Wait(S) (called before a process enters critical section) If S <= 0, blocks processes (go to sleep) Decrement S Signal(S) (called after a process exits critical section) Increments S Wakes up one sleeping process if any This usage is commonly known as mutex (mutual exclusion) Properties Given S initial >= 0 Invariant: S current = S initial + number of signals() operations executed - number of wait() operations completed Classical Synchronization Problems Producer consumer Processes share a bounded buffer of size K Producers produce items to insert into buffer Consumers remove items from buffer Busy waiting while !canProduce, producer waits while !canConsumer, consumer waits Blocking version wait(notFull): producers go to sleep wait(notEmpty): consumers to go to sleep signal(notFull): 1 consumer wakes 1 producer signal(notEmpty): 1 producer wakes 1 consumer Readers writers Processes share a data structure D Readers retrieve information from D If they are the first reader, wait for roomEmpty If they are the last reader, signal roomEmpty and release mutex Writer modifies information in D (when roomEmpty) Writer might face starvation if rate of arrival of readers > rate of departure of readers (so number of readers never reach 0) Dining philosophers Tanenbaum solution To eat, a philosopher must acquire both the left and right chopsticks If a philosopher cannot acquire both chopsticks, they wait until both are available Synchronization Implementations POSIX semaphore #include <semaphore.h> Initialize a semaphore Perform wait() or signal() on semaphore pthread mutex and conditional variables Synchronization mechanisms for pthreads Mutex (pthread_mutex): Binary semaphore (i.e. equivalent Semaphore(1)) Lock: pthread_mutex_lock() Unlock: pthread_mutex_unlock() Conditional Variables( pthread_cond ): Wait: pthread_cond_wait() Signal: pthread_cond_signal() Broadcast: pthread_cond_broadcast() Memory Abstraction Types of data in a process Transient Data: Valid only for a limited duration, e.g., during function call e.g., parameters, local variables Persistent Data: Valid for the duration of the program unless explicitly removed (if applicable) e.g., global variable, constant variable, dynamically allocated memory If two processes are using the same physical memory, there might be conflicts in memory access because both processes assume memory starts at 0 Use logical adddress Contiguous Memory Management Assumptions Each process occupies a contiguous memory region Physical memory is large enough to contain one or more processes with complete memory space Memory Partitioning Fixed-Size Partitions Physical memory is split into fixed number of partitions of equal size A process will occupy one of the partitions Causes internal fragmentation (space leftover within partition when process takes less than partition size) Variable-Size Partitions Partition is created based on the actual size of process OS keep track of the occupied and free memory regions Causes external fragmentation from removing processes Can use a linked list (takes more time) to move occupied partitions and create larger holes Allocation algorithm First-fit Take the first hole that is large enough Next-fit Search from the last allocated block and wrap around Best-fit Find the smallest hole that is large enough Worst-fit Find the largest hole Buddy system Free block is split into half repeatedly to meet request size The two halves forms a sibling blocks (buddy blocks) When buddy blocks are both free, they can be merged to form larger block Disjoint Memory Schemes Paging Physical memory is split into regions of fixed size (known as physical frames) Logical memory is similarly split into regions of the same size (logical page) Lookup table to provide translation between logical page to physical page (page table) Physical address = frame_number x sizeof(physical_frame) + offset Offset: displacement from the beginning of the physical frame Address translation formula Page/Frame size of 2^n m bits of logical address Frame number represented by (m - n) bits Offset represented by n bits To store the page table, PCB (only software) Requires 2 memory accesses for every memory reference Translation Look-Aside Buffer (TLB) On-chip component to support paging TLB hit: Frame number is retrieved to generate physical address TLB miss: memory access to access the page table When context switch occurs, TLB entries are flushed New process will not get incorrect translation Protection Access-Right Bits Each page table entry has a writable, readable, executable bit Every memory access is checked against the access right bits in hardware Valid Bit Included in each page table entry Indicated whether the page is valid to access by the process Every memory access is checked against this bit in hardware: Out-of-range access will be caught by OS in this manner Page Sharing Several processes to share the same physical memory frame Use the same physical frame number in the page table entries Implementing Copy-On-Write Parent and child process can share a page until one tries to change a value in it Segmentation Scheme Manage memory at the level of memory segments Each memory segment Has a name Has a limit Memory references specified as \"segment name + offset\" Logical address translation Each segment mapped to a contiguous physical memory region with a base address and a limit/size Logical address <SegID, Offset> SegID is used to look up of the segment in a segment table Physical address = base + offset Offset < limit for valid access Each segment is an independent contiguous memory space Segmentation requires variable-size contiguous memory regions (can cause external fragmentation) Segmentation with Paging Each segment is composed of several pages instead of a contiguous memory region Virtual Memory Management Secondary storage capacity >> Physical memory capacity Some pages are accessed much more often than others Basic idea: split the logical address space into small chunks (some are in physical memory, others in secondary storage) Extended Paging Scheme Use page table for virtual -> physical address translation Two page types: Memory resident (pages in physical memory) Non-memory resident (pages in secondary storage) Use a resident bit in the page-table entry CPU can only access memory resident pages If attempt to access non-resident, page fault Hardware Check page table: Is page X a memory resident? Yes: Access physical memory location. Done. No: raise an exception! OS Page Fault: OS takes control Locate page X in secondary storage Load page X into a physical memory Update page table Go to step 1 to re-execute the same instruction This time with the page in memory Issues Secondary storage access time >> physical memory access time If memory access results in page fault most of the time To load non-resident pages into memory Entire system can slow down significantly (known as thrashing) Locality principles Temporal Locality: Memory address used now is likely to be used again Spatial Locality: Memory addresses close to the address that is used now is likely to be used soon Demand paging Process start with no memory resident page Only allocate a page when there is a page fault Fast startup time for new process Might be sluggish at the start due to page faults Page Table Structure Page table information is kept with the process information and takes up physical memory space Direct paging Keep all entries in a single table Virtual Address: 32 bits, Page Size = 4KiB P=32\u201312=20; 2^20 pages Size of PTE = 2 bytes Page Table Size = 2^20 * 2 bytes = 2MiB 2-level paging Process may not use entire virtual memory space If original page tabel has 2^P entries With 2^M smaller page tables, M bits is needed to uniquely identify one page table Each smaller page table contains 2^(P-M) entries Problem: two serialized memory accesses just to get frame number TLB misses experience longer page-table walks Page-table walk: the traversal of page-tables in hardware Inverted Page Table Page table is a per-process information With M processes in memory, there are M independent page tables Observation: Only N physical memory frames can be occupied Out of the M page tables, only N entries are valid! Huge waste: N << Overhead of M page tables Idea: Keep a single mapping of physical frame to <pid, page#> pid = process id , page# = logical page number in the corresponding the process page# is not unique among processes pid + page# can uniquely identify a memory page Entries are ordered by frame number instead of page number Page Replacement Algorithms No free physical memory frame during a page fault Memory access time: T access = (1 - p) _ T mem + P _ T page fault p = probability of page fault T mem = access time for memory resident page T page fault = access time if page fault occurs Optimal Page Replacement (OPT) Replace the page that will not be needed again for the longest period of time Guarantees minimum number of page fault But future knowledge of memory references is needed FIFO Page Replacement Algorithm Memory pages are evicted based on their loading time Evict the oldest memory page OS maintains a queue of resident page numbers But FIFO does not exploit temporal locality Least Recently Used (LRU) Make used of temporal locality Replace the page that has not been used in the longest time But implementation is difficult Using a \"time\" counter: need to search through all pages to find the smallest Using a \"stack\": hard to implement in hardware because it is not a pure stack Second-Chance Page Replacement (aka CLOCK) Modified FIFO to give a second chance to pages that are accessed Each page table entry has a reference bit Degenerate into FIFO algorithm Algorithm: The oldest FIFO page is selected (victim page) If reference bit == 0, page is replaced If reference bit == 1, page is skipped and reference is cleared to 0 Frame Allocation Best way to distribute N physical memory frames to M processes competing for frames Equal allocation Each process gets N/M frames Proportional allocation Each process gets size_of_process / total_size * N frames Victim page selected among pages of the process that causes page fault: local replacement Number of frames allocated to a process remain constant If frames allocated not enough, it may hinder the progress of process Victim page selected among all physical frames: global replacement Allow self-adjustment between processes Badly behaved processes can steal frames from other processes Thrashing Insufficient physical frame In global replacement: A thrashing process \"steals\" page from other process cause other process to thrash (Cascading Thrashing) In local replacement: thrashing can be limited to one process, but that process can use up the I/O bandwidth and degrade performance of others\\ Right number of frames: working set Transient region: working set changing in size Stable region: working set about the same for a long time File Management Common file types: regular files: contains user information Directories: system files for file system structure Special files: character/ block oriented File types: Use file extension as indication Use embedded information in the file (magic number stored at beginning of file) File Protection Controlled access to the information stored in a file Access: read, write, execute, append, delete, list Users classified into three classes: Owner Group Universe Define permission of three access types: r w x r w x r w x Access control list can be Minimal (same as ppermission bits) Extended (added named users/ groups) File Data Structure Array of byes Each byte has a unique offset from file start Fixed length records Array of records that can grow and shrink Variable length records Flexible but harder to locate Access methods Sequential access Data read in order, starting from beginning e.g. cassette tapes Random access Data can be read in any order Read (offset): every read operation explicitly states the position to be accessed Seek (offset): special operation to move to a new location in file Direct access Used for file that contains fixed-length records Allow random access to any record directly OS provides file operations as system calls Provide proection, concurrent and efficient access File Information Information kept for an opened file File pointer: keep track of the current position within a file File descriptor: unique identifier of the file Disk location: actual file location on disk Open count/ reference count: number of proccesses that have the file opened Per-process open-file table: To keep track of the open files for a process Each entry points to the system-wide open-file table entries System-wide open-file table: To keep track of all the open files in the system Each entry points to a V-node entry System-wide V-node (virtual node) table To link with the file on physical drive Contains the information about the physical location of the file Processes and Files Process A tries to open a file that is currently being written by Process B. OS uses the Open File Table to check for existing opened file. Since the file is already opened for reading, it can reject the file open system call from process A. Process A tries to use a bogus file descriptor in a file-related system call. Since Process A passed the file descriptor (fd for short) to OS as parameter, OS can check whether that particular entry is valid (or even exists) in the PCB of A. If the fd is out of range, non-existent etc, OS can reject the file-related system calls made by Process A. Process A can never \"accidentally\" access files opened by Process B. Since the fd index is in process specific PCB, there is no way Process A can access Process B's file descriptor table. Process A and Process B reads from the same file. However, their reading should not affect each other. Process A and Process B can have their own fds, which refers to two distinct locations in the open file table. Each entry of the open file table keep track of the current location separately. This enables Process A and Process B to read from the same file independently. Redirect Process A's standard input / output, e.g. \"a.out < test.in > test.out\". So, for all file redirections, it is a simple question of: Opening and possibly creating the file. Replace the corresponding file descriptor to point to the entry from (1) in the open file table. Directory Used to Provide a logical grouping of files Keep track of files Single-Level All files are in root directory Tree-Structured Directories can be recursively embedded in other directories Direct Acyclic Graph If a file can be shared, only one copy of actual content \"Appears\" in multiple directories with different file names Alias is for files only, not directories Unix hard link ( ln ) Directory A and B have separate pointers to the actual file F in disk Can only be deleted when all links are deleted General Graph Users have the capability to create a cycle of directory within a directory Hard to traverse, and need to prevent infinite looping Unix symbolic link/ soft link ( ln -s ) Symbolic link is a special link file that contains the path name of the file F When link file is accessed, it finds where the F is and accesses F Simple deletion: link is deleted, not file; file is deleted, dangling link File System Implementations Master Boot Record (MBR) at sector 0 with partition table Followed by one or more partitions Each partition can contain an independent file system File Block Allocation Contiguous Allocate consecutive disk blocks to a file External fragmentation Linked list Keep a linked list of disk blocks that each stores next disk block number and actual file data Random access in a file is slow File allocation table (FAT) FAT entry contains either: FREE code (block is unused) Block number of next block EOF code (i.e., NULL pointer) BAD block (block is unusable, i.e., disk error) Faster random access FAT keeps track of all disk blocks in a partition, which will be expensive when disk is large Indexed allocation Maintain blocks for each file; IndexBlock[N] == Nth block address Lesser memory overhead Limited maximum file size (max number of blocks == number of index block entries) I-Node Data Every file/ directory has an I-node associated Allows fast access to small file Flexibility in handling huge files Free Space Management Maintain free space information Bitmap Each disk block represented by 1 bit Linked list Each disk block contains number of free disk block numbers or pointer to next free space Easy to locate free block High overhead Implementing Directory Keep track of files in directory Map the file name to file information Linear list Each directory consists of a linear list where each entry represents a file Locating a file requires linear search Hash table Each directory consists of a hash table of size N Fast lookup Hash table has limited size File information Each directory consists of file information (name and disk block information) Stored in directory entry directly OR Store only name and point to some data structure for other info","title":"CS2106 Notes AY23/24 Sem2"},{"location":"cs2106/cs2106-notes/#cs2106-notes-ay2324-sem2","text":"CS2106 Notes AY23/24 Sem2 Operating Systems Operating System Structure Running OSes Process Management Process Abstraction Component Description Basic Instruction Execution Memory Context Function Call Dynamically Allocated Memory OS Context Processes Process Abstraction in Unix Zombie Process Unix System Calls Process Scheduling Concurrent Execution Process Scheduling Algorithms First-Come First-Serve: FCFS Shortest Job First: SJF Shortest Remaining Time: SRT Round Robin: RR Priority Scheduling Multi-level Feedback Queue (MLFQ) Lottery Scheduling Scheduling for Interactive Systems Process Alternative - Threads Motivation for Thread Process and Thread Thread Models User Thread Kernel Thread Hybrid Thread Model POSIX Threads: pthread Inter-Process Communication (IPC) Message Passing Unix Pipes Unix Signal Synchronization Assembly Level Implementation High Level Language Implementation High Level Abstraction Classical Synchronization Problems Synchronization Implementations Memory Abstraction Contiguous Memory Management Memory Partitioning Disjoint Memory Schemes Paging Protection Page Sharing Segmentation Scheme Segmentation with Paging Virtual Memory Management Extended Paging Scheme Issues Page Table Structure Inverted Page Table Page Replacement Algorithms Optimal Page Replacement (OPT) FIFO Page Replacement Algorithm Least Recently Used (LRU) Second-Chance Page Replacement (aka CLOCK) Frame Allocation File Management File Protection File Data File Information Processes and Files Directory File System Implementations File Block Allocation Free Space Management Implementing Directory","title":"CS2106 Notes AY23/24 Sem2"},{"location":"cs2106/cs2106-notes/#operating-systems","text":"Operating system: A program that acts as an intermediary between a computer user and the computer hardware. Motivation for OS Abstraction: Hide the different low level details Present the common high level functionality to user Resource Allocator: Manages all resources: CPU,Memory,Input/Outputdevices Arbitrate potentially conflicting requests: for efficient and fair resource use Control Program: Controls execution of programs: prevent errors and improper use of the computer and provides security and protection OS can protect a user program from other malicious applications OS manages hardware resources for user programs","title":"Operating Systems"},{"location":"cs2106/cs2106-notes/#operating-system-structure","text":"A monolithic kernel is an operating system architecture where the entire operating system is working in kernel space A microkernel architecture is an operating system pattern where only basic functionality is provided in the core of the software system Inter-Process Communication (IPC) Address space management Thread management Layered systems Generalization of monolithic system Organize the components into hierarchy of layers Upper layers make use of the lower layers Lowest layer is the hardware Highest layer is the user interface Client-Server Model Variation of microkernel Two classes of processes: Client process request service from server process Server Process built on top of the microkernel Client and Server process can be on separate machine!","title":"Operating System Structure"},{"location":"cs2106/cs2106-notes/#running-oses","text":"Motivation Operating system assumes total control of the hardware Operating system is hard to debug/ monitor Definition Virtual machine : a software emulation of hardware, also known as hypervisor","title":"Running OSes"},{"location":"cs2106/cs2106-notes/#process-management","text":"Process Abstraction Information describing an executing program Process/ Task/ Job is a dynamic abstracton for execution program Process Scheduling Deciding which process get to execute Inter-Process Communication & Synchronization Passing information between processes Alternative to Process Light-weight process aka Thread","title":"Process Management"},{"location":"cs2106/cs2106-notes/#process-abstraction","text":"","title":"Process Abstraction"},{"location":"cs2106/cs2106-notes/#component-description","text":"Memory Storage for instruction and data Cache Duplicate part of the memory for faster access Usually split into instruction cache and data cache Fetch unit Loads instruction from memory Location indicated by a special register: Program Counter (PC) Functional units Carry out the instruction execution Dedicated to different instruction type Registers Internal storage for the fastest access speed General purpose registers: accessible by user program Special register: program counter","title":"Component Description"},{"location":"cs2106/cs2106-notes/#basic-instruction-execution","text":"Instruction X is fetched Memory location indicated by Program Counter Instruction X dispatched to the corresponding Functional Unit Read operands if applicable, usually from memory or GPR Result computed Write value if applicable n Usually to memory or GPR Instruction X is completed PC updated for the next instruction","title":"Basic Instruction Execution"},{"location":"cs2106/cs2106-notes/#memory-context","text":"","title":"Memory Context"},{"location":"cs2106/cs2106-notes/#function-call","text":"Stack memory The new memory region to store information during function invocation Information of function invocation is described by a stack frame Stack frame contains: Return address of the caller Arguments for the function Storage for local variables Top of stack region (first unused location) is indicated by a stack pointer Stack frame is added on top when a function is invoked Stack frame is removed from top when a function call ends Function call convention (example scheme) Frame pointer To facilitate the access of various stack frame items Points to a fixed location in a stack frame Saved register Number of general purpose registers on most processors are limited When GPRs are exhausted, use memory to hold the GPR value, then reuse GPR, value held can be restored afterwards (known as register spilling)","title":"Function Call"},{"location":"cs2106/cs2106-notes/#dynamically-allocated-memory","text":"Acquire new memory space during execution time - malloc() Observations Memory is allocated only at runtime (size is not known during compilation) -> cannot place in data region No definite deallocation timing (can be explicitly freed by programmer) -> cannot place in stack region Solution: set up a separate heap memory region Memory context: text, data, stack and heap Hardware context: general purpose register, program counter, stack pointer, stack frame pointer","title":"Dynamically Allocated Memory"},{"location":"cs2106/cs2106-notes/#os-context","text":"","title":"OS Context"},{"location":"cs2106/cs2106-notes/#processes","text":"Process Identification & Process States New New process created May still be under initialisation Ready Process is waiting to run Running Process being executed on CPU Blocked Process waiting for event Cannot execute until event is available Terminated Process has finished execution, may require OS cleanup Process Table & Process Control Block: Entire execution context for a process Kernel maintains PCB for all processes Hardware context in PCB is updated only when process swap out Memory context in PCB is not the actual memory space used in process (points to real memory & contains page table) PCBs are part of OS memory space OS context of PCB contains information used for scheduling, e.g. priority, time quantum allocated, etc. System calls System calls are dependent on the operating system Application program interface (API) to OS Provides way of calling facilities/ services in kernel Not the same as normal function call (have to change from user mode to kernel mode) User program invokes the library call (normal function call, which are programming language dependent) Library call (usually in assembly code) places the system call number in a designated location E.g. Register Library call executes a special instruction to switch from user mode to kernel mode (commonly known as TRAP) Now in kernel mode, the appropriate system call handler is determined: Using the system call number as index This step is usually handled by a dispatcher System call handler is executed: Carry out the actual request System call handler ended: Control return to the library call Switch from kernel mode to user mode Library call return to the user program: via normal function return mechanism System calls are more expensive than library calls due to context switching Exception and Interrupt Exception is synchronous : occur due to program execution Have to execute an exception handler Similar to a forced function call Interrupt is asynchronous : events that occur independent of program execution Program execution is suspended Have to execute an interrupt handler","title":"Processes"},{"location":"cs2106/cs2106-notes/#process-abstraction-in-unix","text":"Identification PID: process ID Information Process state: running, sleeping, stopped, zombie Parent PID Cumulative CPU time Command: ps (process status) Creation: fork() # include <unistd.h> int fork(); Returns: PID of newly created process for parent and 0 for child Child process is a duplicate of current executable image Both parent and child processes continue executing after fork() exec() Replace current executing process image with a new one # include <unistd.h> int execl( const char *path, const char *arg0 ... NULL) Path: location of executable e.g. execl( \"/bin/ls\", \"ls\", \"-l\", NULL); = ls -l Termination #include <stdlib.h> void exit( int status ); 0 = Normal Termination (successful execution) No return Most system resources used by processes are released on exit (files) Some resources are not releaseable (PID & status, process accounting info) Parent-Child Synchronisation #include <sys/types.h> #include <sys/wait.h> int wait( int *status ); Returns the PID of the terminated child process status (passed by address) Parent process blocks until at least one child terminates wait() creates zombie processes","title":"Process Abstraction in Unix"},{"location":"cs2106/cs2106-notes/#zombie-process","text":"Parent process terminates before child process: init process becomes \"pseudo\" parent of child processes Child termination sends signal to init, which utilizes wait() to cleanup Child process terminates before parent but parent did not call wait: Child process become a zombie process Can fill up process table May need a reboot to clear the table on older Unix implementations","title":"Zombie Process"},{"location":"cs2106/cs2106-notes/#unix-system-calls","text":"","title":"Unix System Calls"},{"location":"cs2106/cs2106-notes/#process-scheduling","text":"Time quantum is always an integer multiple of interval between timer interrupt Given the same period of time, smaller interval between timer interrupt lengthen task turn-around time Shorter ITI -> More Timer Interrupt -> less time spent on actual user process","title":"Process Scheduling"},{"location":"cs2106/cs2106-notes/#concurrent-execution","text":"Concurrent processes Logical concept to cover multitasked processes Terminology Scheduler: Part of the OS that makes scheduling decision Scheduling algorithm: The algorithm used by scheduler Processing environment Batch processing No user: no interaction required, no need to be responsive Interactive With active user interacting with system Should be responsive, consistent in response time Real time processing Have deadline to meet Usually periodic process Criteria for all processing environments Fairness Should get a fair share of CPU time No starvation Balance All parts of computing system should be utilised Types of scheduling policies Non-preemptive (cooperative) A process stayed scheduled in running state until it blocks or gives up the CPU voluntarily Preemptive A process is given a fixed time quota to run (possible to block or give up early)","title":"Concurrent Execution"},{"location":"cs2106/cs2106-notes/#process-scheduling-algorithms","text":"Criteria for batch processing Turnaround time : Total time taken, i.e. finish-arrival time Waiting time : Time spent waiting for CPU Throughput : Number of tasks finished per unit time i.e. Rate of task completion CPU utilization : Percentage of time when CPU is working on a task","title":"Process Scheduling Algorithms"},{"location":"cs2106/cs2106-notes/#first-come-first-serve-fcfs","text":"Tasks are stored on a First-In-First-Out (FIFO) queue based on arrival time Pick the first task in queue to run until the task is done OR the task is blocked Blocked task is removed from the FIFO queue When it is ready again, it is placed at the back of queue i.e. just like a newly arrive task Guaranteed to have no starvation: The number of tasks in front of task X in FIFO is always decreasing -> task X will get its chance eventually Shortcomings Convoy effect : FCFS algorithm is non-preemptive in nature, that is, once CPU time has been allocated to a process, other processes can get CPU time only after the current process has finished","title":"First-Come First-Serve: FCFS"},{"location":"cs2106/cs2106-notes/#shortest-job-first-sjf","text":"Select task with the smallest total CPU time Need to know total CPU time for a task in advance Given a fixed set of tasks, average waiting time is minimised Starvation is possible: biased towards short jobs, such that long job may never get a chance","title":"Shortest Job First: SJF"},{"location":"cs2106/cs2106-notes/#shortest-remaining-time-srt","text":"Select job with shortest remaining (or expected) time New job with shorter remaining time can preempt currently running job Provide good service for short job even when it arrives late","title":"Shortest Remaining Time: SRT"},{"location":"cs2106/cs2106-notes/#round-robin-rr","text":"Tasks are stored in a FIFO queue Pick the first task from queue front to run until: A fixed time slice (quantum) elapsed The task gives up the CPU voluntarily The task is then placed at the end of queue to wait for another turn Blocked task will be moved to other queue to wait for its request Basically a preemptive version of FCFS Response time guarantee: Given n tasks and quantum q Time before a task get CPU is bounded by (n-1)q Timer interrupt needed: For scheduler to check on quantum expiry The choice of time quantum duration is important: Big quantum: Better CPU utilization but longer waiting time Small quantum: Bigger overhead (worse CPU utilization) but shorter waiting time","title":"Round Robin: RR"},{"location":"cs2106/cs2106-notes/#priority-scheduling","text":"Assign a priority value to all tasks, select task with highest priority value Variants Preemptive version: higher priority process can preempt running process with lower priority Non-preemptive version: late coming high priority process has to wait for next round of scheduling Shortcomings Low priority process can starve (worse in preemptive variant) Possible solutions Decrease the priority of currently running process after every time quantum Give the current running process a time quantum Priority Inversion : Priority inversion is a situation that can occur when a low-priority task is holding a resource such as a semaphore for which a higher-priority task is waiting","title":"Priority Scheduling"},{"location":"cs2106/cs2106-notes/#multi-level-feedback-queue-mlfq","text":"If Priority(A) > Priority(B) -> A runs If Priority(A) == Priority(B) -> A and B runs in RR Priority Setting/Changing rules: New job -> Highest priority If a job fully utilized its time slice -> priority reduced If a job give up / blocks before it finishes the time slice -> priority retained Favours IO intensive process Exploitations: Change of heart: A process with a lengthy CPU-intensive phase followed by I/O-intensive phase. The process can sink to the lowest priority during the CPU intensive phase. With the low priority, the process may not receive CPU time in a timely fashion, which degrades the responsiveness. Timely boost: All processes in the system will be moved to the highest priority level periodically. By periodically boosting the priority of all processes (essentially treat all process as \u201cnew\u201d and hence have highest priority), a process with different behavior phases may get a chance to be treated correctly even after it has sunk to the lowest priority. Gaming the system: A process repeatedly gives up CPU just before the time quantum lapses. Accounting matters: The CPU usage of a process is now accumulated across time quanta. Once the CPU usage exceeds a single time quantum, the priority of the task will be decremented.","title":"Multi-level Feedback Queue (MLFQ)"},{"location":"cs2106/cs2106-notes/#lottery-scheduling","text":"Give out \u201clottery tickets\u201d to processes for various system resources When a scheduling decision is needed, a lottery ticket is chosen randomly among eligible tickets Responsive: a newly created process can participate in the next lottery A process can be given Y lottery tickets to distribute to its child process An important process can be given more lottery tickets Each resource can have its own set of tickets Different proportion of usage per resource per task","title":"Lottery Scheduling"},{"location":"cs2106/cs2106-notes/#scheduling-for-interactive-systems","text":"Criteria for Interactive Environment Response time : Time between request and response by system Predictability : Variation in response time, lesser variation -> more predictable Preemptive scheduling algorithms are used to ensure good response time Scheduler needs to run periodically Interval of timer interrupt (ITI) OS scheduler is triggered every timer interrupt Time Quantum Execution duration given to a process Could be constant or variable among the processes Must be multiples of interval of timer interrupt Large range of values","title":"Scheduling for Interactive Systems"},{"location":"cs2106/cs2106-notes/#process-alternative-threads","text":"","title":"Process Alternative - Threads"},{"location":"cs2106/cs2106-notes/#motivation-for-thread","text":"Process is expensive: Process creation under the fork() model: duplicate memory space, duplicate most of the process context etc Context switch: Requires saving/restoration of process information It is hard for independent processes to communicate with each other: Independent memory space -> no easy way to pass information Requires Inter-Process Communication (IPC) Thread is invented to overcome the problems with process model Started out as a \"quick hack\" and eventually matured to be very popular mechanism Basic Idea: A traditional process has a single thread of control: only one instruction of the whole program is executing at any time Add more threads of control to the same process: multiple parts of the programs is executing at the same time conceptually","title":"Motivation for Thread"},{"location":"cs2106/cs2106-notes/#process-and-thread","text":"A single proces can have multiple threads: multithreaded process Threads in the same process shares Memory context: text, data, heap OS context: process id, files Unique information needed for each thread Identification (usually thread id) Registers (general purpose and special) Stack Context Switch Process context switch involves: OS Context Hardware Context Memory Context Thread switch within the same process involves: Hardware context: Registers, \"Stack\" (actually just changing FP and SP registers) Threads: Benefits Economy Multiple threads in the same process requires much less resources to manage compared to multiple processes Resource sharing Threads share most of the resources of a process No need for additional mechanism for passing information around Responsiveness Multithreaded programs can appear much more responsive Scability Multithreaded program can take advantage of multiple CPUs Threads: Problems System call concurrency Parallel execution of multiple threads -> parallel system call possible Process behaviour fork() duplicate process, and thread behaviour is OS specific (the other threads may or may not get duplicated) If a single thread calls exit() in a multithreaded program, it typically terminates the entire process, not just the thread that called exit() When a single thread calls exec(), it replaces the entire process image with a new program. This includes all threads. The new program starts with a single thread, and the previous threads of the calling process are terminated","title":"Process and Thread"},{"location":"cs2106/cs2106-notes/#thread-models","text":"","title":"Thread Models"},{"location":"cs2106/cs2106-notes/#user-thread","text":"Thread is implemented as a user library; kernel is not aware of the threads in the process Advantages: Can have multithreaded program on ANY OS Thread operations are just library calls Generally more configurable and flexible e.g. Customized thread scheduling policy Disadvantages: OS is not aware of threads, scheduling is performed at process level (can never exploit multi-core processors) One thread blocked -> Process blocked -> All threads blocked Cannot exploit multiple CPUs!","title":"User Thread"},{"location":"cs2106/cs2106-notes/#kernel-thread","text":"Thread is implemented in the OS Thread operation is handled as system calls Thread-level scheduling is possible Kernel schedule by threads, instead of by process Advantages: Kernel can schedule on thread levels: More than 1 thread in the same process can run simultaneously on multiple CPUs Disadvantages: Thread operations is now a system call! Slower and more resource intensive Generally less flexible: Used by all multithreaded programs If implemented with many features, expensive, overkill for simple program If implemented with few features, not flexible enough for some programs","title":"Kernel Thread"},{"location":"cs2106/cs2106-notes/#hybrid-thread-model","text":"Have both kernel and user threads OS schedule on kernel threads only User thread can bind to a kernel thread If we use a 1-to-1 binding in a hybrid thread model, the end result is the same as a pure kernel-thread model as each user thread is bounded to a kernel thread that can be scheduled Offer great flexibility Can limit the concurrency of any process/ user","title":"Hybrid Thread Model"},{"location":"cs2106/cs2106-notes/#posix-threads-pthread","text":"Header file: # include <pthread.h> Compilation: gcc XXX.c -lpthread Datatypes pthread_t : Data type to represent a thread id pthread_attr : Data type to represent attributes of a thread Creation syntax Returns (0 = success; !0 = errors) Parameters: tidCreated: Thread Id for the created thread threadAttributes: Control the behavior of the new thread startRoutine: Function pointer to the function to be executed by thread argForStartRoutine: Arguments for the startRoutine function Pthread can start on any function as long as the function signature is void f(void ) int pthread_create( pthread_t* tidCreated, const pthread_attr_t* threadAttributes, void* (*startRoutine) (void*), void* argForStartRoutine ); Termination syntax Parameters: exitValue: Value to be returned to whoever synchronize with this thread (more later) If pthread_exit()is not used, a pthread will terminate automatically at the end of the startRoutine int pthread_exit( void* exitValue ); Join To wait for the termination of another pthread Returns (0 = success; !0 = errors) Parameters: threadID: TID of the pthread to wait for status: Exit value returned by the target pthread int pthread_join( pthread_t threadID, void **status );","title":"POSIX Threads: pthread"},{"location":"cs2106/cs2106-notes/#inter-process-communication-ipc","text":"General Idea: Process P1 creates a shared memory region M Process P2 attaches M to its own memory space P1 and P2 can now communicate using M Any writes to M can be seen by all other parties (behaves similar to normal memory region) Same model for multiple processes sharing the same memory region Process P1 1. Create M (implict attach) 2. Read/Write to M Process P2 1. Attach M 2. Read/Write to M Master program int main() { int shmid, i, *shm; // Create shared memory region shmid = shmget( IPC_PRIVATE, 40, IPC_CREAT | 0600); if (shmid == -1) { printf(\"Cannot create shared memory!\\n\"); exit(1); } else printf(\"Shared Memory Id = %d\\n\", shmid); // Attach shared memory region shm = (int*) shmat( shmid, NULL, 0 ); if (shm == (int*) -1) { printf(\"Cannot attach shared memory!\\n\"); exit(1); } // First element is used as control value shm[0] = 0; while(shm[0] == 0) { sleep(3); } for (i = 0; i < 3; i++){ printf(\"Read %d from shared memory.\\n\", shm[i+1]); } // Detach and destroy shared memory region shmdt( (char*) shm); shmctl( shmid, IPC_RMID, 0); return 0; } Slave program //similar header files int main() { int shmid, i, input, *shm; printf(\"Shared memory id for attachment: \"); scanf(\"%d\", &shmid); // Attach to shared memory region shm = (int*)shmat( shmid, NULL, 0); if (shm == (int*)-1) { printf(\"Error: Cannot attach!\\n\"); exit(1); } // Write 3 values for (i = 0; i < 3; i++){ scanf(\"%d\", &input); shm[i+1] = input; } // Let master program know we are done! shm[0] = 1; // Detach shared memory region shmdt( (char*)shm ); return 0; } Advantages Efficient: only create and attach involve OS Ease of use: shared memory region behaves the same as normal memory Disadvantages Synchronisation: shared resource means there is a need to synchronise access","title":"Inter-Process Communication (IPC)"},{"location":"cs2106/cs2106-notes/#message-passing","text":"Process P1 prepares a message M and send it to Process P2 Process P2 receives the message M Message sending and receiving are usually provided as system calls Naming scheme Direct communication Sender/ receiver of message explicitly name the other party Indirect communication Messages are sent to/ received from message storage Synchronisation behaviours Blocking primitives (synchronous) Sender/ receiver is blocked until message is received/ arrived Non-blocking primitives (asynchronous) Sender: resume operation immediately Receiver: either receive the message or some indication that message is not ready Advantages Portable: can be easily implemented Easier synchronisation Disadvantages Inefficient (requires OS intervention) Harder to use, messages are limited in size or format","title":"Message Passing"},{"location":"cs2106/cs2106-notes/#unix-pipes","text":"Piping in shell \"|\" symbol to link the input/output channels of one process to another (known as piping) Output of a process goes directly into another as input Pipe functions as circular bounded byte buffer with implicit synchronization: Writers wait when buffer is full Readers wait when buffer is empty Variants Half-duplex: unidirectional, one write end and one read end Full-duplex: bidirectional, read/ write for both ends System calls #include <unistd.h> int pipe( int fd[] ) Returns 0 to indicate success; !0 for errors","title":"Unix Pipes"},{"location":"cs2106/cs2106-notes/#unix-signal","text":"A form of inter-process communication An asynchronous notification regarding an event Sent to a process/thread Recipient of the signal must handle the signal by A default set of handlers User supplied handler E.g. kill, stop, continue, memory error, arithmetic error A process can install user-define handler for multiple different signals. [True] We can install user-define handler for all signals. [False: The \"kill -9\" i.e. SIGKIL is not captureable] A parent process can force the child processes to execute any part of their code by sending signal to them. [False: Only the signal handler can be triggered.] The \"kill\" signal (sent by the \"kill\" command) is different from the \"interrupt\" signal (sent by pressing \"ctrl-c\"). [True]","title":"Unix Signal"},{"location":"cs2106/cs2106-notes/#synchronization","text":"Designate code segment with race condition as critical section At any point in time, only one process can execute in the critical section Properties of correct critical section implementation: Mutual exclusion: Only one process can enter critical section Progress: If no process is in critical section, one of the waiting processes should be granted access Bounded wait: After process pi requests to enter critical section, there exists an upperbound of number of times other processes can enter the critical section before pi Independence: Process not executing in critical section should never block other process Incorrect synchonization: Deadlock: All processes blocked Livelock: Processes keep changing state to avoid deadlock and make no other progress Starvation: Some processes are blocked forever Implementations overview: Assembly level implementations: mechanisms provided by the processor High level language implementations: utilizes only normal programming constructs High level abstraction: provide abstracted mechanisms that provide additional useful features","title":"Synchronization"},{"location":"cs2106/cs2106-notes/#assembly-level-implementation","text":"TestAndSet Register, MemoryLocation Load the current content at MemoryLocation into Register Stores a 1 into MemoryLocation Performed as a single machine operation (i.e. atomic) It employs busy waiting (keep checking the condition until it is safe to enter critical section)","title":"Assembly Level Implementation"},{"location":"cs2106/cs2106-notes/#high-level-language-implementation","text":"Peterson's Algorithm Keep a turn variable, so process can only run when it is their turn Keep a Want array, so process can only run if they want Disadvantages Busy waiting Low level: more error prone","title":"High Level Language Implementation"},{"location":"cs2106/cs2106-notes/#high-level-abstraction","text":"Semaphore A generalized synchronization mechanism Only behaviours are specified Provides A way to block a number of processes, known as sleeping process A way to unblock/ wake up one or more sleeping process Wait(S) (called before a process enters critical section) If S <= 0, blocks processes (go to sleep) Decrement S Signal(S) (called after a process exits critical section) Increments S Wakes up one sleeping process if any This usage is commonly known as mutex (mutual exclusion) Properties Given S initial >= 0 Invariant: S current = S initial + number of signals() operations executed - number of wait() operations completed","title":"High Level Abstraction"},{"location":"cs2106/cs2106-notes/#classical-synchronization-problems","text":"Producer consumer Processes share a bounded buffer of size K Producers produce items to insert into buffer Consumers remove items from buffer Busy waiting while !canProduce, producer waits while !canConsumer, consumer waits Blocking version wait(notFull): producers go to sleep wait(notEmpty): consumers to go to sleep signal(notFull): 1 consumer wakes 1 producer signal(notEmpty): 1 producer wakes 1 consumer Readers writers Processes share a data structure D Readers retrieve information from D If they are the first reader, wait for roomEmpty If they are the last reader, signal roomEmpty and release mutex Writer modifies information in D (when roomEmpty) Writer might face starvation if rate of arrival of readers > rate of departure of readers (so number of readers never reach 0) Dining philosophers Tanenbaum solution To eat, a philosopher must acquire both the left and right chopsticks If a philosopher cannot acquire both chopsticks, they wait until both are available","title":"Classical Synchronization Problems"},{"location":"cs2106/cs2106-notes/#synchronization-implementations","text":"POSIX semaphore #include <semaphore.h> Initialize a semaphore Perform wait() or signal() on semaphore pthread mutex and conditional variables Synchronization mechanisms for pthreads Mutex (pthread_mutex): Binary semaphore (i.e. equivalent Semaphore(1)) Lock: pthread_mutex_lock() Unlock: pthread_mutex_unlock() Conditional Variables( pthread_cond ): Wait: pthread_cond_wait() Signal: pthread_cond_signal() Broadcast: pthread_cond_broadcast()","title":"Synchronization Implementations"},{"location":"cs2106/cs2106-notes/#memory-abstraction","text":"Types of data in a process Transient Data: Valid only for a limited duration, e.g., during function call e.g., parameters, local variables Persistent Data: Valid for the duration of the program unless explicitly removed (if applicable) e.g., global variable, constant variable, dynamically allocated memory If two processes are using the same physical memory, there might be conflicts in memory access because both processes assume memory starts at 0 Use logical adddress","title":"Memory Abstraction"},{"location":"cs2106/cs2106-notes/#contiguous-memory-management","text":"Assumptions Each process occupies a contiguous memory region Physical memory is large enough to contain one or more processes with complete memory space","title":"Contiguous Memory Management"},{"location":"cs2106/cs2106-notes/#memory-partitioning","text":"Fixed-Size Partitions Physical memory is split into fixed number of partitions of equal size A process will occupy one of the partitions Causes internal fragmentation (space leftover within partition when process takes less than partition size) Variable-Size Partitions Partition is created based on the actual size of process OS keep track of the occupied and free memory regions Causes external fragmentation from removing processes Can use a linked list (takes more time) to move occupied partitions and create larger holes Allocation algorithm First-fit Take the first hole that is large enough Next-fit Search from the last allocated block and wrap around Best-fit Find the smallest hole that is large enough Worst-fit Find the largest hole Buddy system Free block is split into half repeatedly to meet request size The two halves forms a sibling blocks (buddy blocks) When buddy blocks are both free, they can be merged to form larger block","title":"Memory Partitioning"},{"location":"cs2106/cs2106-notes/#disjoint-memory-schemes","text":"","title":"Disjoint Memory Schemes"},{"location":"cs2106/cs2106-notes/#paging","text":"Physical memory is split into regions of fixed size (known as physical frames) Logical memory is similarly split into regions of the same size (logical page) Lookup table to provide translation between logical page to physical page (page table) Physical address = frame_number x sizeof(physical_frame) + offset Offset: displacement from the beginning of the physical frame Address translation formula Page/Frame size of 2^n m bits of logical address Frame number represented by (m - n) bits Offset represented by n bits To store the page table, PCB (only software) Requires 2 memory accesses for every memory reference Translation Look-Aside Buffer (TLB) On-chip component to support paging TLB hit: Frame number is retrieved to generate physical address TLB miss: memory access to access the page table When context switch occurs, TLB entries are flushed New process will not get incorrect translation","title":"Paging"},{"location":"cs2106/cs2106-notes/#protection","text":"Access-Right Bits Each page table entry has a writable, readable, executable bit Every memory access is checked against the access right bits in hardware Valid Bit Included in each page table entry Indicated whether the page is valid to access by the process Every memory access is checked against this bit in hardware: Out-of-range access will be caught by OS in this manner","title":"Protection"},{"location":"cs2106/cs2106-notes/#page-sharing","text":"Several processes to share the same physical memory frame Use the same physical frame number in the page table entries Implementing Copy-On-Write Parent and child process can share a page until one tries to change a value in it","title":"Page Sharing"},{"location":"cs2106/cs2106-notes/#segmentation-scheme","text":"Manage memory at the level of memory segments Each memory segment Has a name Has a limit Memory references specified as \"segment name + offset\" Logical address translation Each segment mapped to a contiguous physical memory region with a base address and a limit/size Logical address <SegID, Offset> SegID is used to look up of the segment in a segment table Physical address = base + offset Offset < limit for valid access Each segment is an independent contiguous memory space Segmentation requires variable-size contiguous memory regions (can cause external fragmentation)","title":"Segmentation Scheme"},{"location":"cs2106/cs2106-notes/#segmentation-with-paging","text":"Each segment is composed of several pages instead of a contiguous memory region","title":"Segmentation with Paging"},{"location":"cs2106/cs2106-notes/#virtual-memory-management","text":"Secondary storage capacity >> Physical memory capacity Some pages are accessed much more often than others Basic idea: split the logical address space into small chunks (some are in physical memory, others in secondary storage)","title":"Virtual Memory Management"},{"location":"cs2106/cs2106-notes/#extended-paging-scheme","text":"Use page table for virtual -> physical address translation Two page types: Memory resident (pages in physical memory) Non-memory resident (pages in secondary storage) Use a resident bit in the page-table entry CPU can only access memory resident pages If attempt to access non-resident, page fault Hardware Check page table: Is page X a memory resident? Yes: Access physical memory location. Done. No: raise an exception! OS Page Fault: OS takes control Locate page X in secondary storage Load page X into a physical memory Update page table Go to step 1 to re-execute the same instruction This time with the page in memory","title":"Extended Paging Scheme"},{"location":"cs2106/cs2106-notes/#issues","text":"Secondary storage access time >> physical memory access time If memory access results in page fault most of the time To load non-resident pages into memory Entire system can slow down significantly (known as thrashing) Locality principles Temporal Locality: Memory address used now is likely to be used again Spatial Locality: Memory addresses close to the address that is used now is likely to be used soon Demand paging Process start with no memory resident page Only allocate a page when there is a page fault Fast startup time for new process Might be sluggish at the start due to page faults","title":"Issues"},{"location":"cs2106/cs2106-notes/#page-table-structure","text":"Page table information is kept with the process information and takes up physical memory space Direct paging Keep all entries in a single table Virtual Address: 32 bits, Page Size = 4KiB P=32\u201312=20; 2^20 pages Size of PTE = 2 bytes Page Table Size = 2^20 * 2 bytes = 2MiB 2-level paging Process may not use entire virtual memory space If original page tabel has 2^P entries With 2^M smaller page tables, M bits is needed to uniquely identify one page table Each smaller page table contains 2^(P-M) entries Problem: two serialized memory accesses just to get frame number TLB misses experience longer page-table walks Page-table walk: the traversal of page-tables in hardware","title":"Page Table Structure"},{"location":"cs2106/cs2106-notes/#inverted-page-table","text":"Page table is a per-process information With M processes in memory, there are M independent page tables Observation: Only N physical memory frames can be occupied Out of the M page tables, only N entries are valid! Huge waste: N << Overhead of M page tables Idea: Keep a single mapping of physical frame to <pid, page#> pid = process id , page# = logical page number in the corresponding the process page# is not unique among processes pid + page# can uniquely identify a memory page Entries are ordered by frame number instead of page number","title":"Inverted Page Table"},{"location":"cs2106/cs2106-notes/#page-replacement-algorithms","text":"No free physical memory frame during a page fault Memory access time: T access = (1 - p) _ T mem + P _ T page fault p = probability of page fault T mem = access time for memory resident page T page fault = access time if page fault occurs","title":"Page Replacement Algorithms"},{"location":"cs2106/cs2106-notes/#optimal-page-replacement-opt","text":"Replace the page that will not be needed again for the longest period of time Guarantees minimum number of page fault But future knowledge of memory references is needed","title":"Optimal Page Replacement (OPT)"},{"location":"cs2106/cs2106-notes/#fifo-page-replacement-algorithm","text":"Memory pages are evicted based on their loading time Evict the oldest memory page OS maintains a queue of resident page numbers But FIFO does not exploit temporal locality","title":"FIFO Page Replacement Algorithm"},{"location":"cs2106/cs2106-notes/#least-recently-used-lru","text":"Make used of temporal locality Replace the page that has not been used in the longest time But implementation is difficult Using a \"time\" counter: need to search through all pages to find the smallest Using a \"stack\": hard to implement in hardware because it is not a pure stack","title":"Least Recently Used (LRU)"},{"location":"cs2106/cs2106-notes/#second-chance-page-replacement-aka-clock","text":"Modified FIFO to give a second chance to pages that are accessed Each page table entry has a reference bit Degenerate into FIFO algorithm Algorithm: The oldest FIFO page is selected (victim page) If reference bit == 0, page is replaced If reference bit == 1, page is skipped and reference is cleared to 0","title":"Second-Chance Page Replacement (aka CLOCK)"},{"location":"cs2106/cs2106-notes/#frame-allocation","text":"Best way to distribute N physical memory frames to M processes competing for frames Equal allocation Each process gets N/M frames Proportional allocation Each process gets size_of_process / total_size * N frames Victim page selected among pages of the process that causes page fault: local replacement Number of frames allocated to a process remain constant If frames allocated not enough, it may hinder the progress of process Victim page selected among all physical frames: global replacement Allow self-adjustment between processes Badly behaved processes can steal frames from other processes Thrashing Insufficient physical frame In global replacement: A thrashing process \"steals\" page from other process cause other process to thrash (Cascading Thrashing) In local replacement: thrashing can be limited to one process, but that process can use up the I/O bandwidth and degrade performance of others\\ Right number of frames: working set Transient region: working set changing in size Stable region: working set about the same for a long time","title":"Frame Allocation"},{"location":"cs2106/cs2106-notes/#file-management","text":"Common file types: regular files: contains user information Directories: system files for file system structure Special files: character/ block oriented File types: Use file extension as indication Use embedded information in the file (magic number stored at beginning of file)","title":"File Management"},{"location":"cs2106/cs2106-notes/#file-protection","text":"Controlled access to the information stored in a file Access: read, write, execute, append, delete, list Users classified into three classes: Owner Group Universe Define permission of three access types: r w x r w x r w x Access control list can be Minimal (same as ppermission bits) Extended (added named users/ groups)","title":"File Protection"},{"location":"cs2106/cs2106-notes/#file-data","text":"Structure Array of byes Each byte has a unique offset from file start Fixed length records Array of records that can grow and shrink Variable length records Flexible but harder to locate Access methods Sequential access Data read in order, starting from beginning e.g. cassette tapes Random access Data can be read in any order Read (offset): every read operation explicitly states the position to be accessed Seek (offset): special operation to move to a new location in file Direct access Used for file that contains fixed-length records Allow random access to any record directly OS provides file operations as system calls Provide proection, concurrent and efficient access","title":"File Data"},{"location":"cs2106/cs2106-notes/#file-information","text":"Information kept for an opened file File pointer: keep track of the current position within a file File descriptor: unique identifier of the file Disk location: actual file location on disk Open count/ reference count: number of proccesses that have the file opened Per-process open-file table: To keep track of the open files for a process Each entry points to the system-wide open-file table entries System-wide open-file table: To keep track of all the open files in the system Each entry points to a V-node entry System-wide V-node (virtual node) table To link with the file on physical drive Contains the information about the physical location of the file","title":"File Information"},{"location":"cs2106/cs2106-notes/#processes-and-files","text":"Process A tries to open a file that is currently being written by Process B. OS uses the Open File Table to check for existing opened file. Since the file is already opened for reading, it can reject the file open system call from process A. Process A tries to use a bogus file descriptor in a file-related system call. Since Process A passed the file descriptor (fd for short) to OS as parameter, OS can check whether that particular entry is valid (or even exists) in the PCB of A. If the fd is out of range, non-existent etc, OS can reject the file-related system calls made by Process A. Process A can never \"accidentally\" access files opened by Process B. Since the fd index is in process specific PCB, there is no way Process A can access Process B's file descriptor table. Process A and Process B reads from the same file. However, their reading should not affect each other. Process A and Process B can have their own fds, which refers to two distinct locations in the open file table. Each entry of the open file table keep track of the current location separately. This enables Process A and Process B to read from the same file independently. Redirect Process A's standard input / output, e.g. \"a.out < test.in > test.out\". So, for all file redirections, it is a simple question of: Opening and possibly creating the file. Replace the corresponding file descriptor to point to the entry from (1) in the open file table.","title":"Processes and Files"},{"location":"cs2106/cs2106-notes/#directory","text":"Used to Provide a logical grouping of files Keep track of files Single-Level All files are in root directory Tree-Structured Directories can be recursively embedded in other directories Direct Acyclic Graph If a file can be shared, only one copy of actual content \"Appears\" in multiple directories with different file names Alias is for files only, not directories Unix hard link ( ln ) Directory A and B have separate pointers to the actual file F in disk Can only be deleted when all links are deleted General Graph Users have the capability to create a cycle of directory within a directory Hard to traverse, and need to prevent infinite looping Unix symbolic link/ soft link ( ln -s ) Symbolic link is a special link file that contains the path name of the file F When link file is accessed, it finds where the F is and accesses F Simple deletion: link is deleted, not file; file is deleted, dangling link","title":"Directory"},{"location":"cs2106/cs2106-notes/#file-system-implementations","text":"Master Boot Record (MBR) at sector 0 with partition table Followed by one or more partitions Each partition can contain an independent file system","title":"File System Implementations"},{"location":"cs2106/cs2106-notes/#file-block-allocation","text":"Contiguous Allocate consecutive disk blocks to a file External fragmentation Linked list Keep a linked list of disk blocks that each stores next disk block number and actual file data Random access in a file is slow File allocation table (FAT) FAT entry contains either: FREE code (block is unused) Block number of next block EOF code (i.e., NULL pointer) BAD block (block is unusable, i.e., disk error) Faster random access FAT keeps track of all disk blocks in a partition, which will be expensive when disk is large Indexed allocation Maintain blocks for each file; IndexBlock[N] == Nth block address Lesser memory overhead Limited maximum file size (max number of blocks == number of index block entries) I-Node Data Every file/ directory has an I-node associated Allows fast access to small file Flexibility in handling huge files","title":"File Block Allocation"},{"location":"cs2106/cs2106-notes/#free-space-management","text":"Maintain free space information Bitmap Each disk block represented by 1 bit Linked list Each disk block contains number of free disk block numbers or pointer to next free space Easy to locate free block High overhead","title":"Free Space Management"},{"location":"cs2106/cs2106-notes/#implementing-directory","text":"Keep track of files in directory Map the file name to file information Linear list Each directory consists of a linear list where each entry represents a file Locating a file requires linear search Hash table Each directory consists of a hash table of size N Fast lookup Hash table has limited size File information Each directory consists of file information (name and disk block information) Stored in directory entry directly OR Store only name and point to some data structure for other info","title":"Implementing Directory"},{"location":"cs3213/cs3213-notes/","text":"CS3213 Notes AY23/24 Sem2 CS3213 Notes AY23/24 Sem2 Software Engineering Software Engineering Activities Software Process Models Waterfall Model Incremental Development Prototyping Integration and Configuration Requirements Engineering Software Requirements Documents Requirements Elicidation and Analysis Requirements Specification Natural Language Use Cases and User Stories Requirements Validation Basis for Testing Requirements Management Planning Software Architecture Architectural Drivers Advantages of Architectural Design Architectural Patterns Quality Attributes Availability Tactics System Modeling Modeling Languages UML C4 Business Process Model and Notation (BPMN) Agile Software Development Agile Manifesto Agile Reasons Scrum Kanban Extreme Programming Quality Assurance: Software Testing Testing Levels Test Flakiness Testing and Processes Automated Testing Approaches Software Evolution Software Engineering \u201cSoftware engineering is an engineering discipline that is concerned with all aspects of software production from initial conception to operation and maintenance.\u201d (Sommerville) Engineering is about selectively using theories, methods, and tools where appropriate No silver bullet (1986) Fred Brooks 1931-2022 \u201cThere is no single development, in either technology or in management technique, that itself promises even one order-of-magnitude improvement in productivity, in reliability, in simplicity.\u201d \u201cI believe the hard part of building software to be the specification, design, and testing of this conceptual construct, not the labor of representing it and testing the fidelity of the representation. [...] If this is true, building software will always be hard . There is inherently no silver bullet.\u201d Software Engineering Activities Central software engineering activities: Software specification The functionality of the software and contraints on its operation must be defined Software development The software to meet the specification must be produced Software validation The software must be validated to ensure it does what the customer wants Software evolution The software must evolve to meet changing customer needs Two general perspectives: Plan-based development Requirements engineering --> requirements specification --> design and implementation --(requirements change requests)--> requirements engineering Agile development Requirements engineering --> design and implementation --> requirements engineering Software Process Models Software process model: simplified representation of a software process Typically from one perspective (eg activities, but no people and their roles) Waterfall Model Plan-driven model: plan and schedule before starting development Next phase only starts after previous one completed Works well if requirements are clear, large safety-critical software systems Drawback: Accomodating change (e.g. changing requirements) Incremental Development Interleaves the activities of specification, development, and validation System is developed as a series of versions (increments), with each version adding functionality to the previous version Cost of accommodating change and responding to changing customer requirements is lower More rapid delivery of software Plan-driven (e.g., in combination with prototyping) or agile Drawback Process is less measurable; degrading system structure (refactoring required) Prototyping Developing executable model of the system Requirements engineering: can help with the elicitation and validation of system requirements System design: can be used to explore software solutions and in the development of a user interface for the system Integration and Configuration Requirements Engineering Requirements: Descriptions of the services that a system should provide and the constraints on its operation. Reflect the needs of customers for a system that serves a certain purpose such as controlling a device, placing an order, or finding information. Requirements engineering (RE): Process of finding out, analyzing, documenting and checking these services and constraints Stakeholders: Person or organization who influences a system\u2019s requirements or who is impacted by that system. Problems: Users' incomplete understanding of needs, computer capabilties and limitations Conflicting views from different users Requirements evolve over time Reasons for requirements engineering: Lowest defect cost High cost of errors during requirements Communication between stakeholders for customer relation and communication Basis for structure and behaviour of software design Basis for testing and acceptance of final product Dictate the quality of the system realisation, risks and overhead in operations Software Requirements Documents Software Requirements Specification (SRS) Goal of requirements definition May include both the user requirements for a system and a detailed specification of the system requirements Requirements change rapidly in agile methods: requirements are written incrementally as user stories Requirements User requirements: statements of what services the system is expected to provide to system users and the constraints under which it must operate System requirements: more detailed descriptions of the software system\u2019s functions, services, and operational constraints Document (or functional specification) should define exactly what is to be implemented May be part of the contract between the system buyer and the software developers Functional: describe what the system should do Should be complete and consistent Non-functional: requirements that are not directly concerned with the specific services delivered by the system to its users Often more critical than individual functional requirements Whenever possible, they should be written quantitatively so they can be objectively tested Key activities: Elicitation and analysis: discovering requirements by interacting with the stakeholders Specification: converting the requirements into a standard form Validation: checking that the requirements actually define the system that the customer wants High level business requirements --> detailed system requirements Elicidation and Analysis Challenges: Stakeholders often do not know what they want from a computer system except in the most general terms They may make unrealistic demands because they do not know what is and is not feasible. Political factors may influence the requirements of a system. Managers may demand specific system requirements because these will allow them to increase their influence in the organization. Economic and business environment in which the analysis takes place is dynamic. It inevitably changes during the analysis process. Process Model Process of interacting with stakeholders to discover requirements Groups related requirements and organises them into coherent clusters One way of doing so is to consider each group to be a viewpoint and collect all requirements from that group into that viewpoint Priorising requirements and resolving requirements conflicts Requirements are documented and input into the next round of the spiral Elicidation Methods: Interviewing Closed interview: stakeholder answers a predefined set of questions Open interviews: no predefined agenda. The requirements engineering team explores a range of issues with system stakeholders and hence develops a better understanding of their needs Document analysis (prior research) Workshops Focus groups Prototyping Observation (of how people work) Personas: an archetype of a user group Requirements Specification User Requirements Almost always written in natural language supplemented by appropriate diagrams and tables in the requirements document Should describe the functional and nonfunctional requirements so that they are understandable by system users who do not have detailed technical knowledge Should specify only the external behavior of the system Should not include details of the system architecture or design System Requirements May also be written in natural language, but other notations based on forms, graphical, or mathematical system models can also be used Expanded versions of the user requirements that software engineers use as the starting point for the system design Add detail and explain how the system meets user requirements May be used as part of the contract for the implementation of the system Should be a complete and detailed specification of the whole system Should only describe the external behavior of the system and its operational constraints Should not be concerned with how the system should be designed or implemented. Natural Language Invent a standard format and ensure that all requirement definitions adhere to that format. Use text highlighting (bold, italic, or color) to pick out key parts of the requirement. Avoid the use of jargon, abbreviations, and acronyms. Use Cases and User Stories User-centric view to elicit and specify requirements both common in the traditional view and for agile methods Focus on what users need to accomplish (i.e., the tasks they expect the system to do for them) Use case Describes an interaction between an actor and the system Documented as a high-level use case diagram Set of use cases represents all of the possible interactions that will be described in the system requirements User story Serve as a placeholder that will be split into smaller stories for implementation; elaborate to acceptance tests called \u201cconditions of satisfaction\u201d Requirements Validation Process of checking that requirements define the system that the customer really wants Feasibility study A short, focused study that should take place early in the RE process System prototyping A version of the system or part of the system is developed quickly to check the customer\u2019s requirements and the feasibility of design decisions Peer review Someone else than the author of the document reviews the requirements Informal review Collecting unstructured feedback Formal requirements review Requirements are analyzed systematically by a team of reviewers who check for errors and inconsistencies Inspection Reviewing one requirement at a time, and noting down defects Validity checks: requirements reflect the real needs of system users Consistency checks: requirements in the document should not conflict Completeness checks: requirements document should include requirements that define all functions and constraints intended Realism checks: can be implemented within proposed budget Verifiability: reduce the potential for dispute between customer and contractor Basis for Testing Requirements should be testable and used to derive test cases Test-driven development V-model and testing Requirements Management Planning Concerned with establishing how a set of evolving requirements will be managed Requirements identification: Each requirement must be uniquely identified So it can be cross-referenced with other requirements and used in traceability assessments A change management process: Set of activities that assess the impact and cost of changes Traceability policies: Define the relationships between each requirement and between the requirements and the system design that should be recorded Tool support: Range from specialist requirements management systems to shared spreadsheets and simple database systems Software Architecture How the system is organized (e.g., components and relations) How developers explain the system at a high level (i.e., the overall structure) Architectural pattern: established architectural solution that might comprise multiple architectural tactics Design pattern: typically less relevant for architecture (e.g., Factory Pattern or Facade) Architectural tactic: design decision that influences a quality attribute Architectural Drivers Architecturally significant requirements (ASRs): requirements that have a measurable impact on the architecture Representing as Block diagram: box as component, arrow as data/ control flow UML C4 Context diagrams (level 1): show the system in scope and its relationship with users and other systems Container diagrams (level 2): decompose a system into interrelated containers. A container represents an application or a data store Component diagrams (level 3): decompose containers into interrelated components, and relate the components to other containers or other systems Code diagrams (level 4): provide additional details about the design of the architectural elements that can be mapped to code. The C4 model relies at this level on existing notations like UML Structures Component-and-connector (C&C) structures: focuses on the way components interact with each other at run time Module structures: focuses on how to partition systems into implementation units (modules like packages, classes, layers) Decomposition structure: shows how modules are related to each other by the \u201cis-a-submodule-of\u201d relation Uses structure: focuses on a \u201cuses\u201d relation, where unit requires another unit for its correct functioning Generalization structure: focus on classes and their relationships, \u201cInherits-from\u201d or \u201cis-an-instance-of\u201d relation Allocation structures: focuses on how software maps to non-software structures, such as its organizations Advantages of Architectural Design Quality Attributes Whether or not a system meets its quality attributes (i.e., non-functional requirements) is significantly influenced by its architecture Modifiability and Reasoning about Change Modifiability is a quality attribute, but one of the most common and important ones Three categories of changes Local change: only single component is affected (e.g., adding a new rule to a pricing module) Non-local change: multiple elements are affected (e.g., besides the rule, database and UI needs to be changed) Architectural change: affects how the elements interact and might require changes over the whole system Communication Among Stakeholders Can be used as a basis for mutual understanding, negotiating, forming consensus, and communicating with each other Architectural Patterns Typically comprise multiple architectural tactics Big ball of mud An antipattern: lack of architecture Layered architecture A layer can only use the layer directly beneath it Quality attributes: Modifiability: separation allows changes to be localized Portability: allows layers to be general or specific to an OS or environment Reusability Monoliths: Layered and Modular Often used to distinguish the architecture from a distributed architecture (e.g., microservices) Typically a single deployable unit Layered: technical partitioning Modular: partitioned by domains or workflows Pipe-and-filter architecture Pipe: data as input and output Filters incrementally read their input, process it, and incrementally write it to their output Data flows through the pipes: transformed, filtered, or enriched Quality attributes: Modifiability: filters are independent from each other Reconfigurability: filters can be combined in different ways Model-centered Independent components interact with a central model (also known as repository style) rather than with each other Quality attributes: Modifiability Extensibility Model View Controller (instantiation of a model-centered architecture) Three components Model: model like in other model-centered architecture Controller: for user interaction, updates the model View: renders the presentation of the model Quality attributes: Highly modifiable: Components are independent, can be added; state can be managed and persisted since it is centralized Concurrency: Views and controllers can run in their own threads or processes Microkernel (plug-in architecture) Natural fit for many products that are installed as a single, monolithic deployment Each subsystem in the platform is itself structured as a set of plug-ins that implement some key function Quality attributes: Extensibility Maintainability Testability Client-server Clients request services from the server Quality attributes: Maintainability: organizations can change a business process or rule by changing the implementation of the server (rather than all the individual clients) Evolvability Service-oriented Focus on independent (domain) services that are separately deployed Quality attributes: Deployability: services can be individually managed Testability: services can be individually tested Reliability: if one service goes down, others might be able to continue Microservice Primary goal is decoupling: microservices are expected to be independent Each microservice models a domain or workflow Quality attributes: Quick time to market and Deployability Independence: each team can make its own technology choices Scalability: service instances can be dynamically added Quality Attributes Source Specifies where the fault comes from Internal/ external: people, hardware, software Stimulus Cause of fault Omission, crash, incorrect timing Artifact Which portions of the system are responsible for and affected by the fault Processors, communication channels, storage Environment Running environment and environment that is recovering from a fault Normal operation, startup, shutdown, overloaded operation, repair mode Response Most commonly desired response is to prevent the fault from becoming a failure Response Measure Focus on a number of measures of availability, depending on the criticality of the service being provided Time to detect the fault, time to repair the fault Availability Tactics Detect faults Monitor: monitor various components of the system Heartbeat: periodic message exchange between a system monitor and a process being monitored Sanity checking: checks the validity of specific operations or their output based on the knowledge of their internal structure Recover (Preparation and repair) Redundant spare : one or more duplicate components can step in if a component fails Rollback : revert to a previous, known good state Software upgrade : in-service upgrade in a non-service-affecting manner Recover (Reintroduction) Shadow : operate a component in a \"shadow mode\" while being mentored before revering it back to an active mode Escalating restart : automatic restart at different granularities (clear caches/ restart the whole system) Prevent faults Removal from service Transactions : Provide atomic, consistent, isolated and durable properties Increase competence set : set of states in which the program can \"competently\" operate System Modeling Goal: develop abstract models of a system Perspectives: External perspective: context or environment of the system Interaction perspective: interactions between a system and its environment, or between the components of a system Structural perspective: model the organization of a system or the structure of the data that is processed by the system Behavioral perspective: model the dynamic behavior of the system and how it responds to events Modeling Languages UML , C4, Business Process Model and Notation (BPMN), Systems modeling language (SysML) UML Sequence diagrams focus on objects in a system, whereas activity diagrams focus on operations or activities State machine diagram Show how the system reacts to internal and external events Example of a behavioral model (like activity diagrams) Focus on system states and events that cause transitions from one state to another Use case diagram Shows interactions between actors and system Class diagrams: show the object classes in the system and the associations between these classes Sequence diagrams: show interactions between actors and the system and between system components Activity diagrams: show the activities involved in a process or in data processing C4 Developed for modeling for software architectures Hierarchical diagrams and abstractions System context: a System Context diagram provides a starting point, showing how the software system in scope fits into the world around it Containers: a Container diagram zooms into the software system in scope, showing the high-level technical building blocks Components: a Component diagram zooms into an individual container, showing the components inside it Code: A code (e.g. UML class) diagram can be used to zoom into an individual component, showing how that component is implemented Business Process Model and Notation (BPMN) For business processes, similar to UML activity diagrams Related standard: Decision Model and Notation (DMN) Means deriving a result (output) from given facts (input) on the basis of defined logic (decision logic) Most popular way to model decisions: a decision table Agile Software Development Agile Manifesto Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan Satisfy the customer through early and continuous delivery of valuable software Welcome changing requirements, even late in development Delivery working software frequently Agile Reasons Organisations' SE priorities: End-customer satisfaction Time to delivery Competitive advantage Used for ongoing release cycles, featuring small incremental changes Scrum General, lightweight framework Does not specify how to do requirements engineering, architecture, etc Prescriptive: proposes specific rules that need to be followed Often seen as a synonym to agile practices Focus: delivering value Achieves this via increments in sprints Founded on empiricism and lean thinking Empiricism: knowledge comes from experience and decision making based on observations Lean thinking: reduce waste and focus on the essentials Scrum pillars Transparency: process and work is visible for those doing the work and receiving its output Inspection: artifact and process is inspected frequently to detect problems Adaption: adjustments if the resulting product is unacceptable Sprints Goal: create a useful increment Includes planning, daily scrums, sprint review, sprint retrospective and product backlog Artifacts: product backlog (ordered list of what is needed to improve the product), sprint backlog (sprint goal, product backlog items selected for sprint, an actionable plan for delivering the increment), increment (concrete stepping point towards product goal) User stories: describe some functionality and represent customer requirements Card: a written description of the story used for planinng Conversation: verbal exchange with the customer to flesh out the details of the story Confirmation: acceptance tests specified by the customer can be used to determine when a story is complete Kanban Optimizes flow using a visual, pull-based system Definition of Workflow (DoW): explicit shared understanding of flow, which requires a definition of various concepts A definition of how WIP will be controlled from started to finished A service level expectation (SLE), which is a forecast of how long it should take a work item to flow from started to finished Extreme Programming Extreme Programming (XP) takes an \u201cextreme\u201d approach to iterative development and best practices New versions may be built several times per day Increments are delivered to customers every 2 weeks All tests must be run for every build and the build is only accepted if tests run successfully Pair programming All code is produced by two developers working together One developer is programming, while the other is reviewing and focusing on the big picture Test-driven development XP proposed test-driven development Unit tests are written before the code is written Acceptance tests are derived from the user requirements Continuous integration Development team should always work on the latest version of the software Code should be integrated into the main branch of the project frequently On-site customer: A representative of the end-user of the system (the customer) should be available full time for the use of the XP team. In an extreme programming process, the customer is a member of the development team and is responsible for bringing system requirements to the team for implementation. Sustainable pace: Large amounts of overtime are not considered acceptable as the net effect is often to reduce code quality and medium term productivity Quality Assurance: Software Testing Defect testing : \u201cprogram testing can be used very effectively to show the presence of bugs but never to show their absence\u201d - Dijkstra Validation testing : demonstrate that the system corresponds to the requirements Verification: \"are we building the product right\" Programming errors Validation: \"are we building the right product\" Whether this is what user requires Test Case Test Oracle : is a mechanism for determining whether a test has passed or failed (e.g. assertEquals ) Test input Automated testing: testing tool automatically generates a test input and applies a test oracle Manual test: manually testing for defects Pesticide paradox: Every method you use to prevent or find bugs leaves a residue of subtler bugs against which those methods are ineffectual Not all bugs can be identified from one method of testing Testing Levels Unit test: testing individual components Typically fast, and allow testing of large portions of a system in limited time Easy to control, as they typically check expected result values when passed a certain input value Easy to write, as they require no additional set up Lack reality, as they do not represent the real execution of a system Integration test: testing multiple components in combination Typically focuses on \"our\" component and an external component (database system or web services) System test (end-to-end test): evaluating the whole system Run the system in its entirety instead of testing small parts in isolation Realistic tests but are often slow and harder to write Test Flakiness Flaky test: a test that might non-deterministically pass or fail Lowers confidence in the tests, difficult to debug, might lower overall developer productivity Causes: Concurrency, when task is shared by multiple threads Async wait: whether the test case succeeds depends on how quickly server responds Test pyramid: write tests with different granularity (fewer high-level tests, many small and fast unit tests) Testing and Processes Waterfall model V-model Testing happens after requirements engineering, architecture, design phases Testing is planned together with other phases Acceptance testing User Acceptance Testing (UAT): focuses on validation, that is, checking whether the system meets the users\u2019 requirements Test driven development (TDD) Focus on requirements and quick feedback Used when faced with complex problem or solution not yet clear Classicist/ detroit school: inside-out TDD, start with different units that will compose the overall feature London school: outside-in TDD, start from the outside and use of mocking Steps Write test Check that the newly-written test fails Write the simplest code that passes the new test All tests should now pass Refactor as needed Black-box: no internal information Specification-based testing, derives tests based on the requirements or documentation White-box: internal information (based on a function's implementation) Use the source code to guide testing, known as structural testing Main means through coverage criteria Line: lines_covered / total lines x 100% Branch (each branching instruction): branches_covered / total branches x 100% Condition (multiple conditions like && || in one line) + branch: (branches_covered + conditions_covered) / (total_branches + total_conditions) x 100% Path: paths_covered / total_paths x 100% Modified condition/ decision coverage: number_of_conditions_evaluated_to_all_possible_outcomes_affecting_the_outcome_of_the_decision / total_number_of_conditions_within_the_decisions x 100% Test important combinations of conditions and thus reduce the cost as compared to full Path Coverage Each condition in a decision is shown to independently affect the outcome of the decision Exploratory testing Explore what the program does to increase your understanding and build a mental model Devising test cases: boundary value analysis, identifying partitions Mutation testing Evaluate the quality of exisiting tests and derive new tests Mutate code in the program (introduce a bug), assuming that a test case \"kills\" the mutant Effective way of discovering undertested parts Automated Testing Approaches Automated testing tackles test input generation and/or test oracle problem Property-based testing Specify properties for the component we can test and let the test framework find a test input that might cause the property to break Property-based testing framework: jqwik for Java Useful for complex functionality and if there is uncertainty whether example-based tests are sufficient Differential testing Send a common input to multiple systems and see whether their result or other properties agree Compare between: Different versions of a software Different configurations Against a simple reference engine Different implementations of the same functionality Potentially small overlap in functionality and intended differences makes this technique produce false alarms that need to be analyzed Metamorphic testing Use a source test-case (and its result) to generate a follow-up test case for which the result can be inferred Black-box approach Equivalence Modulo Inputs (EMI) is one of the most successful metamorphic testing approaches Rather than creating equivalent programs, create programs that are equivalent only for a given input, which is easier Constraint Solvers Constraint solvers accept a formula and check if it is satisfiable (SAT) or unsatisfiable (UNSAT) Boolean Satisfiability (SAT Solvers) Input: propositional formula Output: model that satisfies the formula Satisfiability Modulo Theories (SMT Solvers) Solve a formula based on a given theory Symbolic Execution Testing involves executing the program on one, concrete input Uses an SMT solver to determine whether a patch condition is feasible or not Systematically generate inputs (but there might be path explosion) Fuzzing Black-box fuzzing: send random input to the program and hope it crashes Mutation-based fuzzing: Rather than passing random input to the program, mutate existing inputs White-box fuzzing: Leverages detailed knowledge of the program for fuzzing Grey-box fuzzing: For each mutated input, check whether it resulted in a gain of code coverage (or code coverage pattern) Test-case Reduction: many automated input generation techniques generate large inputs Remove redundant test cases that do not trigger the bug Delta debugging*: systematically removes elements from the bug-inducing input; Behaves like binary search but tries different combinations of smaller blocks where binary search fails Small scope hypothesis: A high proportion of errors can be found by testing a program for all test inputs within some small scope Static analysis tools are tools that reason about code without executing it Linters and style checkers Data-flow analysis Control-flow analysis Completeness: If analysis says X is true, it is really true Soundness: If X is true, the analysis will indicate that X is true *Delta Debugging (with granularity n = 2) Try to reduce to subset (use only either input 1 or input 2) Try to reduce to complement (swap input 1 and 2) If both result in no bug, increase granularity to n = 4 (have input 1, 2, 3, 4) If input that fails the test is found, reduce granularity to n = 3 If still fails, reduce granularity again If passes, increase granularity (find the local minimum) Software Evolution Versioning Software versioning is the process of assigning either unique version names or unique version numbers to unique states of computer software Commit hash: automatically generated, but near random and may include irrelevant versions in-between Calendar versioning (YY.MM.DD.HH.mm) Semantic versioning (major version. minor version. patch version) Bug finding Infrastructure software such as databases, compilers are depended on to build stable software Fuzz testing: tries to break infrastructure software by randomizing input Feature triage Requirements elicitation changes after release Determine the usage and performance of software via analytics and telemetry Deprecation Don't deprecate Backwards compatibility is a feature Early mistakes cannot be easily reversed Translation interface Adapt the old interface to call the new one, migration is blind to user Need to maintain old promises Hyrum's law: With a sufficient number of users of an API, it does not matter what you promise in the contract; all observable behaviors of your system will be depended on by somebody. With enough users, any change to a piece of software will break somebody's workflow Migration tooling Create a tool for stakeholders to automatically upgrade to the next version Tool needs to be created and tested End-of-support period Guarantee some support of old versions to give stakeholders time to migrate Someone needs to maintain the old version Advisory Deprecation Deprecations that have no deadline and are not a high priority for the organization Compulsory Deprecation Deprecations that have a deadline, after which the deprecated interface is no longer guaranteed to work","title":"CS3213 Notes AY23/24 Sem2"},{"location":"cs3213/cs3213-notes/#cs3213-notes-ay2324-sem2","text":"CS3213 Notes AY23/24 Sem2 Software Engineering Software Engineering Activities Software Process Models Waterfall Model Incremental Development Prototyping Integration and Configuration Requirements Engineering Software Requirements Documents Requirements Elicidation and Analysis Requirements Specification Natural Language Use Cases and User Stories Requirements Validation Basis for Testing Requirements Management Planning Software Architecture Architectural Drivers Advantages of Architectural Design Architectural Patterns Quality Attributes Availability Tactics System Modeling Modeling Languages UML C4 Business Process Model and Notation (BPMN) Agile Software Development Agile Manifesto Agile Reasons Scrum Kanban Extreme Programming Quality Assurance: Software Testing Testing Levels Test Flakiness Testing and Processes Automated Testing Approaches Software Evolution","title":"CS3213 Notes AY23/24 Sem2"},{"location":"cs3213/cs3213-notes/#software-engineering","text":"\u201cSoftware engineering is an engineering discipline that is concerned with all aspects of software production from initial conception to operation and maintenance.\u201d (Sommerville) Engineering is about selectively using theories, methods, and tools where appropriate No silver bullet (1986) Fred Brooks 1931-2022 \u201cThere is no single development, in either technology or in management technique, that itself promises even one order-of-magnitude improvement in productivity, in reliability, in simplicity.\u201d \u201cI believe the hard part of building software to be the specification, design, and testing of this conceptual construct, not the labor of representing it and testing the fidelity of the representation. [...] If this is true, building software will always be hard . There is inherently no silver bullet.\u201d","title":"Software Engineering"},{"location":"cs3213/cs3213-notes/#software-engineering-activities","text":"Central software engineering activities: Software specification The functionality of the software and contraints on its operation must be defined Software development The software to meet the specification must be produced Software validation The software must be validated to ensure it does what the customer wants Software evolution The software must evolve to meet changing customer needs Two general perspectives: Plan-based development Requirements engineering --> requirements specification --> design and implementation --(requirements change requests)--> requirements engineering Agile development Requirements engineering --> design and implementation --> requirements engineering","title":"Software Engineering Activities"},{"location":"cs3213/cs3213-notes/#software-process-models","text":"Software process model: simplified representation of a software process Typically from one perspective (eg activities, but no people and their roles)","title":"Software Process Models"},{"location":"cs3213/cs3213-notes/#waterfall-model","text":"Plan-driven model: plan and schedule before starting development Next phase only starts after previous one completed Works well if requirements are clear, large safety-critical software systems Drawback: Accomodating change (e.g. changing requirements)","title":"Waterfall Model"},{"location":"cs3213/cs3213-notes/#incremental-development","text":"Interleaves the activities of specification, development, and validation System is developed as a series of versions (increments), with each version adding functionality to the previous version Cost of accommodating change and responding to changing customer requirements is lower More rapid delivery of software Plan-driven (e.g., in combination with prototyping) or agile Drawback Process is less measurable; degrading system structure (refactoring required)","title":"Incremental Development"},{"location":"cs3213/cs3213-notes/#prototyping","text":"Developing executable model of the system Requirements engineering: can help with the elicitation and validation of system requirements System design: can be used to explore software solutions and in the development of a user interface for the system","title":"Prototyping"},{"location":"cs3213/cs3213-notes/#integration-and-configuration","text":"","title":"Integration and Configuration"},{"location":"cs3213/cs3213-notes/#requirements-engineering","text":"Requirements: Descriptions of the services that a system should provide and the constraints on its operation. Reflect the needs of customers for a system that serves a certain purpose such as controlling a device, placing an order, or finding information. Requirements engineering (RE): Process of finding out, analyzing, documenting and checking these services and constraints Stakeholders: Person or organization who influences a system\u2019s requirements or who is impacted by that system. Problems: Users' incomplete understanding of needs, computer capabilties and limitations Conflicting views from different users Requirements evolve over time Reasons for requirements engineering: Lowest defect cost High cost of errors during requirements Communication between stakeholders for customer relation and communication Basis for structure and behaviour of software design Basis for testing and acceptance of final product Dictate the quality of the system realisation, risks and overhead in operations","title":"Requirements Engineering"},{"location":"cs3213/cs3213-notes/#software-requirements-documents","text":"Software Requirements Specification (SRS) Goal of requirements definition May include both the user requirements for a system and a detailed specification of the system requirements Requirements change rapidly in agile methods: requirements are written incrementally as user stories","title":"Software Requirements Documents"},{"location":"cs3213/cs3213-notes/#requirements","text":"User requirements: statements of what services the system is expected to provide to system users and the constraints under which it must operate System requirements: more detailed descriptions of the software system\u2019s functions, services, and operational constraints Document (or functional specification) should define exactly what is to be implemented May be part of the contract between the system buyer and the software developers Functional: describe what the system should do Should be complete and consistent Non-functional: requirements that are not directly concerned with the specific services delivered by the system to its users Often more critical than individual functional requirements Whenever possible, they should be written quantitatively so they can be objectively tested Key activities: Elicitation and analysis: discovering requirements by interacting with the stakeholders Specification: converting the requirements into a standard form Validation: checking that the requirements actually define the system that the customer wants High level business requirements --> detailed system requirements","title":"Requirements"},{"location":"cs3213/cs3213-notes/#elicidation-and-analysis","text":"Challenges: Stakeholders often do not know what they want from a computer system except in the most general terms They may make unrealistic demands because they do not know what is and is not feasible. Political factors may influence the requirements of a system. Managers may demand specific system requirements because these will allow them to increase their influence in the organization. Economic and business environment in which the analysis takes place is dynamic. It inevitably changes during the analysis process. Process Model Process of interacting with stakeholders to discover requirements Groups related requirements and organises them into coherent clusters One way of doing so is to consider each group to be a viewpoint and collect all requirements from that group into that viewpoint Priorising requirements and resolving requirements conflicts Requirements are documented and input into the next round of the spiral Elicidation Methods: Interviewing Closed interview: stakeholder answers a predefined set of questions Open interviews: no predefined agenda. The requirements engineering team explores a range of issues with system stakeholders and hence develops a better understanding of their needs Document analysis (prior research) Workshops Focus groups Prototyping Observation (of how people work) Personas: an archetype of a user group","title":"Elicidation and Analysis"},{"location":"cs3213/cs3213-notes/#requirements-specification","text":"User Requirements Almost always written in natural language supplemented by appropriate diagrams and tables in the requirements document Should describe the functional and nonfunctional requirements so that they are understandable by system users who do not have detailed technical knowledge Should specify only the external behavior of the system Should not include details of the system architecture or design System Requirements May also be written in natural language, but other notations based on forms, graphical, or mathematical system models can also be used Expanded versions of the user requirements that software engineers use as the starting point for the system design Add detail and explain how the system meets user requirements May be used as part of the contract for the implementation of the system Should be a complete and detailed specification of the whole system Should only describe the external behavior of the system and its operational constraints Should not be concerned with how the system should be designed or implemented.","title":"Requirements Specification"},{"location":"cs3213/cs3213-notes/#natural-language","text":"Invent a standard format and ensure that all requirement definitions adhere to that format. Use text highlighting (bold, italic, or color) to pick out key parts of the requirement. Avoid the use of jargon, abbreviations, and acronyms.","title":"Natural Language"},{"location":"cs3213/cs3213-notes/#use-cases-and-user-stories","text":"User-centric view to elicit and specify requirements both common in the traditional view and for agile methods Focus on what users need to accomplish (i.e., the tasks they expect the system to do for them) Use case Describes an interaction between an actor and the system Documented as a high-level use case diagram Set of use cases represents all of the possible interactions that will be described in the system requirements User story Serve as a placeholder that will be split into smaller stories for implementation; elaborate to acceptance tests called \u201cconditions of satisfaction\u201d","title":"Use Cases and User Stories"},{"location":"cs3213/cs3213-notes/#requirements-validation","text":"Process of checking that requirements define the system that the customer really wants Feasibility study A short, focused study that should take place early in the RE process System prototyping A version of the system or part of the system is developed quickly to check the customer\u2019s requirements and the feasibility of design decisions Peer review Someone else than the author of the document reviews the requirements Informal review Collecting unstructured feedback Formal requirements review Requirements are analyzed systematically by a team of reviewers who check for errors and inconsistencies Inspection Reviewing one requirement at a time, and noting down defects Validity checks: requirements reflect the real needs of system users Consistency checks: requirements in the document should not conflict Completeness checks: requirements document should include requirements that define all functions and constraints intended Realism checks: can be implemented within proposed budget Verifiability: reduce the potential for dispute between customer and contractor","title":"Requirements Validation"},{"location":"cs3213/cs3213-notes/#basis-for-testing","text":"Requirements should be testable and used to derive test cases Test-driven development V-model and testing","title":"Basis for Testing"},{"location":"cs3213/cs3213-notes/#requirements-management-planning","text":"Concerned with establishing how a set of evolving requirements will be managed Requirements identification: Each requirement must be uniquely identified So it can be cross-referenced with other requirements and used in traceability assessments A change management process: Set of activities that assess the impact and cost of changes Traceability policies: Define the relationships between each requirement and between the requirements and the system design that should be recorded Tool support: Range from specialist requirements management systems to shared spreadsheets and simple database systems","title":"Requirements Management Planning"},{"location":"cs3213/cs3213-notes/#software-architecture","text":"How the system is organized (e.g., components and relations) How developers explain the system at a high level (i.e., the overall structure) Architectural pattern: established architectural solution that might comprise multiple architectural tactics Design pattern: typically less relevant for architecture (e.g., Factory Pattern or Facade) Architectural tactic: design decision that influences a quality attribute","title":"Software Architecture"},{"location":"cs3213/cs3213-notes/#architectural-drivers","text":"Architecturally significant requirements (ASRs): requirements that have a measurable impact on the architecture Representing as Block diagram: box as component, arrow as data/ control flow UML C4 Context diagrams (level 1): show the system in scope and its relationship with users and other systems Container diagrams (level 2): decompose a system into interrelated containers. A container represents an application or a data store Component diagrams (level 3): decompose containers into interrelated components, and relate the components to other containers or other systems Code diagrams (level 4): provide additional details about the design of the architectural elements that can be mapped to code. The C4 model relies at this level on existing notations like UML Structures Component-and-connector (C&C) structures: focuses on the way components interact with each other at run time Module structures: focuses on how to partition systems into implementation units (modules like packages, classes, layers) Decomposition structure: shows how modules are related to each other by the \u201cis-a-submodule-of\u201d relation Uses structure: focuses on a \u201cuses\u201d relation, where unit requires another unit for its correct functioning Generalization structure: focus on classes and their relationships, \u201cInherits-from\u201d or \u201cis-an-instance-of\u201d relation Allocation structures: focuses on how software maps to non-software structures, such as its organizations","title":"Architectural Drivers"},{"location":"cs3213/cs3213-notes/#advantages-of-architectural-design","text":"Quality Attributes Whether or not a system meets its quality attributes (i.e., non-functional requirements) is significantly influenced by its architecture Modifiability and Reasoning about Change Modifiability is a quality attribute, but one of the most common and important ones Three categories of changes Local change: only single component is affected (e.g., adding a new rule to a pricing module) Non-local change: multiple elements are affected (e.g., besides the rule, database and UI needs to be changed) Architectural change: affects how the elements interact and might require changes over the whole system Communication Among Stakeholders Can be used as a basis for mutual understanding, negotiating, forming consensus, and communicating with each other","title":"Advantages of Architectural Design"},{"location":"cs3213/cs3213-notes/#architectural-patterns","text":"Typically comprise multiple architectural tactics Big ball of mud An antipattern: lack of architecture Layered architecture A layer can only use the layer directly beneath it Quality attributes: Modifiability: separation allows changes to be localized Portability: allows layers to be general or specific to an OS or environment Reusability Monoliths: Layered and Modular Often used to distinguish the architecture from a distributed architecture (e.g., microservices) Typically a single deployable unit Layered: technical partitioning Modular: partitioned by domains or workflows Pipe-and-filter architecture Pipe: data as input and output Filters incrementally read their input, process it, and incrementally write it to their output Data flows through the pipes: transformed, filtered, or enriched Quality attributes: Modifiability: filters are independent from each other Reconfigurability: filters can be combined in different ways Model-centered Independent components interact with a central model (also known as repository style) rather than with each other Quality attributes: Modifiability Extensibility Model View Controller (instantiation of a model-centered architecture) Three components Model: model like in other model-centered architecture Controller: for user interaction, updates the model View: renders the presentation of the model Quality attributes: Highly modifiable: Components are independent, can be added; state can be managed and persisted since it is centralized Concurrency: Views and controllers can run in their own threads or processes Microkernel (plug-in architecture) Natural fit for many products that are installed as a single, monolithic deployment Each subsystem in the platform is itself structured as a set of plug-ins that implement some key function Quality attributes: Extensibility Maintainability Testability Client-server Clients request services from the server Quality attributes: Maintainability: organizations can change a business process or rule by changing the implementation of the server (rather than all the individual clients) Evolvability Service-oriented Focus on independent (domain) services that are separately deployed Quality attributes: Deployability: services can be individually managed Testability: services can be individually tested Reliability: if one service goes down, others might be able to continue Microservice Primary goal is decoupling: microservices are expected to be independent Each microservice models a domain or workflow Quality attributes: Quick time to market and Deployability Independence: each team can make its own technology choices Scalability: service instances can be dynamically added","title":"Architectural Patterns"},{"location":"cs3213/cs3213-notes/#quality-attributes","text":"Source Specifies where the fault comes from Internal/ external: people, hardware, software Stimulus Cause of fault Omission, crash, incorrect timing Artifact Which portions of the system are responsible for and affected by the fault Processors, communication channels, storage Environment Running environment and environment that is recovering from a fault Normal operation, startup, shutdown, overloaded operation, repair mode Response Most commonly desired response is to prevent the fault from becoming a failure Response Measure Focus on a number of measures of availability, depending on the criticality of the service being provided Time to detect the fault, time to repair the fault","title":"Quality Attributes"},{"location":"cs3213/cs3213-notes/#availability-tactics","text":"Detect faults Monitor: monitor various components of the system Heartbeat: periodic message exchange between a system monitor and a process being monitored Sanity checking: checks the validity of specific operations or their output based on the knowledge of their internal structure Recover (Preparation and repair) Redundant spare : one or more duplicate components can step in if a component fails Rollback : revert to a previous, known good state Software upgrade : in-service upgrade in a non-service-affecting manner Recover (Reintroduction) Shadow : operate a component in a \"shadow mode\" while being mentored before revering it back to an active mode Escalating restart : automatic restart at different granularities (clear caches/ restart the whole system) Prevent faults Removal from service Transactions : Provide atomic, consistent, isolated and durable properties Increase competence set : set of states in which the program can \"competently\" operate","title":"Availability Tactics"},{"location":"cs3213/cs3213-notes/#system-modeling","text":"Goal: develop abstract models of a system Perspectives: External perspective: context or environment of the system Interaction perspective: interactions between a system and its environment, or between the components of a system Structural perspective: model the organization of a system or the structure of the data that is processed by the system Behavioral perspective: model the dynamic behavior of the system and how it responds to events","title":"System Modeling"},{"location":"cs3213/cs3213-notes/#modeling-languages","text":"UML , C4, Business Process Model and Notation (BPMN), Systems modeling language (SysML)","title":"Modeling Languages"},{"location":"cs3213/cs3213-notes/#uml","text":"Sequence diagrams focus on objects in a system, whereas activity diagrams focus on operations or activities State machine diagram Show how the system reacts to internal and external events Example of a behavioral model (like activity diagrams) Focus on system states and events that cause transitions from one state to another Use case diagram Shows interactions between actors and system Class diagrams: show the object classes in the system and the associations between these classes Sequence diagrams: show interactions between actors and the system and between system components Activity diagrams: show the activities involved in a process or in data processing","title":"UML"},{"location":"cs3213/cs3213-notes/#c4","text":"Developed for modeling for software architectures Hierarchical diagrams and abstractions System context: a System Context diagram provides a starting point, showing how the software system in scope fits into the world around it Containers: a Container diagram zooms into the software system in scope, showing the high-level technical building blocks Components: a Component diagram zooms into an individual container, showing the components inside it Code: A code (e.g. UML class) diagram can be used to zoom into an individual component, showing how that component is implemented","title":"C4"},{"location":"cs3213/cs3213-notes/#business-process-model-and-notation-bpmn","text":"For business processes, similar to UML activity diagrams Related standard: Decision Model and Notation (DMN) Means deriving a result (output) from given facts (input) on the basis of defined logic (decision logic) Most popular way to model decisions: a decision table","title":"Business Process Model and Notation (BPMN)"},{"location":"cs3213/cs3213-notes/#agile-software-development","text":"","title":"Agile Software Development"},{"location":"cs3213/cs3213-notes/#agile-manifesto","text":"Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan Satisfy the customer through early and continuous delivery of valuable software Welcome changing requirements, even late in development Delivery working software frequently","title":"Agile Manifesto"},{"location":"cs3213/cs3213-notes/#agile-reasons","text":"Organisations' SE priorities: End-customer satisfaction Time to delivery Competitive advantage Used for ongoing release cycles, featuring small incremental changes","title":"Agile Reasons"},{"location":"cs3213/cs3213-notes/#scrum","text":"General, lightweight framework Does not specify how to do requirements engineering, architecture, etc Prescriptive: proposes specific rules that need to be followed Often seen as a synonym to agile practices Focus: delivering value Achieves this via increments in sprints Founded on empiricism and lean thinking Empiricism: knowledge comes from experience and decision making based on observations Lean thinking: reduce waste and focus on the essentials Scrum pillars Transparency: process and work is visible for those doing the work and receiving its output Inspection: artifact and process is inspected frequently to detect problems Adaption: adjustments if the resulting product is unacceptable Sprints Goal: create a useful increment Includes planning, daily scrums, sprint review, sprint retrospective and product backlog Artifacts: product backlog (ordered list of what is needed to improve the product), sprint backlog (sprint goal, product backlog items selected for sprint, an actionable plan for delivering the increment), increment (concrete stepping point towards product goal) User stories: describe some functionality and represent customer requirements Card: a written description of the story used for planinng Conversation: verbal exchange with the customer to flesh out the details of the story Confirmation: acceptance tests specified by the customer can be used to determine when a story is complete","title":"Scrum"},{"location":"cs3213/cs3213-notes/#kanban","text":"Optimizes flow using a visual, pull-based system Definition of Workflow (DoW): explicit shared understanding of flow, which requires a definition of various concepts A definition of how WIP will be controlled from started to finished A service level expectation (SLE), which is a forecast of how long it should take a work item to flow from started to finished","title":"Kanban"},{"location":"cs3213/cs3213-notes/#extreme-programming","text":"Extreme Programming (XP) takes an \u201cextreme\u201d approach to iterative development and best practices New versions may be built several times per day Increments are delivered to customers every 2 weeks All tests must be run for every build and the build is only accepted if tests run successfully Pair programming All code is produced by two developers working together One developer is programming, while the other is reviewing and focusing on the big picture Test-driven development XP proposed test-driven development Unit tests are written before the code is written Acceptance tests are derived from the user requirements Continuous integration Development team should always work on the latest version of the software Code should be integrated into the main branch of the project frequently On-site customer: A representative of the end-user of the system (the customer) should be available full time for the use of the XP team. In an extreme programming process, the customer is a member of the development team and is responsible for bringing system requirements to the team for implementation. Sustainable pace: Large amounts of overtime are not considered acceptable as the net effect is often to reduce code quality and medium term productivity","title":"Extreme Programming"},{"location":"cs3213/cs3213-notes/#quality-assurance-software-testing","text":"Defect testing : \u201cprogram testing can be used very effectively to show the presence of bugs but never to show their absence\u201d - Dijkstra Validation testing : demonstrate that the system corresponds to the requirements Verification: \"are we building the product right\" Programming errors Validation: \"are we building the right product\" Whether this is what user requires Test Case Test Oracle : is a mechanism for determining whether a test has passed or failed (e.g. assertEquals ) Test input Automated testing: testing tool automatically generates a test input and applies a test oracle Manual test: manually testing for defects Pesticide paradox: Every method you use to prevent or find bugs leaves a residue of subtler bugs against which those methods are ineffectual Not all bugs can be identified from one method of testing","title":"Quality Assurance: Software Testing"},{"location":"cs3213/cs3213-notes/#testing-levels","text":"Unit test: testing individual components Typically fast, and allow testing of large portions of a system in limited time Easy to control, as they typically check expected result values when passed a certain input value Easy to write, as they require no additional set up Lack reality, as they do not represent the real execution of a system Integration test: testing multiple components in combination Typically focuses on \"our\" component and an external component (database system or web services) System test (end-to-end test): evaluating the whole system Run the system in its entirety instead of testing small parts in isolation Realistic tests but are often slow and harder to write","title":"Testing Levels"},{"location":"cs3213/cs3213-notes/#test-flakiness","text":"Flaky test: a test that might non-deterministically pass or fail Lowers confidence in the tests, difficult to debug, might lower overall developer productivity Causes: Concurrency, when task is shared by multiple threads Async wait: whether the test case succeeds depends on how quickly server responds Test pyramid: write tests with different granularity (fewer high-level tests, many small and fast unit tests)","title":"Test Flakiness"},{"location":"cs3213/cs3213-notes/#testing-and-processes","text":"Waterfall model V-model Testing happens after requirements engineering, architecture, design phases Testing is planned together with other phases Acceptance testing User Acceptance Testing (UAT): focuses on validation, that is, checking whether the system meets the users\u2019 requirements Test driven development (TDD) Focus on requirements and quick feedback Used when faced with complex problem or solution not yet clear Classicist/ detroit school: inside-out TDD, start with different units that will compose the overall feature London school: outside-in TDD, start from the outside and use of mocking Steps Write test Check that the newly-written test fails Write the simplest code that passes the new test All tests should now pass Refactor as needed Black-box: no internal information Specification-based testing, derives tests based on the requirements or documentation White-box: internal information (based on a function's implementation) Use the source code to guide testing, known as structural testing Main means through coverage criteria Line: lines_covered / total lines x 100% Branch (each branching instruction): branches_covered / total branches x 100% Condition (multiple conditions like && || in one line) + branch: (branches_covered + conditions_covered) / (total_branches + total_conditions) x 100% Path: paths_covered / total_paths x 100% Modified condition/ decision coverage: number_of_conditions_evaluated_to_all_possible_outcomes_affecting_the_outcome_of_the_decision / total_number_of_conditions_within_the_decisions x 100% Test important combinations of conditions and thus reduce the cost as compared to full Path Coverage Each condition in a decision is shown to independently affect the outcome of the decision Exploratory testing Explore what the program does to increase your understanding and build a mental model Devising test cases: boundary value analysis, identifying partitions Mutation testing Evaluate the quality of exisiting tests and derive new tests Mutate code in the program (introduce a bug), assuming that a test case \"kills\" the mutant Effective way of discovering undertested parts","title":"Testing and Processes"},{"location":"cs3213/cs3213-notes/#automated-testing-approaches","text":"Automated testing tackles test input generation and/or test oracle problem Property-based testing Specify properties for the component we can test and let the test framework find a test input that might cause the property to break Property-based testing framework: jqwik for Java Useful for complex functionality and if there is uncertainty whether example-based tests are sufficient Differential testing Send a common input to multiple systems and see whether their result or other properties agree Compare between: Different versions of a software Different configurations Against a simple reference engine Different implementations of the same functionality Potentially small overlap in functionality and intended differences makes this technique produce false alarms that need to be analyzed Metamorphic testing Use a source test-case (and its result) to generate a follow-up test case for which the result can be inferred Black-box approach Equivalence Modulo Inputs (EMI) is one of the most successful metamorphic testing approaches Rather than creating equivalent programs, create programs that are equivalent only for a given input, which is easier Constraint Solvers Constraint solvers accept a formula and check if it is satisfiable (SAT) or unsatisfiable (UNSAT) Boolean Satisfiability (SAT Solvers) Input: propositional formula Output: model that satisfies the formula Satisfiability Modulo Theories (SMT Solvers) Solve a formula based on a given theory Symbolic Execution Testing involves executing the program on one, concrete input Uses an SMT solver to determine whether a patch condition is feasible or not Systematically generate inputs (but there might be path explosion) Fuzzing Black-box fuzzing: send random input to the program and hope it crashes Mutation-based fuzzing: Rather than passing random input to the program, mutate existing inputs White-box fuzzing: Leverages detailed knowledge of the program for fuzzing Grey-box fuzzing: For each mutated input, check whether it resulted in a gain of code coverage (or code coverage pattern) Test-case Reduction: many automated input generation techniques generate large inputs Remove redundant test cases that do not trigger the bug Delta debugging*: systematically removes elements from the bug-inducing input; Behaves like binary search but tries different combinations of smaller blocks where binary search fails Small scope hypothesis: A high proportion of errors can be found by testing a program for all test inputs within some small scope Static analysis tools are tools that reason about code without executing it Linters and style checkers Data-flow analysis Control-flow analysis Completeness: If analysis says X is true, it is really true Soundness: If X is true, the analysis will indicate that X is true *Delta Debugging (with granularity n = 2) Try to reduce to subset (use only either input 1 or input 2) Try to reduce to complement (swap input 1 and 2) If both result in no bug, increase granularity to n = 4 (have input 1, 2, 3, 4) If input that fails the test is found, reduce granularity to n = 3 If still fails, reduce granularity again If passes, increase granularity (find the local minimum)","title":"Automated Testing Approaches"},{"location":"cs3213/cs3213-notes/#software-evolution","text":"Versioning Software versioning is the process of assigning either unique version names or unique version numbers to unique states of computer software Commit hash: automatically generated, but near random and may include irrelevant versions in-between Calendar versioning (YY.MM.DD.HH.mm) Semantic versioning (major version. minor version. patch version) Bug finding Infrastructure software such as databases, compilers are depended on to build stable software Fuzz testing: tries to break infrastructure software by randomizing input Feature triage Requirements elicitation changes after release Determine the usage and performance of software via analytics and telemetry Deprecation Don't deprecate Backwards compatibility is a feature Early mistakes cannot be easily reversed Translation interface Adapt the old interface to call the new one, migration is blind to user Need to maintain old promises Hyrum's law: With a sufficient number of users of an API, it does not matter what you promise in the contract; all observable behaviors of your system will be depended on by somebody. With enough users, any change to a piece of software will break somebody's workflow Migration tooling Create a tool for stakeholders to automatically upgrade to the next version Tool needs to be created and tested End-of-support period Guarantee some support of old versions to give stakeholders time to migrate Someone needs to maintain the old version Advisory Deprecation Deprecations that have no deadline and are not a high priority for the organization Compulsory Deprecation Deprecations that have a deadline, after which the deprecated interface is no longer guaranteed to work","title":"Software Evolution"},{"location":"dsa-notes/dsa-notes/","text":"Data Structures and Algorithm Data Structures and Algorithm Recurrence Relations Binary Search Peak Finding Sorting BubbleSort SelectionSort InsertionSort MergeSort QuickSort Partition QuickSelect Trees Binary Search Trees Height Search Insert Traversals Inorder Traversal Preorder Traversal Postorder Traversal Delete Balanced Trees AVL Insert Delete Tries Dynamic Order Statistics Interval Trees Insert Interval Search 1D Range Trees Query 2D Range Trees Priority Queue Binary (Max) Heaps Insert DecreaseKey Delete Heap vs AVL Tree HeapSort Disjoint Set Quick Find: using an int[] componentId Quick Union: using an int[] parent Weighted Union Weighted Union with Path Compression Hashing Direct Access Table Chaining Open Addressing Resizing Table Graph Breadth-First Search Depth-First Search Shortest Path Bellman-Ford Dijkstra's Algorithm Minimum Spanning Trees Prim's Algorithm Kruskal's Algorithm Dynamic Programming Topological Sort Recurrence Relations T(n) = T(n-1) + O(1) = O(n) T(n) = T(n/2) + O(1) = O(logn) T(n) = T(n-1) + O(n) = O(n^2) T(n) = T(n-1) + O(nk) = O(n^(k+1)) T(n) = 2T(n/2) + O(n) = O(nlogn) T(n) = T(n/2) + O(n) = O(n) T(n) = 2T(n/2) + O(1) = O(n) T(n) = 2T(n-1) + O(1) = O(2^n) Binary Search Time complexity: O(logn) Preconditions: Array is of size n Array is sorted Postconditions: If element is in array: A[left] = key Loop invariant: A[left] <= key <= A[right] (right - left) <= n/2^k in iteration k public int search(int A[], int key, int n) { int left = 0; int right = n - 1; while (left < right) { // int mid = (left + right) / 2 can lead to integer overflow int mid = left + (right - left) / 2; if (key <= A[mid]) { right = mid; } else { left = mid + 1; } } return (A[left] == key ? left : -1); } Peak Finding Output a local maximum in A, where A[i - 1] <= A[i] and A[i + 1] <= A[i] Time complexity: O(logn) Invariant: If we recuse in the right half, then there exists a peak in the right half There exists a peak in the range [begin, end] Every peak in [begin, end] is a peak in [1, n] T(n) = T(n/2) + \u03b8(1) = O(logn) public int findPeak(int A[], int n) { // if right of mid is larger, recurse on right if (A[n / 2 + 1] > A[n / 2]) { return findPeak(Arrays.copyOfRange(A, n / 2 + 1, n + 1), n / 2) // if left of mid is larger, recurse on left } else if (A[n / 2 - 1] > A[n / 2]) { return findPeak(Arrays.copyOfRange(A, 0, n / 2), n / 2) } else { return n / 2; } } Sorting BubbleSort Invariant: At the end of iteration i, the biggest j items are correctly sorted in the final j positions of the array. Best: O(n), when array is already sorted Worst: O(n^2) , when array is reverse sorted Stable Description: For n loops, if A[j] > A[j + 1], swap(A[j], A[j + 1]) void bubbleSort(int arr[], int n) { int i, j, temp; boolean swapped; for (i = 0; i < n - 1; i++) { swapped = false; for (j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { // Swap arr[j] and arr[j+1] temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; swapped = true; } } // If no two elements were // swapped by inner loop, then break if (swapped == false) break; } } SelectionSort Invariant: At the end of iteration j: the smallest j items are correctly sorted in the first j positions of the array. Best: O(n^2) Worst: O(n^2) Not stable Description: For n loops, find minimum element A[j] in A[j..n], swap(A[j], A[k]) void selectionSort(int arr[], int n) { int min_idx = 0; // One by one move boundary of unsorted subarray for (int i = 0; i < n - 1; i++) { // Find the minimum element in unsorted array min_idx = i; for (int j = i + 1; j < n; j++) { if (arr[j] < arr[min_idx]) min_idx = j; } // Swap the found minimum element with the first element if (min_idx != i) swap(arr[min_idx], arr[i]); } } InsertionSort Invariant: At the end of iteration j: the first j items in the array are in sorted order. Best: O(n), when array is already sorted Worst: O(n^2) , when array is reverse sorted Stable Description: For n loops, insert key into the sorted array A[1 .. j - 1] void insertionSort(int arr[]) { int n = arr.length; for (int i = 1; i < n; ++i) { int key = arr[i]; int j = i - 1; /* Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position */ while (j >= 0 && arr[j] > key) { arr[j + 1] = arr[j]; j = j - 1; } arr[j + 1] = key; } } MergeSort Best: O(n logn) Worst: O(n logn) Stable Memory: O(n logn) Description: Divide: split array into two halves Recurse: sort the two halves Combine: merge the two sorted halves Use InsertionSort instead for n < 1024 void merge(int arr[], int l, int m, int r) { // Find sizes of two subarrays to be merged int n1 = m - l + 1; int n2 = r - m; // Create temp arrays int L[] = new int[n1]; int R[] = new int[n2]; // Copy data to temp arrays for (int i = 0; i < n1; ++i) L[i] = arr[l + i]; for (int j = 0; j < n2; ++j) R[j] = arr[m + 1 + j]; // Merge the temp arrays // Initial indices of first and second subarrays int i = 0, j = 0; // Initial index of merged subarray array int k = l; while (i < n1 && j < n2) { if (L[i] <= R[j]) { arr[k] = L[i]; i++; } else { arr[k] = R[j]; j++; } k++; } // Copy remaining elements of L[] if any while (i < n1) { arr[k] = L[i]; i++; k++; } // Copy remaining elements of R[] if any while (j < n2) { arr[k] = R[j]; j++; k++; } } void mergeSort(int arr[], int l, int r) { if (l < r) { // Find the middle point int m = l + (r - l) / 2; // Sort first and second halves mergeSort(arr, l, m); mergeSort(arr, m + 1, r); // Merge the sorted halves merge(arr, l, m, r); } } QuickSort Invariant: At the end of every loop iteration, For every i < low: B[i] < pivot For every j > high: B[j] > pivot Best: O(n logn) , when median element is chosen as pivot Worst: O(n^2) , when first element is chosen as pivot/ all elements are the same Not stable Description: Divide: Partition the array into two sub-arrays around a pivot x such that elements in lower subarray \u2264 x \u2264 elements in upper sub-array. Conquer: Recursively sort the two sub-arrays. Combine: Trivial, do nothing. void quickSort(int[] arr, int low, int high) { if (low < high) { // pi is partitioning index, arr[pi] // is now at right place int pi = partition(arr, low, high); // Separately sort elements before // partition and after partition quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } } Partition Invariant: A[high] > pivot at the end of each loop At the end of every loop iteration For all i >= high, A[i] > pivot For all 1 < j < low, A[j] < pivot Time complexity: O(n) int partition(int[] arr, int low, int high) { // Choosing the pivot int pivot = arr[high]; // Index of smaller element and indicates // the right position of pivot found so far int i = (low - 1); for (int j = low; j <= high - 1; j++) { // If current element is smaller than the pivot if (arr[j] < pivot) { // Increment index of smaller element i++; swap(arr, i, j); } } swap(arr, i + 1, high); return (i + 1); } QuickSelect Invariant: After partioning, arr[partition] is now at right place Time complexity: O(n) Description: Find the k-th smallest element in an unordered list partition the array if partition is at position k, the partition is the k-th smallest element else continue searching in the correct half // ASSUMPTION: all elements in arr[] are distinct int kthSmallest(int[] arr, int low, int high, int k) { // find the partition int partition = partition(arr, low, high); // if partition value is equal to the kth position, return value at k if (partition == k - 1) { return arr[partition]; } // if partition value is less than kth position, search right side of the array else if (partition < k - 1) { return kthSmallest(arr, partition + 1, high, k); } // if partition value is more than kth position, search left side of the array else { return kthSmallest(arr, low, partition - 1, k); } } Trees Binary Search Trees All in left sub-tree < key < all in right sub-tree Height Number of edges on longest path from root to leaf h(v) = 0 (if v is a leaf) h(v) = max(h(v.left), h(v.right)) + 1 Time complexity: O(logn) int height() { int leftHeight = -1; int rightHeight = -1; if (leftTree != null) { leftHeight = leftTree.height(); } if (rightTree != null) { rightHeight = rightTree.height(); } return max(leftHeight, rightHeight) + 1; } Search Worst case: O(n) , (when n = h) Time complexity: O(h) searchMax() TreeNode searchMax() { if (rightTree != null) { return rightTree.searchMax(); } else { return this; } } searchMin() TreeNode searchMin() { if (leftTree != null) { return leftTree.searchMin(); } else { return this; } } search(int queryKey) public TreeNode search(int queryKey){ if (queryKey < key) { if (leftTree != null) { return leftTree.search(key); } else { return null; } } else if (queryKey > key) { if (rightTree != null) { return rightTree.search(key); } else { return null; } } else { return this; // Key is here! } } Insert void insert(int insKey, int intValue) { if (insKey < key) { if (leftTree != null) { leftTree.insert(insKey); } else { leftTree = new TreeNode(insKey,insValue) } } else if (insKey > key) { if (rightTree != null) { rightTree.insert(insKey); } else { rightTree = new TreeNode(insKey, insValue); } } else { return; // Key is already in the tree! } } Traversals Inorder Traversal Left, self, right Running time: O(n) void inOrder(Node node) { if (node == null) return; // First recur on left child inOrder(node.left); // Then print the data of node System.out.print(node.key + \" \"); // Now recur on right child inOrder(node.right); } Preorder Traversal Self, left, right Running time: O(n) void preOrder(Node node) { if (node == null) return; // Print the data of node System.out.print(node.key + \" \"); // Then recur on left child preOrder(node.left); // Now recur on right child preOrder(node.right); } Postorder Traversal Left, right, self Running time: O(n) void postOrder(Node node) { if (node == null) return; // First recur on left child postOrder(node.left); // Then recur on right child postOrder(node.right); // Now print the data of node System.out.print(node.key + \" \"); } Delete Successor Running time: O(h) Idea: Search for key in the tree. If (result > key), then return result. If (result <= key), then search for successor of result. Case 1: node has a right child Case 2: node has no right child public TreeNode successor() { if (rightTree != null) { return rightTree.searchMin(); } TreeNode parent = parentTree; TreeNode child = this; while ((parent != null) && (child == parent.rightTree)) { child = parent; parent = child.parentTree; } return parent; } Delete Running time: O(h) Case 1: no children Remove v Case 2: 1 child Remove v Connect child(v) to parent(v) Case 3: 2 children x = successor(v) Delete(x) Remove v Connect x to left(v), right(v), parent(v) Balanced Trees BST is balanced if h = O(logn) All operations run in O(logn) time Maxmimum height: h < 2logn Mininimum nodes: n > 2^(h/2) In every node v, store height (augment) On insert and delete, update height: height = max(left.height, right.height) + 1 Define Invariant A node v is height-balanced if |v.left.height - v.right.height| <= 1 A BST is height-balanced if every node is height-balanced Maintain balance // assume v has left != null void rightRotate(TreeNode v) { TreeNode w = v.left; w.parent = v.parent; v.parent = w; v.left = w.right; w.right = v; } // assume v has right != null void leftRotate(TreeNode v) { TreeNode w = v.right; w.parent = v.parent; v.parent = w; v.right = w.left; w.left = v; } If v is out of balanced and left-heavy: Case 1: v.left is balanced -> rightRotate(v) Case 2: v.left is left-heavy -> rightRotate(v) Case 3: v.left is right-heavy -> leftRotate(v.left), rightRotate(v) If v is out of balanced and right-heavy: Case 1: v.right is balanced -> leftRotate(v) Case 2: v.right is left-heavy -> leftRotate(v) Case 3: v.right is right-heavy -> rightRotate(v.right), leftRotate(v) import java.util.TreeSet; TreeSet<IntegerNode> leftHalf; TreeSet<IntegerNode> rightHalf; void rebalance() { int leftSize = this.leftHalf.size(); int rightSize = this.rightHalf.size(); int diff = Math.abs(leftSize - rightSize); if (diff > 1) { if (leftSize > rightSize) { // Left is bigger, move the biggest item to right this.rightHalf.add(this.leftHalf.pollLast()); } else { // Right is bigger, move the smallest item to left this.leftHalf.add(this.rightHalf.pollFirst()); } } } AVL Insert Summary: Insert key in BST Walk up tree: At every step, check for balance If out-of-balance, use rotations to rebalance and return Key observation: Only need to fix lowest out-of-balance node Only need at most two rotations to fix Delete If v has two children, swap it with its successor Delete node v from binary tree (and reconnect children) For every ancestor of the deleted node: Check if it is height-balanced If not, perform a rotation Continue to the root Summary: Delete key from BST Walk up tree: At every step, check for balance If out-of-balance, use rotations to rebalance continue to root Key observation: Needs at most O(logn) rotations import java.util.*; import java.io.*; class Node { int key, height; Node left, right; Node (int d) { key = d; height = 1; } } class AVLTree { Node root; int height (Node N) { if (N == null) return 0; return N.height; } int max (int a, int b) { return (a > b) ? a : b; } Node rightRotate (Node y) { Node x = y.left; Node T2 = x.right; x.right = y; y.left = T2; y.height = max (height (y.left), height (y.right)) + 1; x.height = max (height (x.left), height (x.right)) + 1; return x; } Node leftRotate (Node x) { Node y = x.right; Node T2 = y.left; y.left = x; x.right = T2; x.height = max (height (x.left), height (x.right)) + 1; y.height = max (height (y.left), height (y.right)) + 1; return y; } int getBalance (Node N) { if (N == null) return 0; return height (N.left) - height (N.right); } Node insert (Node node, int key) { if (node == null) return (new Node (key)); if (key < node.key) node.left = insert (node.left, key); else if (key > node.key) node.right = insert (node.right, key); else return node; node.height = 1 + max (height (node.left), height (node.right)); int balance = getBalance (node); if (balance > 1 && key < node.left.key) return rightRotate (node); if (balance < -1 && key > node.right.key) return leftRotate (node); if (balance > 1 && key > node.left.key) { node.left = leftRotate (node.left); return rightRotate (node); } if (balance < -1 && key < node.right.key) { node.right = rightRotate (node.right); return leftRotate (node); } return node; } } Tries Cost of comparing two strings in a tree: O(hL) Cost in trie: O(L) Space for storing a try: O(size of text * overhead) Dynamic Order Statistics Select(k) : finds the node with rank k // augmented tree with weight // O(logn) Node select(k) { rank = m_left.weight + 1; if (k == rank) { return v; } else if (k < rank) { return m_left.select(k); } else if (k > rank) { return m_right.select(k\u2013rank); } } // in-order traversal method // O(n) Node kthSmallest(int k) { Result result = new Result(0, null); inOrderTraversal(root, k, result); return result.result; } void inOrderTraversal(Node node, int k, Result result) { if (node == null || result.count >= k) { return; } inOrderTraversal(node.left, k, result); result.count++; if (result.count == k) { result.result = node; return; } inOrderTraversal(node.right, k, result); } class Result { int count; Node result; Result(int count, Node result) { this.count = count; this.result = result; } } Rank(v) : computes the rank of a node v // augmented tree with weight // O(logn) int rank(TreeNode node) { rank = node.left.weight + 1; while (node != null) { if (node.parent.left == node) { continue; } else { rank += node.parent.left.weight + 1; } node = node.parent; } return rank; } // recursion method // worst case: O(n) int rank(TreeNode node, int x) { if (node == null) { return 0; } if (node.value <= x) { return 1 + rank(node.left, x) + rank(node.right,x); } else { return rank(node.left, x) } } Interval Trees Augment tree with maximum endpoint in subtree class Node { int[] interval; int maxEnd; Node left, right; int height; Node(int[] interval) { this.interval = interval; this.maxEnd = interval[1]; this.left = this.right = null; this.height = 1; } } Insert class IntervalTree { private int height(Node node) { return (node == null) ? 0 : node.height; } private int maxEnd(Node node) { return (node == null) ? Integer.MIN_VALUE : node.maxEnd; } private int getBalance(Node node) { return (node == null) ? 0 : height(node.left) - height(node.right); } private Node insert(Node root, int[] interval) { if (root == null) { return new Node(interval); } if (interval[0] < root.interval[0]) { root.left = insert(root.left, interval); } else { root.right = insert(root.right, interval); } root.height = Math.max(height(root.left), height(root.right)) + 1; root.maxEnd = Math.max(root.interval[1], Math.max(maxEnd(root.left), maxEnd(root.right))); int balance = getBalance(root); // Left Heavy if (balance > 1) { if (interval[0] < root.left.interval[0]) { return rotateRight(root); } else { root.left = rotateLeft(root.left); return rotateRight(root); } } // Right Heavy if (balance < -1) { if (interval[0] > root.right.interval[0]) { return rotateLeft(root); } else { root.right = rotateRight(root.right); return rotateLeft(root); } } return root; } } Interval Search Find interval containing x Running time: O(logn) boolean isInInterval(Node c, int x) { return x >= c.interval[0] && x <= c.interval[1]; } int[] intervalSearch(int x) { Node c = root; while (c != null && !isInInterval(c, x)) { if (c.left == null) { c = c.right; } else if (x > c.left.maxEnd) { c = c.right; } else { c = c.left; } } return c.interval; } All-Overlaps: List all intervals that overlap with point Running time if there are k overlapping intervals: O(k logn) Repeat until no more intervals: Search for interval. Add to list. Delete interval. Repeat for all intervals on list: Add interval back to tree. 1D Range Trees Strategy: Use a binary search tree. Store all points in the leaves of the tree. (Internal nodes store only copies.) Each internal node v stores the MAX of any leaf in the left sub-tree. Query Invariant: The search interval for a left-traversal at node v includes the maximum item in the subtree rooted at v. Algorithm: Find split node, takes O(logn) Do left traversal Do right traversal Query time complexity: O(k + logn), where k is number of points found Preprocessing (buildtree) time complexity: O(n logn) Total space complexity: O(n) Node FindSplit(int low, int high) { Node v = root; done = false; while (!done) { if (high <= v.key) { v = v.left; } else if (low > v.key) { v = v.right; } else { done = true } } return v; } // LeftTraversal either: // 1. Output all right sub-tree and recurse left. // 2. Recurse right. void LeftTraversal(Node v, int low, int high) { boolean isInRange = low <= v.key; boolean isLeafNode = v.left == null && v.right == null; if (isLeafNode && isInRange) { System.out.println(v.key); } if (isInRange) { // if in range, take the all of right subtree's leafs AllLeafTraversal(v.right); LeftTraversal(v.left, low, high); } else { LeftTraversal(v.right, low, high); } } void RightTraversal(Node v, int low, int high) { boolean isInRange = v.key <= high; boolean isLeafNode = v.left == null && v.right == null; if (isLeafNode && isInRange) { System.out.println(v.key); } if (isInRange) { // if in range, take the all of left subtree's leafs AllLeafTraversal(v.left); RightTraversal(v.right, low, high); } else { RightTraversal(v.left, low, high); } } void AllLeafTraversal(Node v) { if (v == null) { return; } // only leaf nodes are printed if (v.left == null && v.right == null) { System.out.println(v.key); } AllLeafTraversal(v.left); AllLeafTraversal(v.right); } void Query(low, high) { Node v = FindSplit(low, high); LeftTraversal(v.left, low, high); RightTraversal(v.right, low, high); } 2D Range Trees Build an x-tree using only x-coordinates. For every node in the x-tree, build a y-tree out of nodes in subtree using only y-coordinates. Query time: O((logn)^2 + k) O(logn) to find split node O(logn) recursing steps O(logn) y-tree-searches of cost O(logn) O(k) enumerating output Space complexity: O(n logn) Each point appears in at most one y-tree per level There are O(log n) levels Query cost: O((logn)^d + k) buildTree cost: O(n (logn)^d-1) Space: O(n (logn)^d-1) Priority Queue Return Type Operation Description void insert(Key k, Priority p) insert k with priority p Data extractMin() remove key with min. priority void decreaseKey(Key k, Priority p) reduce the priority of key k to priority p boolean contains(Key k) whether queue contains key k boolean isEmpty() whether queue is empty Sorted array Insert: O(n) extractMax: O(1) Unsorted array insert: O(1) extractMax: O(n) AVL tree (indexed by priority) insert: O(logn) extractMax: O(logn) AVL tree and dictionary contains: O(1) decreaseKey: O(logn) Binary (Max) Heaps Heap ordering: priority[parent] >= priority[child] Complete binary tree Every level is full, except possibly the last All nodes are as far left as possible Height: O(logn) (maximum height is floor(logn)) Operations: O(logn) Implements a max priority queue Return Type Operation Description void insert(Key k, Priority p) insert k with priority p Data extractMax() remove key with max priority void increaseKey(Key k, Priority p) increase the priority of key k to priority p void decreaseKey(Key k, Priority p) reduce the priority of key k to priority p Data delete(Key k) delete k from heap left(x) = 2 * x + 1 right(x) = 2 * x + 2 parent(x) = floor((x - 1) / 2) Where x is the position of the node in the array Insert Add leaf of new node at leftmost position Bubble up (swap with parent) until condition priority[parent] >= priority[child] fulfilled bubbleUp(Node v) { while (v != null) { if (priority(v) > priority(parent(v))) { swap(v, parent(v)); } else { return; } v = parent(v); } } insert(Priority p, Key k) { Node v = tree.insert(p, k); bubbleUp(v); } DecreaseKey Update priority Bubble down (swap with child that has higher priority) bubbleDown(Node v) { while (!isLeaf(v)) { leftP = priority(left(v)); rightP = priority(right(v)); maxP = max(leftP, rightP, priority(v)); if (leftP == max) { swap(v, left(v)); v = left(v); } else if (rightP == max) { swap(v, right(v)); v = right(v); } else { return; } } } Delete Swap deleted node with last node (which is last element in array) Remove last node Bubble down swapped node ExtractMax: delete(root); Heap vs AVL Tree Same asymptotic cost for operations Faster real cost (no constant factors) Simpler: no rotations Slightly better concurrency HeapSort Running time: O(n logn) In-place Deterministic, and will always take O(n logn) Faster than MergeSort, a little slower than QuickSort Not stable Unsorted list --> heap (running time: O(n)), specifically 2 * O(n) Base case: each leaf is a heap Recursion: siblings + parent nodes = heap (bubbleDown) // int[] A = array of unsorted integers for (int i = n - 1; i >= 0; i--) { bubbleDown(i, A); // O(height), but more than n/2 of nodes are leaves with height = 0 } Heap --> sorted list () (running time: O(n logn)) Fill array from last position to first position, by recursively calling extractMax() //int[] A = array stored as a heap for (int i = n - 1; i >= 0; i--) { int value = extractMax(A); //O(logn) A[i] = value; } Disjoint Set Determine if objects are connected Quick Find: using an int[] componentId Store component identifier of each object Find: O(1) Finds whether p and q are connected boolean find(int p, int q) { return(componentId[p] == componentId[q]); } Union: O(n) Make p and q have the same componentId Traverse the component identifier array: if id = q's id, update to be p's id void union(int p, int q) { updateComponent = componentId[q]; for (int i=0; i<componentId.length; i++) { if (componentId[i] == updateComponent) { componentId[i] = componentId[p]; } } } Quick Union: using an int[] parent Two objects are connected if they are part of the same tree Find: O(n) Traverse up the tree from given node, to find parent If final parents are the same, they are connected boolean find(int p, int q) { while (parent[p] != p) { p = parent[p]; } while (parent[q] != q) { q = parent[q]; } return (p == q); } Union: O(n), height of tree can be n Traverse up the tree from given node, to find parent Set parent of p to be q void union(int p, int q) { while (parent[p] != p) { p = parent[p]; } while (parent[q] != q) { q = parent[q]; } parent[p] = q; } Weighted Union Choose the larger element to be the parent during union Maximum depth of tree: O(logn) Running time of find : O(logn) Running time of union : O(logn) union(int p, int q) { while (parent[p] !=p) { p = parent[p]; } while (parent[q] !=q) { q = parent[q]; } if (size[p] > size[q]) { parent[q] = p; // Link q to p size[p] = size[p] + size[q]; } else { parent[p] = q; // Link p to q size[q] = size[p] + size[q]; } } Weighted Union with Path Compression After finding root, set the parent of each traversed node to the root Tree height is compressed // Takes O(logn) time findRoot(int p) { root = p; while (parent[root] != root) { root = parent[root]; } while (parent[p] != p) { temp = parent[p]; parent[p] = root; p = temp; } return root; } union(int p, int q) { p = findRoot(p); q = findRoot(q); if (size[p] > size[q]) { parent[q] = p; // Link q to p size[p] = size[p] + size[q]; } else { parent[p] = q; // Link p to q size[q] = size[p] + size[q]; } } Starting from empty, any sequence of m union/find operations on n objects takes: O(n + m\u03b1(m, n))time. Path compression is helpful with more union/ find operations First operation will still take the same amount of time (+ path compression for future operations) \u03b1 = ackermann function (between O(1) and O(logn)) Running time of find : \u03b1(m, n) Running time of union : \u03b1(m, n) Hashing Implement symbol table with an AVL tree: C(insert) = O(logn); C(search) = O(logn) Direct Access Table Using a table, indexed by keys Insert: O(1), Search: O(1) Space: m buckets Hash function defined to derive key Impossible to choose a hash function with no collisions (pigeonhole principle) Chaining Insert a linked list in the table, indexed by keys Space: O(m + n); table size is m, linked list size is n Insert: O(1 + cost(h)) Worst case search: O(n + cost(h)) (when all keys hash to the same bucket, cost is n) With SUHA, E(search time) = 1 + n/m = O(1) Maximum chain length with SUHA = O(logn) = \u0398(logn / loglogn) Simple uniform hashing assumption (made of the hashing function) Every key is equally likely to map to every bucket Keys are mapped independently P(i'th key is put in bucket j) = 1/m Open Addressing All data directly stored in the table, with one item per slot On collision, probe a sequence of buckets until an empty one is found Delete Set bucket to DELETED , instead of leaving it empty So that search can find an element Properties of good hash function h(key, i) enumerates all possible buckets Simple Uniform Hashing Assumption Linear probing can lead to clusters: O(n) Assuming uniform hashing, E(cost of operations) = 1 / (1 - a) a = n / m Performance degrades badly as a -> 1 Double Hashing Using two hash functions, define a new hash function: h(k, i) = f(k) + i * g(k) mod m Resizing Table Cost of resize from m to m + 1 Cost of double size: O(n) (done when the table is full) Cost of inserting n items + resizing: O(n) Most insertions: O(1) Average cost: O(1) Half the table size when table is 3/4 empty Cost of squared table size: O(n^2) Cost of inserts: O(n) Deleting elements: O(1 + n/m) Graph Diameter: maximum distance between two notes, following the shortest path Special graphs Star: one central node, all edges connect centre to edges; diameter = 2 Clique: complete graph, degree = n - 1; diameter = 1 Line or path: degree = 2; diameter = n - 1 Cycle: degree = 2; diameter = n/2 or n/2 - 1 Bipartite graph: nodes divided into two sets with no edges between nodes in the same set; diameter = n - 1 Memory usage of graph G | | Adjacency List | Adjacency Matrix | | ------------ | -------------- | ---------------- | | Graph (V, E) | O(V + E) | O(V^2) | | Cycle | O(V) | O(V^2) | | Clique | O(V^2) | O(V^2) | Breadth-First Search BFS with adjacency list: O(V + E) // With an adjacency list void BFS(int s) { // Mark all the vertices as not visited boolean visited[] = new boolean[V]; // Create a queue for BFS LinkedList<Integer> queue = new LinkedList<Integer>(); // Mark the current node as visited and enqueue it visited[s] = true; queue.add(s); while (queue.size() != 0) { // Dequeue a vertex from queue and print it s = queue.poll(); System.out.print(s + \" \"); // Get all adjacent vertices of the dequeued // vertex s. // If an adjacent has not been visited, // then mark it visited and enqueue it Iterator<Integer> i = adj[s].listIterator(); while (i.hasNext()) { int n = i.next(); if (!visited[n]) { visited[n] = true; queue.add(n); } } } } BFS with adjacency matrix: O(V^2) // With an adjacency matrix void BFS(int start) { // A vertex is not visited more than once // Initializing the vector to false at the beginning boolean[] visited = new boolean[v]; Arrays.fill(visited, false); List<Integer> q = new ArrayList<>(); q.add(start); // Set source as visited visited[start] = true; int vis; while (!q.isEmpty()) { vis = q.get(0); // Print the current node System.out.print(vis + \" \"); q.remove(q.get(0)); // For every adjacent vertex to the current vertex for(int i = 0; i < v; i++) { if (adj[vis][i] == 1 && (!visited[i])) { // Push the adjacent node to the queue q.add(i); visited[i] = true; } } } } Depth-First Search DFS with adjacency list: O(V + E) // With an adjacency list void DFSUtil(int v, boolean visited[]) { // Mark the current node as visited and print it visited[v] = true; System.out.print(v + \" \"); // Recurse for all adjacent vertices Iterator<Integer> i = adj[v].listIterator(); while (i.hasNext()) { int n = i.next(); if (!visited[n]) DFSUtil(n, visited); } } void DFS(int v) { // Mark all the vertices as // not visited(set as // false by default in java) boolean visited[] = new boolean[V]; // Call the recursive helper // function to print DFS // traversal DFSUtil(v, visited); } DFS with adjacency matrix: O(V^2) // With an adjacency matrix static void dfs(int start, boolean[] visited) { // Print the current node System.out.print(start + \" \"); // Set current node as visited visited[start] = true; // For every node of the graph for (int i = 0; i < adj[start].length; i++) { // If some node is adjacent to the current node // and it has not already been visited if (adj[start][i] == 1 && (!visited[i])) { dfs(i, visited); } } } Shortest Path Representing a directed graph Adjacency list space: O(V + E) Adjacency matrix space: O(V^2) Bellman-Ford Running time: O(EV) Stops after one entire iteration with no changes to estimates Invariant: Let T be a shortest path tree of graph G rooted at source S After iteration j, if u is j hops from s on tree T, then est[u] = distance(s, u) Description: Maintain an estimate of infinity for every node Update estimates with minimum of sum of edges Special issues: If negative weight-cycle: impossible Use Bellman-Ford to detect negative weight cycle (v + 1)th relaxing still changes an estimate If all weights are the same, use BFS void BellmanFord(Graph graph, int src) { int V = graph.V; // number of vertices int E = graph.E; // number of edges int dist[] = new int[V]; // Step 1: Initialize distances from src to all other vertices as INFINITE for (int i = 0; i < V; ++i) { dist[i] = Integer.MAX_VALUE; } dist[src] = 0; // Step 2: For every vertex, visit all edges for (int i = 1; i < V; ++i) { for (int j = 0; j < E; ++j) { // Edge goes from u to v int u = graph.edge[j].src; int v = graph.edge[j].dest; int weight = graph.edge[j].weight; if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) { dist[v] = dist[u] + weight; } } } // Step 3: check for negative-weight cycles. Guarantees shortest distances if graph // doesn't contain negative weight cycle. If we get a shorter path, then there is a cycle. for (int j = 0; j < E; ++j) { int u = graph.edge[j].src; int v = graph.edge[j].dest; int weight = graph.edge[j].weight; if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) { System.out.println(\"Graph contains negative weight cycle\"); return; } } printArr(dist, V); } Dijkstra's Algorithm No negative weight edges Description: Maintain distance estimate for every node Add neighbours and their distances into priority queue Remove node with smallest distance, visit its neighbours Done when priority queue is empty Final node will have its shortest distance static class iPair { int first, second; iPair(int first, int second) { this.first = first; this.second = second; } } void shortestPath(int src, int[][] graph) { // Sets up priority queue that compares distance of nodes, shorter distance first PriorityQueue<iPair> pq = new PriorityQueue<>(V, Comparator.comparingInt(o -> o.second)); int[] dist = new int[V]; Arrays.fill(dist, Integer.MAX_VALUE); pq.add(new iPair(0, src)); dist[src] = 0; while (!pq.isEmpty()) { // u is the value of the node with minimum distance int u = pq.poll().first; // for all neighbour of u for (int[] neighbour : graph[u]) { iPair v = new iPair(neighbour[0], neighbour[1]); int newDistance = dist[u] + v.second; if (dist[v.first] > newDistance) { dist[v.first] = newDistance; pq.add(new iPair(v.first, dist[v.first])); } } } for (int i = 0; i < V; i++) { System.out.println(i + dist[i]); } } Using AVL Tree priority queue Running time: O(E logV) insert: O(logn) deleteMin: O(logn) decreaseKey: O(logn) contains(key): O(1) Performance Minimum Spanning Trees A spanning tree with minimum weight Properties: No cycles If you cut an MST, the two pieces are both MSTs For every cycle, the maximum weight edge is not in the MST For every partition of the nodes, the minimum weight edge across the cut is in the MST For every vertex, the minimum outgoing edge is always in the MST (not true for maximum) Prim's Algorithm Continually pick the smallest edge of every node visited Using AVL tree for priority queue: Running time: O(E log V) class Pair implements Comparable<Pair> { int v; int wt; Pair(int v, int wt) { this.v = v; this.wt = wt; } public int compareTo(Pair that) { return this.wt - that.wt; } } static int spanningTree(int V, int E, int edges[][]) { ArrayList<ArrayList<Pair>> adj = new ArrayList<>(); for(int i = 0; i < V; i++) { adj.add(new ArrayList<Pair>()); } for(int i = 0; i < edges.length; i++) { int u = edges[i][0]; // from node u int v = edges[i][1]; // to node v int wt = edges[i][2]; // of weight wt // Add all edges into adj adj.get(u).add(new Pair(v,wt)); adj.get(v).add(new Pair(u,wt)); } PriorityQueue<Pair> pq = new PriorityQueue<Pair>(); pq.add(new Pair(0,0)); int[] vis = new int[V]; int s = 0; while (!pq.isEmpty()) { Pair node = pq.poll(); int v = node.v; // curr node's value int wt = node.wt; // curr node's weight if (vis[v] == 1) { continue; // if node is visited, skip } // node was not visited before s += wt; vis[v] = 1; for(Pair it : adj.get(v)) { if(vis[it.v] == 0) { pq.add(new Pair(it.v, it.wt)); } } } return s; } Kruskal's Algorithm Sort all edges by weight, take all the minimum edges as long as there are no cycles Running time: O(E logV) static class Subset { int parent, rank; public Subset(int parent, int rank) { this.parent = parent; this.rank = rank; } } static class Edge { int src, dest, weight; public Edge(int src, int dest, int weight) { this.src = src; this.dest = dest; this.weight = weight; } } private static int findRoot(Subset[] subsets, int i) { if (subsets[i].parent == i) { return subsets[i].parent; } subsets[i].parent = findRoot(subsets, subsets[i].parent); return subsets[i].parent; } private static void union(Subset[] subsets, int x, int y) { int rootX = findRoot(subsets, x); int rootY = findRoot(subsets, y); if (subsets[rootY].rank < subsets[rootX].rank) { subsets[rootY].parent = rootX; } else if (subsets[rootX].rank < subsets[rootY].rank) { subsets[rootX].parent = rootY; } else { subsets[rootY].parent = rootX; subsets[rootX].rank++; } } private static void kruskals(int V, List<Edge> edges) { int j = 0; int noOfEdges = 0; Subset subsets[] = new Subset[V]; Edge results[] = new Edge[V]; // Create V subsets with single elements for (int i = 0; i < V; i++) { subsets[i] = new Subset(i, 0); } while (noOfEdges < V - 1) { // Edges are sorted in ascending order // Pick the smallest edge Edge nextEdge = edges.get(j); int x = findRoot(subsets, nextEdge.src); int y = findRoot(subsets, nextEdge.dest); // If cycle, root is the same if (x != y) { results[noOfEdges] = nextEdge; union(subsets, x, y); noOfEdges++; } j++; } int minCost = 0; for (int i = 0; i < noOfEdges; i++) { System.out.println(results[i].src + \" -- \" + results[i].dest + \" == \" + results[i].weight); minCost += results[i].weight; } System.out.println(\"Total cost of MST: \" + minCost); } Dynamic Programming Bottom up Solve smallest problems Combine smaller problems Solve root problem Top down Start at root and recurse Recurse Solve and memoize Topological Sort Using DFS to find cycles and add to stack Verifies if the graph given is a directed acyclic graph (DAG) class Solution { HashMap<Integer, LinkedList<Integer>> adj = new HashMap<>(); HashMap<Integer, Boolean> visited = new HashMap<>(); Stack<Integer> stack = new Stack<>(); boolean isImpossible = false; public void addEdge(int v, int w) { adj.putIfAbsent(v, new LinkedList<>()); adj.putIfAbsent(w, new LinkedList<>()); adj.get(v).add(w); } private void dfsHelper(Integer v, HashMap<Integer, Boolean> visited1) { visited.put(v, true); visited1.put(v, true); // Traverse neighbours for (Integer i: adj.get(v)) { if (visited1.containsKey(i)) { isImpossible = true; // there is a cycle break; } if (!visited.get(i)) { dfsHelper(i, visited1); } } visited1.remove(v); stack.push(v); } public int[] findOrder(int numCourses, int[][] prerequisites) { int[] res = new int[numCourses]; Arrays.setAll(res, i -> i); if (prerequisites.length == 0) { return res; } // Add all edges into graph adj for (int[] prerequisite : prerequisites) { addEdge(prerequisite[1], prerequisite[0]); } // Set all keys to visited = false for (Integer key: adj.keySet()) { visited.put(key, false); } // Start DFS for (Integer key: adj.keySet()) { HashMap<Integer, Boolean> visited1 = new HashMap<>(); if (visited.get(key) == false) { dfsHelper(key, visited1); } } if (isImpossible) { return new int[0]; } HashMap<Integer, Integer> hm = new HashMap<>(); for (int i = 0; i < numCourses; i++) { hm.put(i, i); } // Add sorted courses into array int n = stack.size(); for (int i = 0; i < n; i++) { int course = stack.pop(); res[i] = course; hm.remove(course); } // Fill in the rest of the array with the missing courses int[] left = hm.keySet().stream().mapToInt(Integer::intValue).toArray(); int i1 = 0; int i2 = n; while (i1 < left.length && n < numCourses) { res[i2] = left[i1]; i1++; i2++; } return res; } }","title":"Data Structures and Algorithm"},{"location":"dsa-notes/dsa-notes/#data-structures-and-algorithm","text":"Data Structures and Algorithm Recurrence Relations Binary Search Peak Finding Sorting BubbleSort SelectionSort InsertionSort MergeSort QuickSort Partition QuickSelect Trees Binary Search Trees Height Search Insert Traversals Inorder Traversal Preorder Traversal Postorder Traversal Delete Balanced Trees AVL Insert Delete Tries Dynamic Order Statistics Interval Trees Insert Interval Search 1D Range Trees Query 2D Range Trees Priority Queue Binary (Max) Heaps Insert DecreaseKey Delete Heap vs AVL Tree HeapSort Disjoint Set Quick Find: using an int[] componentId Quick Union: using an int[] parent Weighted Union Weighted Union with Path Compression Hashing Direct Access Table Chaining Open Addressing Resizing Table Graph Breadth-First Search Depth-First Search Shortest Path Bellman-Ford Dijkstra's Algorithm Minimum Spanning Trees Prim's Algorithm Kruskal's Algorithm Dynamic Programming Topological Sort","title":"Data Structures and Algorithm"},{"location":"dsa-notes/dsa-notes/#recurrence-relations","text":"T(n) = T(n-1) + O(1) = O(n) T(n) = T(n/2) + O(1) = O(logn) T(n) = T(n-1) + O(n) = O(n^2) T(n) = T(n-1) + O(nk) = O(n^(k+1)) T(n) = 2T(n/2) + O(n) = O(nlogn) T(n) = T(n/2) + O(n) = O(n) T(n) = 2T(n/2) + O(1) = O(n) T(n) = 2T(n-1) + O(1) = O(2^n)","title":"Recurrence Relations"},{"location":"dsa-notes/dsa-notes/#binary-search","text":"Time complexity: O(logn) Preconditions: Array is of size n Array is sorted Postconditions: If element is in array: A[left] = key Loop invariant: A[left] <= key <= A[right] (right - left) <= n/2^k in iteration k public int search(int A[], int key, int n) { int left = 0; int right = n - 1; while (left < right) { // int mid = (left + right) / 2 can lead to integer overflow int mid = left + (right - left) / 2; if (key <= A[mid]) { right = mid; } else { left = mid + 1; } } return (A[left] == key ? left : -1); }","title":"Binary Search"},{"location":"dsa-notes/dsa-notes/#peak-finding","text":"Output a local maximum in A, where A[i - 1] <= A[i] and A[i + 1] <= A[i] Time complexity: O(logn) Invariant: If we recuse in the right half, then there exists a peak in the right half There exists a peak in the range [begin, end] Every peak in [begin, end] is a peak in [1, n] T(n) = T(n/2) + \u03b8(1) = O(logn) public int findPeak(int A[], int n) { // if right of mid is larger, recurse on right if (A[n / 2 + 1] > A[n / 2]) { return findPeak(Arrays.copyOfRange(A, n / 2 + 1, n + 1), n / 2) // if left of mid is larger, recurse on left } else if (A[n / 2 - 1] > A[n / 2]) { return findPeak(Arrays.copyOfRange(A, 0, n / 2), n / 2) } else { return n / 2; } }","title":"Peak Finding"},{"location":"dsa-notes/dsa-notes/#sorting","text":"","title":"Sorting"},{"location":"dsa-notes/dsa-notes/#bubblesort","text":"Invariant: At the end of iteration i, the biggest j items are correctly sorted in the final j positions of the array. Best: O(n), when array is already sorted Worst: O(n^2) , when array is reverse sorted Stable Description: For n loops, if A[j] > A[j + 1], swap(A[j], A[j + 1]) void bubbleSort(int arr[], int n) { int i, j, temp; boolean swapped; for (i = 0; i < n - 1; i++) { swapped = false; for (j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { // Swap arr[j] and arr[j+1] temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; swapped = true; } } // If no two elements were // swapped by inner loop, then break if (swapped == false) break; } }","title":"BubbleSort"},{"location":"dsa-notes/dsa-notes/#selectionsort","text":"Invariant: At the end of iteration j: the smallest j items are correctly sorted in the first j positions of the array. Best: O(n^2) Worst: O(n^2) Not stable Description: For n loops, find minimum element A[j] in A[j..n], swap(A[j], A[k]) void selectionSort(int arr[], int n) { int min_idx = 0; // One by one move boundary of unsorted subarray for (int i = 0; i < n - 1; i++) { // Find the minimum element in unsorted array min_idx = i; for (int j = i + 1; j < n; j++) { if (arr[j] < arr[min_idx]) min_idx = j; } // Swap the found minimum element with the first element if (min_idx != i) swap(arr[min_idx], arr[i]); } }","title":"SelectionSort"},{"location":"dsa-notes/dsa-notes/#insertionsort","text":"Invariant: At the end of iteration j: the first j items in the array are in sorted order. Best: O(n), when array is already sorted Worst: O(n^2) , when array is reverse sorted Stable Description: For n loops, insert key into the sorted array A[1 .. j - 1] void insertionSort(int arr[]) { int n = arr.length; for (int i = 1; i < n; ++i) { int key = arr[i]; int j = i - 1; /* Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position */ while (j >= 0 && arr[j] > key) { arr[j + 1] = arr[j]; j = j - 1; } arr[j + 1] = key; } }","title":"InsertionSort"},{"location":"dsa-notes/dsa-notes/#mergesort","text":"Best: O(n logn) Worst: O(n logn) Stable Memory: O(n logn) Description: Divide: split array into two halves Recurse: sort the two halves Combine: merge the two sorted halves Use InsertionSort instead for n < 1024 void merge(int arr[], int l, int m, int r) { // Find sizes of two subarrays to be merged int n1 = m - l + 1; int n2 = r - m; // Create temp arrays int L[] = new int[n1]; int R[] = new int[n2]; // Copy data to temp arrays for (int i = 0; i < n1; ++i) L[i] = arr[l + i]; for (int j = 0; j < n2; ++j) R[j] = arr[m + 1 + j]; // Merge the temp arrays // Initial indices of first and second subarrays int i = 0, j = 0; // Initial index of merged subarray array int k = l; while (i < n1 && j < n2) { if (L[i] <= R[j]) { arr[k] = L[i]; i++; } else { arr[k] = R[j]; j++; } k++; } // Copy remaining elements of L[] if any while (i < n1) { arr[k] = L[i]; i++; k++; } // Copy remaining elements of R[] if any while (j < n2) { arr[k] = R[j]; j++; k++; } } void mergeSort(int arr[], int l, int r) { if (l < r) { // Find the middle point int m = l + (r - l) / 2; // Sort first and second halves mergeSort(arr, l, m); mergeSort(arr, m + 1, r); // Merge the sorted halves merge(arr, l, m, r); } }","title":"MergeSort"},{"location":"dsa-notes/dsa-notes/#quicksort","text":"Invariant: At the end of every loop iteration, For every i < low: B[i] < pivot For every j > high: B[j] > pivot Best: O(n logn) , when median element is chosen as pivot Worst: O(n^2) , when first element is chosen as pivot/ all elements are the same Not stable Description: Divide: Partition the array into two sub-arrays around a pivot x such that elements in lower subarray \u2264 x \u2264 elements in upper sub-array. Conquer: Recursively sort the two sub-arrays. Combine: Trivial, do nothing. void quickSort(int[] arr, int low, int high) { if (low < high) { // pi is partitioning index, arr[pi] // is now at right place int pi = partition(arr, low, high); // Separately sort elements before // partition and after partition quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } }","title":"QuickSort"},{"location":"dsa-notes/dsa-notes/#partition","text":"Invariant: A[high] > pivot at the end of each loop At the end of every loop iteration For all i >= high, A[i] > pivot For all 1 < j < low, A[j] < pivot Time complexity: O(n) int partition(int[] arr, int low, int high) { // Choosing the pivot int pivot = arr[high]; // Index of smaller element and indicates // the right position of pivot found so far int i = (low - 1); for (int j = low; j <= high - 1; j++) { // If current element is smaller than the pivot if (arr[j] < pivot) { // Increment index of smaller element i++; swap(arr, i, j); } } swap(arr, i + 1, high); return (i + 1); }","title":"Partition"},{"location":"dsa-notes/dsa-notes/#quickselect","text":"Invariant: After partioning, arr[partition] is now at right place Time complexity: O(n) Description: Find the k-th smallest element in an unordered list partition the array if partition is at position k, the partition is the k-th smallest element else continue searching in the correct half // ASSUMPTION: all elements in arr[] are distinct int kthSmallest(int[] arr, int low, int high, int k) { // find the partition int partition = partition(arr, low, high); // if partition value is equal to the kth position, return value at k if (partition == k - 1) { return arr[partition]; } // if partition value is less than kth position, search right side of the array else if (partition < k - 1) { return kthSmallest(arr, partition + 1, high, k); } // if partition value is more than kth position, search left side of the array else { return kthSmallest(arr, low, partition - 1, k); } }","title":"QuickSelect"},{"location":"dsa-notes/dsa-notes/#trees","text":"","title":"Trees"},{"location":"dsa-notes/dsa-notes/#binary-search-trees","text":"All in left sub-tree < key < all in right sub-tree","title":"Binary Search Trees"},{"location":"dsa-notes/dsa-notes/#height","text":"Number of edges on longest path from root to leaf h(v) = 0 (if v is a leaf) h(v) = max(h(v.left), h(v.right)) + 1 Time complexity: O(logn) int height() { int leftHeight = -1; int rightHeight = -1; if (leftTree != null) { leftHeight = leftTree.height(); } if (rightTree != null) { rightHeight = rightTree.height(); } return max(leftHeight, rightHeight) + 1; }","title":"Height"},{"location":"dsa-notes/dsa-notes/#search","text":"Worst case: O(n) , (when n = h) Time complexity: O(h) searchMax() TreeNode searchMax() { if (rightTree != null) { return rightTree.searchMax(); } else { return this; } } searchMin() TreeNode searchMin() { if (leftTree != null) { return leftTree.searchMin(); } else { return this; } } search(int queryKey) public TreeNode search(int queryKey){ if (queryKey < key) { if (leftTree != null) { return leftTree.search(key); } else { return null; } } else if (queryKey > key) { if (rightTree != null) { return rightTree.search(key); } else { return null; } } else { return this; // Key is here! } }","title":"Search"},{"location":"dsa-notes/dsa-notes/#insert","text":"void insert(int insKey, int intValue) { if (insKey < key) { if (leftTree != null) { leftTree.insert(insKey); } else { leftTree = new TreeNode(insKey,insValue) } } else if (insKey > key) { if (rightTree != null) { rightTree.insert(insKey); } else { rightTree = new TreeNode(insKey, insValue); } } else { return; // Key is already in the tree! } }","title":"Insert"},{"location":"dsa-notes/dsa-notes/#traversals","text":"","title":"Traversals"},{"location":"dsa-notes/dsa-notes/#inorder-traversal","text":"Left, self, right Running time: O(n) void inOrder(Node node) { if (node == null) return; // First recur on left child inOrder(node.left); // Then print the data of node System.out.print(node.key + \" \"); // Now recur on right child inOrder(node.right); }","title":"Inorder Traversal"},{"location":"dsa-notes/dsa-notes/#preorder-traversal","text":"Self, left, right Running time: O(n) void preOrder(Node node) { if (node == null) return; // Print the data of node System.out.print(node.key + \" \"); // Then recur on left child preOrder(node.left); // Now recur on right child preOrder(node.right); }","title":"Preorder Traversal"},{"location":"dsa-notes/dsa-notes/#postorder-traversal","text":"Left, right, self Running time: O(n) void postOrder(Node node) { if (node == null) return; // First recur on left child postOrder(node.left); // Then recur on right child postOrder(node.right); // Now print the data of node System.out.print(node.key + \" \"); }","title":"Postorder Traversal"},{"location":"dsa-notes/dsa-notes/#delete","text":"Successor Running time: O(h) Idea: Search for key in the tree. If (result > key), then return result. If (result <= key), then search for successor of result. Case 1: node has a right child Case 2: node has no right child public TreeNode successor() { if (rightTree != null) { return rightTree.searchMin(); } TreeNode parent = parentTree; TreeNode child = this; while ((parent != null) && (child == parent.rightTree)) { child = parent; parent = child.parentTree; } return parent; } Delete Running time: O(h) Case 1: no children Remove v Case 2: 1 child Remove v Connect child(v) to parent(v) Case 3: 2 children x = successor(v) Delete(x) Remove v Connect x to left(v), right(v), parent(v)","title":"Delete"},{"location":"dsa-notes/dsa-notes/#balanced-trees","text":"BST is balanced if h = O(logn) All operations run in O(logn) time Maxmimum height: h < 2logn Mininimum nodes: n > 2^(h/2) In every node v, store height (augment) On insert and delete, update height: height = max(left.height, right.height) + 1 Define Invariant A node v is height-balanced if |v.left.height - v.right.height| <= 1 A BST is height-balanced if every node is height-balanced Maintain balance // assume v has left != null void rightRotate(TreeNode v) { TreeNode w = v.left; w.parent = v.parent; v.parent = w; v.left = w.right; w.right = v; } // assume v has right != null void leftRotate(TreeNode v) { TreeNode w = v.right; w.parent = v.parent; v.parent = w; v.right = w.left; w.left = v; } If v is out of balanced and left-heavy: Case 1: v.left is balanced -> rightRotate(v) Case 2: v.left is left-heavy -> rightRotate(v) Case 3: v.left is right-heavy -> leftRotate(v.left), rightRotate(v) If v is out of balanced and right-heavy: Case 1: v.right is balanced -> leftRotate(v) Case 2: v.right is left-heavy -> leftRotate(v) Case 3: v.right is right-heavy -> rightRotate(v.right), leftRotate(v) import java.util.TreeSet; TreeSet<IntegerNode> leftHalf; TreeSet<IntegerNode> rightHalf; void rebalance() { int leftSize = this.leftHalf.size(); int rightSize = this.rightHalf.size(); int diff = Math.abs(leftSize - rightSize); if (diff > 1) { if (leftSize > rightSize) { // Left is bigger, move the biggest item to right this.rightHalf.add(this.leftHalf.pollLast()); } else { // Right is bigger, move the smallest item to left this.leftHalf.add(this.rightHalf.pollFirst()); } } }","title":"Balanced Trees"},{"location":"dsa-notes/dsa-notes/#avl","text":"","title":"AVL"},{"location":"dsa-notes/dsa-notes/#insert_1","text":"Summary: Insert key in BST Walk up tree: At every step, check for balance If out-of-balance, use rotations to rebalance and return Key observation: Only need to fix lowest out-of-balance node Only need at most two rotations to fix","title":"Insert"},{"location":"dsa-notes/dsa-notes/#delete_1","text":"If v has two children, swap it with its successor Delete node v from binary tree (and reconnect children) For every ancestor of the deleted node: Check if it is height-balanced If not, perform a rotation Continue to the root Summary: Delete key from BST Walk up tree: At every step, check for balance If out-of-balance, use rotations to rebalance continue to root Key observation: Needs at most O(logn) rotations import java.util.*; import java.io.*; class Node { int key, height; Node left, right; Node (int d) { key = d; height = 1; } } class AVLTree { Node root; int height (Node N) { if (N == null) return 0; return N.height; } int max (int a, int b) { return (a > b) ? a : b; } Node rightRotate (Node y) { Node x = y.left; Node T2 = x.right; x.right = y; y.left = T2; y.height = max (height (y.left), height (y.right)) + 1; x.height = max (height (x.left), height (x.right)) + 1; return x; } Node leftRotate (Node x) { Node y = x.right; Node T2 = y.left; y.left = x; x.right = T2; x.height = max (height (x.left), height (x.right)) + 1; y.height = max (height (y.left), height (y.right)) + 1; return y; } int getBalance (Node N) { if (N == null) return 0; return height (N.left) - height (N.right); } Node insert (Node node, int key) { if (node == null) return (new Node (key)); if (key < node.key) node.left = insert (node.left, key); else if (key > node.key) node.right = insert (node.right, key); else return node; node.height = 1 + max (height (node.left), height (node.right)); int balance = getBalance (node); if (balance > 1 && key < node.left.key) return rightRotate (node); if (balance < -1 && key > node.right.key) return leftRotate (node); if (balance > 1 && key > node.left.key) { node.left = leftRotate (node.left); return rightRotate (node); } if (balance < -1 && key < node.right.key) { node.right = rightRotate (node.right); return leftRotate (node); } return node; } }","title":"Delete"},{"location":"dsa-notes/dsa-notes/#tries","text":"Cost of comparing two strings in a tree: O(hL) Cost in trie: O(L) Space for storing a try: O(size of text * overhead)","title":"Tries"},{"location":"dsa-notes/dsa-notes/#dynamic-order-statistics","text":"Select(k) : finds the node with rank k // augmented tree with weight // O(logn) Node select(k) { rank = m_left.weight + 1; if (k == rank) { return v; } else if (k < rank) { return m_left.select(k); } else if (k > rank) { return m_right.select(k\u2013rank); } } // in-order traversal method // O(n) Node kthSmallest(int k) { Result result = new Result(0, null); inOrderTraversal(root, k, result); return result.result; } void inOrderTraversal(Node node, int k, Result result) { if (node == null || result.count >= k) { return; } inOrderTraversal(node.left, k, result); result.count++; if (result.count == k) { result.result = node; return; } inOrderTraversal(node.right, k, result); } class Result { int count; Node result; Result(int count, Node result) { this.count = count; this.result = result; } } Rank(v) : computes the rank of a node v // augmented tree with weight // O(logn) int rank(TreeNode node) { rank = node.left.weight + 1; while (node != null) { if (node.parent.left == node) { continue; } else { rank += node.parent.left.weight + 1; } node = node.parent; } return rank; } // recursion method // worst case: O(n) int rank(TreeNode node, int x) { if (node == null) { return 0; } if (node.value <= x) { return 1 + rank(node.left, x) + rank(node.right,x); } else { return rank(node.left, x) } }","title":"Dynamic Order Statistics"},{"location":"dsa-notes/dsa-notes/#interval-trees","text":"Augment tree with maximum endpoint in subtree class Node { int[] interval; int maxEnd; Node left, right; int height; Node(int[] interval) { this.interval = interval; this.maxEnd = interval[1]; this.left = this.right = null; this.height = 1; } }","title":"Interval Trees"},{"location":"dsa-notes/dsa-notes/#insert_2","text":"class IntervalTree { private int height(Node node) { return (node == null) ? 0 : node.height; } private int maxEnd(Node node) { return (node == null) ? Integer.MIN_VALUE : node.maxEnd; } private int getBalance(Node node) { return (node == null) ? 0 : height(node.left) - height(node.right); } private Node insert(Node root, int[] interval) { if (root == null) { return new Node(interval); } if (interval[0] < root.interval[0]) { root.left = insert(root.left, interval); } else { root.right = insert(root.right, interval); } root.height = Math.max(height(root.left), height(root.right)) + 1; root.maxEnd = Math.max(root.interval[1], Math.max(maxEnd(root.left), maxEnd(root.right))); int balance = getBalance(root); // Left Heavy if (balance > 1) { if (interval[0] < root.left.interval[0]) { return rotateRight(root); } else { root.left = rotateLeft(root.left); return rotateRight(root); } } // Right Heavy if (balance < -1) { if (interval[0] > root.right.interval[0]) { return rotateLeft(root); } else { root.right = rotateRight(root.right); return rotateLeft(root); } } return root; } }","title":"Insert"},{"location":"dsa-notes/dsa-notes/#interval-search","text":"Find interval containing x Running time: O(logn) boolean isInInterval(Node c, int x) { return x >= c.interval[0] && x <= c.interval[1]; } int[] intervalSearch(int x) { Node c = root; while (c != null && !isInInterval(c, x)) { if (c.left == null) { c = c.right; } else if (x > c.left.maxEnd) { c = c.right; } else { c = c.left; } } return c.interval; } All-Overlaps: List all intervals that overlap with point Running time if there are k overlapping intervals: O(k logn) Repeat until no more intervals: Search for interval. Add to list. Delete interval. Repeat for all intervals on list: Add interval back to tree.","title":"Interval Search"},{"location":"dsa-notes/dsa-notes/#1d-range-trees","text":"Strategy: Use a binary search tree. Store all points in the leaves of the tree. (Internal nodes store only copies.) Each internal node v stores the MAX of any leaf in the left sub-tree.","title":"1D Range Trees"},{"location":"dsa-notes/dsa-notes/#query","text":"Invariant: The search interval for a left-traversal at node v includes the maximum item in the subtree rooted at v. Algorithm: Find split node, takes O(logn) Do left traversal Do right traversal Query time complexity: O(k + logn), where k is number of points found Preprocessing (buildtree) time complexity: O(n logn) Total space complexity: O(n) Node FindSplit(int low, int high) { Node v = root; done = false; while (!done) { if (high <= v.key) { v = v.left; } else if (low > v.key) { v = v.right; } else { done = true } } return v; } // LeftTraversal either: // 1. Output all right sub-tree and recurse left. // 2. Recurse right. void LeftTraversal(Node v, int low, int high) { boolean isInRange = low <= v.key; boolean isLeafNode = v.left == null && v.right == null; if (isLeafNode && isInRange) { System.out.println(v.key); } if (isInRange) { // if in range, take the all of right subtree's leafs AllLeafTraversal(v.right); LeftTraversal(v.left, low, high); } else { LeftTraversal(v.right, low, high); } } void RightTraversal(Node v, int low, int high) { boolean isInRange = v.key <= high; boolean isLeafNode = v.left == null && v.right == null; if (isLeafNode && isInRange) { System.out.println(v.key); } if (isInRange) { // if in range, take the all of left subtree's leafs AllLeafTraversal(v.left); RightTraversal(v.right, low, high); } else { RightTraversal(v.left, low, high); } } void AllLeafTraversal(Node v) { if (v == null) { return; } // only leaf nodes are printed if (v.left == null && v.right == null) { System.out.println(v.key); } AllLeafTraversal(v.left); AllLeafTraversal(v.right); } void Query(low, high) { Node v = FindSplit(low, high); LeftTraversal(v.left, low, high); RightTraversal(v.right, low, high); }","title":"Query"},{"location":"dsa-notes/dsa-notes/#2d-range-trees","text":"Build an x-tree using only x-coordinates. For every node in the x-tree, build a y-tree out of nodes in subtree using only y-coordinates. Query time: O((logn)^2 + k) O(logn) to find split node O(logn) recursing steps O(logn) y-tree-searches of cost O(logn) O(k) enumerating output Space complexity: O(n logn) Each point appears in at most one y-tree per level There are O(log n) levels Query cost: O((logn)^d + k) buildTree cost: O(n (logn)^d-1) Space: O(n (logn)^d-1)","title":"2D Range Trees"},{"location":"dsa-notes/dsa-notes/#priority-queue","text":"Return Type Operation Description void insert(Key k, Priority p) insert k with priority p Data extractMin() remove key with min. priority void decreaseKey(Key k, Priority p) reduce the priority of key k to priority p boolean contains(Key k) whether queue contains key k boolean isEmpty() whether queue is empty Sorted array Insert: O(n) extractMax: O(1) Unsorted array insert: O(1) extractMax: O(n) AVL tree (indexed by priority) insert: O(logn) extractMax: O(logn) AVL tree and dictionary contains: O(1) decreaseKey: O(logn)","title":"Priority Queue"},{"location":"dsa-notes/dsa-notes/#binary-max-heaps","text":"Heap ordering: priority[parent] >= priority[child] Complete binary tree Every level is full, except possibly the last All nodes are as far left as possible Height: O(logn) (maximum height is floor(logn)) Operations: O(logn) Implements a max priority queue Return Type Operation Description void insert(Key k, Priority p) insert k with priority p Data extractMax() remove key with max priority void increaseKey(Key k, Priority p) increase the priority of key k to priority p void decreaseKey(Key k, Priority p) reduce the priority of key k to priority p Data delete(Key k) delete k from heap left(x) = 2 * x + 1 right(x) = 2 * x + 2 parent(x) = floor((x - 1) / 2) Where x is the position of the node in the array","title":"Binary (Max) Heaps"},{"location":"dsa-notes/dsa-notes/#insert_3","text":"Add leaf of new node at leftmost position Bubble up (swap with parent) until condition priority[parent] >= priority[child] fulfilled bubbleUp(Node v) { while (v != null) { if (priority(v) > priority(parent(v))) { swap(v, parent(v)); } else { return; } v = parent(v); } } insert(Priority p, Key k) { Node v = tree.insert(p, k); bubbleUp(v); }","title":"Insert"},{"location":"dsa-notes/dsa-notes/#decreasekey","text":"Update priority Bubble down (swap with child that has higher priority) bubbleDown(Node v) { while (!isLeaf(v)) { leftP = priority(left(v)); rightP = priority(right(v)); maxP = max(leftP, rightP, priority(v)); if (leftP == max) { swap(v, left(v)); v = left(v); } else if (rightP == max) { swap(v, right(v)); v = right(v); } else { return; } } }","title":"DecreaseKey"},{"location":"dsa-notes/dsa-notes/#delete_2","text":"Swap deleted node with last node (which is last element in array) Remove last node Bubble down swapped node ExtractMax: delete(root);","title":"Delete"},{"location":"dsa-notes/dsa-notes/#heap-vs-avl-tree","text":"Same asymptotic cost for operations Faster real cost (no constant factors) Simpler: no rotations Slightly better concurrency","title":"Heap vs AVL Tree"},{"location":"dsa-notes/dsa-notes/#heapsort","text":"Running time: O(n logn) In-place Deterministic, and will always take O(n logn) Faster than MergeSort, a little slower than QuickSort Not stable Unsorted list --> heap (running time: O(n)), specifically 2 * O(n) Base case: each leaf is a heap Recursion: siblings + parent nodes = heap (bubbleDown) // int[] A = array of unsorted integers for (int i = n - 1; i >= 0; i--) { bubbleDown(i, A); // O(height), but more than n/2 of nodes are leaves with height = 0 } Heap --> sorted list () (running time: O(n logn)) Fill array from last position to first position, by recursively calling extractMax() //int[] A = array stored as a heap for (int i = n - 1; i >= 0; i--) { int value = extractMax(A); //O(logn) A[i] = value; }","title":"HeapSort"},{"location":"dsa-notes/dsa-notes/#disjoint-set","text":"Determine if objects are connected","title":"Disjoint Set"},{"location":"dsa-notes/dsa-notes/#quick-find-using-an-int-componentid","text":"Store component identifier of each object Find: O(1) Finds whether p and q are connected boolean find(int p, int q) { return(componentId[p] == componentId[q]); } Union: O(n) Make p and q have the same componentId Traverse the component identifier array: if id = q's id, update to be p's id void union(int p, int q) { updateComponent = componentId[q]; for (int i=0; i<componentId.length; i++) { if (componentId[i] == updateComponent) { componentId[i] = componentId[p]; } } }","title":"Quick Find: using an int[] componentId"},{"location":"dsa-notes/dsa-notes/#quick-union-using-an-int-parent","text":"Two objects are connected if they are part of the same tree Find: O(n) Traverse up the tree from given node, to find parent If final parents are the same, they are connected boolean find(int p, int q) { while (parent[p] != p) { p = parent[p]; } while (parent[q] != q) { q = parent[q]; } return (p == q); } Union: O(n), height of tree can be n Traverse up the tree from given node, to find parent Set parent of p to be q void union(int p, int q) { while (parent[p] != p) { p = parent[p]; } while (parent[q] != q) { q = parent[q]; } parent[p] = q; }","title":"Quick Union: using an int[] parent"},{"location":"dsa-notes/dsa-notes/#weighted-union","text":"Choose the larger element to be the parent during union Maximum depth of tree: O(logn) Running time of find : O(logn) Running time of union : O(logn) union(int p, int q) { while (parent[p] !=p) { p = parent[p]; } while (parent[q] !=q) { q = parent[q]; } if (size[p] > size[q]) { parent[q] = p; // Link q to p size[p] = size[p] + size[q]; } else { parent[p] = q; // Link p to q size[q] = size[p] + size[q]; } }","title":"Weighted Union"},{"location":"dsa-notes/dsa-notes/#weighted-union-with-path-compression","text":"After finding root, set the parent of each traversed node to the root Tree height is compressed // Takes O(logn) time findRoot(int p) { root = p; while (parent[root] != root) { root = parent[root]; } while (parent[p] != p) { temp = parent[p]; parent[p] = root; p = temp; } return root; } union(int p, int q) { p = findRoot(p); q = findRoot(q); if (size[p] > size[q]) { parent[q] = p; // Link q to p size[p] = size[p] + size[q]; } else { parent[p] = q; // Link p to q size[q] = size[p] + size[q]; } } Starting from empty, any sequence of m union/find operations on n objects takes: O(n + m\u03b1(m, n))time. Path compression is helpful with more union/ find operations First operation will still take the same amount of time (+ path compression for future operations) \u03b1 = ackermann function (between O(1) and O(logn)) Running time of find : \u03b1(m, n) Running time of union : \u03b1(m, n)","title":"Weighted Union with Path Compression"},{"location":"dsa-notes/dsa-notes/#hashing","text":"Implement symbol table with an AVL tree: C(insert) = O(logn); C(search) = O(logn)","title":"Hashing"},{"location":"dsa-notes/dsa-notes/#direct-access-table","text":"Using a table, indexed by keys Insert: O(1), Search: O(1) Space: m buckets Hash function defined to derive key Impossible to choose a hash function with no collisions (pigeonhole principle)","title":"Direct Access Table"},{"location":"dsa-notes/dsa-notes/#chaining","text":"Insert a linked list in the table, indexed by keys Space: O(m + n); table size is m, linked list size is n Insert: O(1 + cost(h)) Worst case search: O(n + cost(h)) (when all keys hash to the same bucket, cost is n) With SUHA, E(search time) = 1 + n/m = O(1) Maximum chain length with SUHA = O(logn) = \u0398(logn / loglogn) Simple uniform hashing assumption (made of the hashing function) Every key is equally likely to map to every bucket Keys are mapped independently P(i'th key is put in bucket j) = 1/m","title":"Chaining"},{"location":"dsa-notes/dsa-notes/#open-addressing","text":"All data directly stored in the table, with one item per slot On collision, probe a sequence of buckets until an empty one is found Delete Set bucket to DELETED , instead of leaving it empty So that search can find an element Properties of good hash function h(key, i) enumerates all possible buckets Simple Uniform Hashing Assumption Linear probing can lead to clusters: O(n) Assuming uniform hashing, E(cost of operations) = 1 / (1 - a) a = n / m Performance degrades badly as a -> 1 Double Hashing Using two hash functions, define a new hash function: h(k, i) = f(k) + i * g(k) mod m","title":"Open Addressing"},{"location":"dsa-notes/dsa-notes/#resizing-table","text":"Cost of resize from m to m + 1 Cost of double size: O(n) (done when the table is full) Cost of inserting n items + resizing: O(n) Most insertions: O(1) Average cost: O(1) Half the table size when table is 3/4 empty Cost of squared table size: O(n^2) Cost of inserts: O(n) Deleting elements: O(1 + n/m)","title":"Resizing Table"},{"location":"dsa-notes/dsa-notes/#graph","text":"Diameter: maximum distance between two notes, following the shortest path Special graphs Star: one central node, all edges connect centre to edges; diameter = 2 Clique: complete graph, degree = n - 1; diameter = 1 Line or path: degree = 2; diameter = n - 1 Cycle: degree = 2; diameter = n/2 or n/2 - 1 Bipartite graph: nodes divided into two sets with no edges between nodes in the same set; diameter = n - 1 Memory usage of graph G | | Adjacency List | Adjacency Matrix | | ------------ | -------------- | ---------------- | | Graph (V, E) | O(V + E) | O(V^2) | | Cycle | O(V) | O(V^2) | | Clique | O(V^2) | O(V^2) |","title":"Graph"},{"location":"dsa-notes/dsa-notes/#breadth-first-search","text":"BFS with adjacency list: O(V + E) // With an adjacency list void BFS(int s) { // Mark all the vertices as not visited boolean visited[] = new boolean[V]; // Create a queue for BFS LinkedList<Integer> queue = new LinkedList<Integer>(); // Mark the current node as visited and enqueue it visited[s] = true; queue.add(s); while (queue.size() != 0) { // Dequeue a vertex from queue and print it s = queue.poll(); System.out.print(s + \" \"); // Get all adjacent vertices of the dequeued // vertex s. // If an adjacent has not been visited, // then mark it visited and enqueue it Iterator<Integer> i = adj[s].listIterator(); while (i.hasNext()) { int n = i.next(); if (!visited[n]) { visited[n] = true; queue.add(n); } } } } BFS with adjacency matrix: O(V^2) // With an adjacency matrix void BFS(int start) { // A vertex is not visited more than once // Initializing the vector to false at the beginning boolean[] visited = new boolean[v]; Arrays.fill(visited, false); List<Integer> q = new ArrayList<>(); q.add(start); // Set source as visited visited[start] = true; int vis; while (!q.isEmpty()) { vis = q.get(0); // Print the current node System.out.print(vis + \" \"); q.remove(q.get(0)); // For every adjacent vertex to the current vertex for(int i = 0; i < v; i++) { if (adj[vis][i] == 1 && (!visited[i])) { // Push the adjacent node to the queue q.add(i); visited[i] = true; } } } }","title":"Breadth-First Search"},{"location":"dsa-notes/dsa-notes/#depth-first-search","text":"DFS with adjacency list: O(V + E) // With an adjacency list void DFSUtil(int v, boolean visited[]) { // Mark the current node as visited and print it visited[v] = true; System.out.print(v + \" \"); // Recurse for all adjacent vertices Iterator<Integer> i = adj[v].listIterator(); while (i.hasNext()) { int n = i.next(); if (!visited[n]) DFSUtil(n, visited); } } void DFS(int v) { // Mark all the vertices as // not visited(set as // false by default in java) boolean visited[] = new boolean[V]; // Call the recursive helper // function to print DFS // traversal DFSUtil(v, visited); } DFS with adjacency matrix: O(V^2) // With an adjacency matrix static void dfs(int start, boolean[] visited) { // Print the current node System.out.print(start + \" \"); // Set current node as visited visited[start] = true; // For every node of the graph for (int i = 0; i < adj[start].length; i++) { // If some node is adjacent to the current node // and it has not already been visited if (adj[start][i] == 1 && (!visited[i])) { dfs(i, visited); } } }","title":"Depth-First Search"},{"location":"dsa-notes/dsa-notes/#shortest-path","text":"Representing a directed graph Adjacency list space: O(V + E) Adjacency matrix space: O(V^2)","title":"Shortest Path"},{"location":"dsa-notes/dsa-notes/#bellman-ford","text":"Running time: O(EV) Stops after one entire iteration with no changes to estimates Invariant: Let T be a shortest path tree of graph G rooted at source S After iteration j, if u is j hops from s on tree T, then est[u] = distance(s, u) Description: Maintain an estimate of infinity for every node Update estimates with minimum of sum of edges Special issues: If negative weight-cycle: impossible Use Bellman-Ford to detect negative weight cycle (v + 1)th relaxing still changes an estimate If all weights are the same, use BFS void BellmanFord(Graph graph, int src) { int V = graph.V; // number of vertices int E = graph.E; // number of edges int dist[] = new int[V]; // Step 1: Initialize distances from src to all other vertices as INFINITE for (int i = 0; i < V; ++i) { dist[i] = Integer.MAX_VALUE; } dist[src] = 0; // Step 2: For every vertex, visit all edges for (int i = 1; i < V; ++i) { for (int j = 0; j < E; ++j) { // Edge goes from u to v int u = graph.edge[j].src; int v = graph.edge[j].dest; int weight = graph.edge[j].weight; if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) { dist[v] = dist[u] + weight; } } } // Step 3: check for negative-weight cycles. Guarantees shortest distances if graph // doesn't contain negative weight cycle. If we get a shorter path, then there is a cycle. for (int j = 0; j < E; ++j) { int u = graph.edge[j].src; int v = graph.edge[j].dest; int weight = graph.edge[j].weight; if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) { System.out.println(\"Graph contains negative weight cycle\"); return; } } printArr(dist, V); }","title":"Bellman-Ford"},{"location":"dsa-notes/dsa-notes/#dijkstras-algorithm","text":"No negative weight edges Description: Maintain distance estimate for every node Add neighbours and their distances into priority queue Remove node with smallest distance, visit its neighbours Done when priority queue is empty Final node will have its shortest distance static class iPair { int first, second; iPair(int first, int second) { this.first = first; this.second = second; } } void shortestPath(int src, int[][] graph) { // Sets up priority queue that compares distance of nodes, shorter distance first PriorityQueue<iPair> pq = new PriorityQueue<>(V, Comparator.comparingInt(o -> o.second)); int[] dist = new int[V]; Arrays.fill(dist, Integer.MAX_VALUE); pq.add(new iPair(0, src)); dist[src] = 0; while (!pq.isEmpty()) { // u is the value of the node with minimum distance int u = pq.poll().first; // for all neighbour of u for (int[] neighbour : graph[u]) { iPair v = new iPair(neighbour[0], neighbour[1]); int newDistance = dist[u] + v.second; if (dist[v.first] > newDistance) { dist[v.first] = newDistance; pq.add(new iPair(v.first, dist[v.first])); } } } for (int i = 0; i < V; i++) { System.out.println(i + dist[i]); } } Using AVL Tree priority queue Running time: O(E logV) insert: O(logn) deleteMin: O(logn) decreaseKey: O(logn) contains(key): O(1) Performance","title":"Dijkstra's Algorithm"},{"location":"dsa-notes/dsa-notes/#minimum-spanning-trees","text":"A spanning tree with minimum weight Properties: No cycles If you cut an MST, the two pieces are both MSTs For every cycle, the maximum weight edge is not in the MST For every partition of the nodes, the minimum weight edge across the cut is in the MST For every vertex, the minimum outgoing edge is always in the MST (not true for maximum)","title":"Minimum Spanning Trees"},{"location":"dsa-notes/dsa-notes/#prims-algorithm","text":"Continually pick the smallest edge of every node visited Using AVL tree for priority queue: Running time: O(E log V) class Pair implements Comparable<Pair> { int v; int wt; Pair(int v, int wt) { this.v = v; this.wt = wt; } public int compareTo(Pair that) { return this.wt - that.wt; } } static int spanningTree(int V, int E, int edges[][]) { ArrayList<ArrayList<Pair>> adj = new ArrayList<>(); for(int i = 0; i < V; i++) { adj.add(new ArrayList<Pair>()); } for(int i = 0; i < edges.length; i++) { int u = edges[i][0]; // from node u int v = edges[i][1]; // to node v int wt = edges[i][2]; // of weight wt // Add all edges into adj adj.get(u).add(new Pair(v,wt)); adj.get(v).add(new Pair(u,wt)); } PriorityQueue<Pair> pq = new PriorityQueue<Pair>(); pq.add(new Pair(0,0)); int[] vis = new int[V]; int s = 0; while (!pq.isEmpty()) { Pair node = pq.poll(); int v = node.v; // curr node's value int wt = node.wt; // curr node's weight if (vis[v] == 1) { continue; // if node is visited, skip } // node was not visited before s += wt; vis[v] = 1; for(Pair it : adj.get(v)) { if(vis[it.v] == 0) { pq.add(new Pair(it.v, it.wt)); } } } return s; }","title":"Prim's Algorithm"},{"location":"dsa-notes/dsa-notes/#kruskals-algorithm","text":"Sort all edges by weight, take all the minimum edges as long as there are no cycles Running time: O(E logV) static class Subset { int parent, rank; public Subset(int parent, int rank) { this.parent = parent; this.rank = rank; } } static class Edge { int src, dest, weight; public Edge(int src, int dest, int weight) { this.src = src; this.dest = dest; this.weight = weight; } } private static int findRoot(Subset[] subsets, int i) { if (subsets[i].parent == i) { return subsets[i].parent; } subsets[i].parent = findRoot(subsets, subsets[i].parent); return subsets[i].parent; } private static void union(Subset[] subsets, int x, int y) { int rootX = findRoot(subsets, x); int rootY = findRoot(subsets, y); if (subsets[rootY].rank < subsets[rootX].rank) { subsets[rootY].parent = rootX; } else if (subsets[rootX].rank < subsets[rootY].rank) { subsets[rootX].parent = rootY; } else { subsets[rootY].parent = rootX; subsets[rootX].rank++; } } private static void kruskals(int V, List<Edge> edges) { int j = 0; int noOfEdges = 0; Subset subsets[] = new Subset[V]; Edge results[] = new Edge[V]; // Create V subsets with single elements for (int i = 0; i < V; i++) { subsets[i] = new Subset(i, 0); } while (noOfEdges < V - 1) { // Edges are sorted in ascending order // Pick the smallest edge Edge nextEdge = edges.get(j); int x = findRoot(subsets, nextEdge.src); int y = findRoot(subsets, nextEdge.dest); // If cycle, root is the same if (x != y) { results[noOfEdges] = nextEdge; union(subsets, x, y); noOfEdges++; } j++; } int minCost = 0; for (int i = 0; i < noOfEdges; i++) { System.out.println(results[i].src + \" -- \" + results[i].dest + \" == \" + results[i].weight); minCost += results[i].weight; } System.out.println(\"Total cost of MST: \" + minCost); }","title":"Kruskal's Algorithm"},{"location":"dsa-notes/dsa-notes/#dynamic-programming","text":"Bottom up Solve smallest problems Combine smaller problems Solve root problem Top down Start at root and recurse Recurse Solve and memoize","title":"Dynamic Programming"},{"location":"dsa-notes/dsa-notes/#topological-sort","text":"Using DFS to find cycles and add to stack Verifies if the graph given is a directed acyclic graph (DAG) class Solution { HashMap<Integer, LinkedList<Integer>> adj = new HashMap<>(); HashMap<Integer, Boolean> visited = new HashMap<>(); Stack<Integer> stack = new Stack<>(); boolean isImpossible = false; public void addEdge(int v, int w) { adj.putIfAbsent(v, new LinkedList<>()); adj.putIfAbsent(w, new LinkedList<>()); adj.get(v).add(w); } private void dfsHelper(Integer v, HashMap<Integer, Boolean> visited1) { visited.put(v, true); visited1.put(v, true); // Traverse neighbours for (Integer i: adj.get(v)) { if (visited1.containsKey(i)) { isImpossible = true; // there is a cycle break; } if (!visited.get(i)) { dfsHelper(i, visited1); } } visited1.remove(v); stack.push(v); } public int[] findOrder(int numCourses, int[][] prerequisites) { int[] res = new int[numCourses]; Arrays.setAll(res, i -> i); if (prerequisites.length == 0) { return res; } // Add all edges into graph adj for (int[] prerequisite : prerequisites) { addEdge(prerequisite[1], prerequisite[0]); } // Set all keys to visited = false for (Integer key: adj.keySet()) { visited.put(key, false); } // Start DFS for (Integer key: adj.keySet()) { HashMap<Integer, Boolean> visited1 = new HashMap<>(); if (visited.get(key) == false) { dfsHelper(key, visited1); } } if (isImpossible) { return new int[0]; } HashMap<Integer, Integer> hm = new HashMap<>(); for (int i = 0; i < numCourses; i++) { hm.put(i, i); } // Add sorted courses into array int n = stack.size(); for (int i = 0; i < n; i++) { int course = stack.pop(); res[i] = course; hm.remove(course); } // Fill in the rest of the array with the missing courses int[] left = hm.keySet().stream().mapToInt(Integer::intValue).toArray(); int i1 = 0; int i2 = n; while (i1 < left.length && n < numCourses) { res[i2] = left[i1]; i1++; i2++; } return res; } }","title":"Topological Sort"},{"location":"unc-psyc101/unc-psyc101-notes/","text":"1: Evolution of Psychology History of Psychology 2: Research Methods What is Research Scientific Method Experiments Research Challenges 3: Biological Bases Terms Types of neural signals Neurotransmitters Common Neurotransmitters Organization of Nervous System Methods to Study Brain Development of Nervous System Brain Physiology and Anatomy Hereditary studies The Evolutionary Bases of Behavior 4. Sensation and Perception Visual System Visual Pathway Theories of Color Perceiving Form Auditory System Vestibular System Gustatory System Olfactory System Somatosensory System 5. Variations in Consciousness Behavioral/ Psychological Description of sleep Sleep Factors Correlated with Sleeping Pattern Effects of Sleep Deprivation Effects of Sleep Sleep Disorders Hypnosis Meditation Drugs 6. Learning Classical Conditioning (Pavlovian Conditioning) History Terms Acquisition Extinction Stimulus Generalization and Discrimination Higher-order Conditioning Biological Influence on Conditioning Operant Conditioning (Instrumental Learning) History Terms Acquisition Extinction Stimulus Generalization and Discrimination Reinforcements Biological Influence on Conditioning Cognition in Classical \\& Operant Conditioning Observational Learning (modeling) History Terms 7. Memory Encoding Storage Amnesias Knowledge \\& Memory Retrieval Forgetting Memory Trace: Physiology of Memory 10. Human Development Physical Conception Stages of prenatal development Teratogens (environmental agents which can cause developmental malformations) Postnatal development Emotional Language Personality Cognitive Moral Major events Death 11. Personality Psychodynamic perspective Neopsychodynamic views of personality development Behavioral perspective Humanistic perspective Biological perspective 12. Social Psychology Person perception Attribution Interpersonal attraction Attitudes Social influence on behavior Behavior in groups 1: Evolution of Psychology History of Psychology Philosophy (Descartes): Using the ability to reason Physiology (Helmholtz): Using scientific method Significant contributors Wilhem Wundt (founder of psychology) First psychology laboratory, in Europe, 1879 Reaction-time studies Edward Titchener Structuralism: various components to everything (cannot exist by itself) William James Functionalism: adaptiveness and evolution Established 1st psyc textbook, Principles of Psychology Stanley Hall Functionalism Established 1st psyc laboratory in US Sigmund Freud Psychoanalysis theory Unconscious: knowledge gained from working with patients were significant, results of his experimental research not significant John B Watson Behaviorism Overt behavior & environmental factors: behaviors can be taught Facilitated an increase in using animals for research: researcher can exert more control over animals B.F. Skinner Behaviorism Acknowledged biological factors & internal factors, but were considered to be unnecessary to understand/control behavior Free will as an illusion Carl Rogers & Abraham Maslow Humanism: emphasize unique qualities of being human Self-concept/ incongruence, pyramid of needs Noam Chomsky (language) George Miller (memory) Herbert Simon (problem-solving) Roger Sperry (biological bases of behavior) 2: Research Methods What is Research Process of gaining information in order to come to a conclusion Goals Measurement and description Understanding and prediction Application and control Guiding principles Rationalism Empiricism: taking observations through senses and forming conclusions Scientific Method Get to know topic Observation (direct or indirect) Formulate a hypothesis To be stated in terms of an operational definition Design the study Quasi-experiment: looks like an experiment, but independent variable has not been manipulated by experimenter Non-experiment: naturalistic observation, case studies, surveys Experiment: can make causal conclusions Ethics should be considered Collect the data Analyze the data: draw conclusions Descriptive statistics Central tendency (mean, median, mode) Correlation (r = .2: negligible, .5: moderate, .8: very strong, 1: perfect) Inferential statistics (chi-test, F-test), used to tell probability that results were due to chance Report the findings Experiments To determine causality Manipulate a variable, hold all other variables steady Random assignment: decreases chances that your groups differ from one another before the manipulation Extraneous variables: variables which may influence results though you are not interested in the effects (factor has been \"controlled for\") Confounding variables: variables that influences results and make them unclear Research Challenges Sampling bias (size) Experimenter expectation/ bias Participant expectation/ bias Single-blind & double-blind studies 3: Biological Bases Terms Soma: body of the cell which contains all organelles Oligo (small/ a few) + dendro (tree-like branches) Myelin sheath: insulating layer, or sheath that forms around nerves; allows electrical impulses to transmit quickly along the nerve cells Glia (\"glue\" of the brain) Oligodendrocytes (CNS): one cell can create several segments of myelin sheath and cover more than one axon Schwann cells (PNS): one cell creates only one segment of myelin sheath for only one axon Astrocytes: synchronizes communication between neurons, nurtures cells, and removes waste products Microglia: functions as part of immune system, removes waste products and invaders Radial glia: guides migration and growth of immature neurons Types of neural signals Synapses Axo-dendritic: connection formed between the axon of one neuron and the dendrite of another Axo-somatic: axon-soma Axo-axonic: axon-axon Action potential (electric & chemical signal in axon) \"all or none\" Threshold of excitation must be met to fire an action potential Refractory period - interval of time during which a second action potential can be initiated Absolute: no matter how large stimulus is applied Relative: depends on stimulus size Excitatory postsynaptic potential (EPSP) & inhibitory postsynaptive potential (IPSP) Electrical and chemical signals Only if EPSP > IPSP and reach threshold of excitation, then action potential in the 2nd neuron Neurotransmitters At terminal buttons, there are vesicles full of chemicals called neurotransmitters When action potential reaches the terminal buttons, exocytosis is triggered to occur (where the neurotransmitter is released from the vesicle) Neurotransmitter diffuses across synapse from presynaptic neuron to postsynaptic neuron Neurotransmitter finds receptors that it matches and binds to \"binding site\" of receptor Binding causes either an excitatory postsynaptic potential or inhibitory postsynaptic potential Neurotransmitter unbinds from receptor and reuptake/ enzymatic degradation occurs Common Neurotransmitters Agonist (increases activity) vs. antagonist (decreases activity) GABA (inhibitory) vs glutamate (excitatory) Acetylcholine/ ach/ cholinergic Binds with PNS: muscle contractions Binds with CNS: arousal, attention, learning Monoamine -> catecholamine Dopamine/ DA Binds with CNS: movmenets, addictions, mood Norepinephrine/ NE Binds with CNS: mood, arousal Epinephrine/ Epi/ adrenergic (works on adrenaline) Binds with PNS: cardiac contraction Binds with CNS: mood Monoamine -> indolamine Serotonin/ 5-HT/ serotonergic Binds with CNS: sleep/ arousal, mood, eating, aggression, impulsivity Endorphins (endogenous + morphine) Type of neuropeptide to modulate pain Organization of Nervous System CNS: central nervous system (spinal cord) PNS: peripheral nervous system; lies outside brain and spinal cord Afferent: \"approaching\" the brain Efferent: \"exiting\" the brain Methods to Study Brain Lesioning (controlled damage) Via knife cut, electrolytic lesion Stimulation Via electrical stimulation, transcranial magnetic stimulation, chemical stimulation Brain imaging Tools which give structural information: CT scan, MRI Tools which give functional information: PET scan (measures blood flow) Tools which give both: fMRI (measures blood flow and oxygen) Development of Nervous System Neural tube development (~24 days) Neural tube defect: spina bifida, anecephaly Advised to take folic acid which is in prenatal vitamins Neural tube continues to swell and grow Forebrain, mid brain, hindbrain and hollow center Telencephalon, diencephalon, mesencephalon (midbrain), metencephalon, myelencephalon (medulla) Telencephalon grows so much Ventricles and central spinal fluid (CSF) Hollow areas filled with fluid CSF Cushions the brain inside and out Brain Physiology and Anatomy Medial and lower in the brain -> primitive/ vital functions Higher and outer areas of brain -> highest level of brain functions Hindbrain (very base of the brain) medulla (connection between the brainstem and the spinal cord) - pons (relay signal below neck) cerebellum (controls balance for walking and standing, and other complex motor functions) reticular formation (major integration and relay center for many vital brain systems) ascending fibers: wakefulness/sleep descending fibers: motor movement aka reticular activating system Midbrain visual information: superior colliculi auditory information: inferior colliculi DA-producing neurons: substantia nigra periaqueductal gray: area of brain involved with modulation of pain perception. For example, opioids can be released in this area and this leads to decreased perception of pain. periaqueductal gray: area of brain involved with modulation of pain perception reticular formation Forebrain cerebral hemispheres corpus callosum split-brain research thalamus \"sensory relay station\" since all sensory information goes here before going to primary cortices, exception: olfactory hypothalamus controls pituitary in endocrine system which releases oxytocin to help women give birth and bond emotional limbic system network of different brain structures cerebral cortex (known as gray matter) higher mental functions are done sulcus/ sulci: a groove gyri: bump or ridge fissure: deep groove occipital lobe: houses primary visual cortex temporal lobe: houses primary auditory cortex parietal lobe: houses primary somatosensory cortex frontal lobe: houses primary motor cortex + mirror neurons + prefrontal lobe (executive functions) Hereditary studies Three ways to estimate heritability: Family studies flaw: families do not share just genes, but also environment Twin studies flaw: the assumption that MZ and DZ twins only differ in terms of genes may be invalid; it\u2019s possible that they experience different environments as well Adoption studies twin adoption study method: gather MZ & DZ twins who have been reared apart; compare concordance rate (of the target behavior) between the MZ & DZ twins flaw: sample sizes tend to be too small (esp. with the twin adoption study method) flaw: separating the twins does not ensure that they experience dissimilar environments (e.g., again, if they look alike, they may evoke the same social environment) Epigenetics (heriditary changes in the characteristics of a cell or organism that result from altered gene expression or other effects not involving changes to the DNA sequence itself) marks can be passed down generations The Evolutionary Bases of Behavior Darwin: traits which provide either survival advantage or reproductive advantage are much more likely to be \u201cselected\u201d over time (via natural selection) Behavioral traits are subject to natural selection as well Population vs. individual organisms 4. Sensation and Perception Visual System Stimulus: electromagnetic radiation between 480nm - 760nm Properties: wavelength, amplitude, purity (saturation) Anatomy & physiology of the eye Cornea -> pupil/ iris -> lens -> vitreous humor -> retina (bipolar cells -> ganglion cells -> photoreceptors, rods and cones) Transduction: process by which a stimulus is represented neurally Photoreceptors Rods Cones Scotopic Photopic Perceives general form (not detail) Greater visual acuity More numerous than cones Less numerous than rods More in the periphery of the retina More in center of retina and there are only cones in the fovea More thoroughly adapts to the dark Quickly adapts to the dark, but is limited in how much it adapts Receptive field: portion of the visual field which a neuron \"monitors\" Visual Pathway After light is transduced by cones/ rods, visual information processed: Bipolar cells Ganglion cells Optic disk (has optic nerves to transfer signals to the brain) Information received by the halves of the retina closer to the nose crosses to the other side of the brain to form the optic chiasm (contralateral connection) dorsal lateral geniculate nucleus of the thalamus primary visual cortex (in occipital lobe) aka V1 aka striate cortex Information received by the halves of the retina farthest from the nose stays on the same side of the brain (ipsilateral connection) dorsal lateral geniculate nucleus of the thalamus primary visual cortex (in occipital lobe) aka V1 aka striate cortex In the primary visual cortex Simple cells: detect orientation of line and location of the line within its receptive field Complex cells: detect orientation of line, movement of line Visual information goes to the WHAT pathway: lower part of temporal lobe, analyzes what the object is WHERE pathway: parietal lobe, analyzes where the object is Theories of Color Trichromatic theory (proposed by Young, refined by Helmholtz) Brain detects 3 main colors, and variations of them will give colors of the rainbow Opponent process theory (proposed by Hering) Neurons that can communicate to the brain that can see one color at one time (seeing one color takes opposing or opposite actions, cannot have two at the same time) Explains complementary afterimages (rebound effect: staring at a waterfall will make things look like they are elevated) Perceiving Form Bottom-up processing (aka feature detection) Basic visual information are compiled so that visual cortical cells Top-down processing (information is taken as a \"whole\") See structure and patterns in order for us to better understand the environment Gestalt principles: similarity, continuation, closure, proximity, figure/ground, and symmetry & order Stroop effect: naming color when spelt another color (interference of the processes) Depth perception Monocular cues: accomodation of one eye Binocular cues: retinal disparaity used to calculate depth; slight difference in images received by each eye due to horizontal separation Auditory System Stimulus: sound (compression and decompression of molecules) Properties: wavelength, amplitude, purity (timbre, quality of sound) Anatomy of ear: Outer ear (ear canal/ pinna) -> middle ear (ear drum/ tympanic membrane -> ossicles) -> inner eat (oval window of cochlea) Cochlea 3 canals: in the middle canal is the basiclar membrane (with auditory hair cells) Vibration moves the fluid, and basilar membrane moves Auditory hair cells fire action potential Place theory Different waveforms stimulate different areas of the basilar membrane Higher frequencies stimulate basilar membrane areas closest to oval window, vice-versa Frequency theory Basilar membrane mimics the sound waveform Neurons at the end of the basilar membrane fire in synchrony with waveform Vestibular System Sense of balance Stimulus: gravitational pull Anatomy of vestibular system Located in inner ear near the cochlea Has semiciruclar canals and vestibular sacs Gustatory System Stimulus: molecules dissolved in fluid Anatomy of tongue: Papillae = bumps Taste buds (many on sides of papillae) Primary cortex: insular cortex in frontal lobe Olfactory System Stimulus: molecules in air Anatomy of nose: Air -> mucous -> olfactory dedrites (transduction occurs) Primary cortex: olfactory bulb (temporal lobe) Somatosensory System Stimulus: mechanical, thermal, chemical Anatomical system involed: nerves in th ebody Mechanoreceptors: ruffini endings, merkel\u2019s discs, pacinian corpuscles, meissner\u2019s corpuscle, hair shaft sensory receptor Nociceptors: free nerve endings Thermoreceptors Proprioceptors Pain Stimulus: something noxious or damaging to tissues (exception: some forms of chronic pain) Anatomy of pain system: noniceptors C fibers: slow pathway (e.g., dull, aching) A-delta fibers: fast pathway (e.g., sharp pain of a knife cut) Gate control theory by Melzack and Wall (theory of how we modulate pain) Triggers: central nervous system (brain can send stimulation to close pain gates) Peripheral nervous system (rubbing area around an injury works, because other sematosensory nerves are stimulated in that area, synapses - pain & rubbing - compete to get to the spinal cord, stopping pain) 5. Variations in Consciousness Behavioral/ Psychological Description of sleep Alert/ Awake Beta waves 13 - 24 cycles per second Relaxed, drowsy Alpha waves 8 - 12 cycles per second Stage 1 Theta waves 4 - 7 cycles per second Stage 2 Theta waves 4 - 7 cycles per second Stage 3: slow wave sleep (SWS) 0 - 49% delta waves <4 cycles per second Stage 4: slow wave sleep (SWS) Above 50% delta waves <4 cycles per second REM High frequency, low amplitude waves Beta waves, some alpha waves Sleep What drives sleepiness Metabolic processes (mostly active brain) Circadian rhythm Circadian rhythm Regulated by suprachiasmatic nuclues (hypothalamus) SCN -> pineal gland -> melatonin -> increase sleepiness Can be entrained by light Factors Correlated with Sleeping Pattern Age Infants: greater total sleep and amount of REM (50%, compared to 20% in adults) More than 70: 50% decrease in SWS, slight decrease in REM Genetics/ biology Cultural variations Effects of Sleep Deprivation Complete deprivation: weariness, irritability, paranois, lapses in attention, memory deficits, hallucinations Partial/ restricted deprivation: inconsistent effects, increased sleepiness, impairments of attention, reaction time, motor coordination, decision making, endocrine and immune system function Correlated with increased accidents and higher rates of physical issues Rebound effects of selective REM and SWS deprivation (brain will increasingly insist on sleep stage when deprived) Mortality rate and sleep amounts correlated (greatest mortality when sleep is less than 7h and more than 9h) Effects of Sleep Cognitive: brain development IQ Memory consolidation Insights during REM Energy conservation Marine mammals have the ability to sleep halfway Restore bodily resources Dreams Adults: focused on self Sex, aggression, misfortune Content of waking life spill into dreams (Frued's \"day residue\") Children: more static than storyline Theories of purposes: Frued: wish fulfillment R. Cartwright: problem-solving/ mood-regulation view Hobson: activation-synthesis model Sleep Disorders Hypersomnia: excessive sleepiness for at least 1 month TX: stimulants Insomnia: difficulty initiating or maintain sleep for at least 1 month More common in women, increase with age, variety of negative health conditions correlated TX: teach good sleep hygiene, relaxation training, benzodiazepines, non-benzodiazepines (e.g. Ambien, Sonata, Lunesta), melatonin Narcolepsy: irresistable attacks of refreshing sleep that occur daily over at least 3 months Presence of one or more of: Cataplexy: brief loss of voluntary muscle tone triggered by strong emotions Hypnogogic: Occur when you're falling asleep Hypnopompic hallucinations: Occur when you're waking up Sleep paralysis TX: stimulants, SSRIs Sleep apnea: breathing stops randomly ~10sec/ 10-15 min per hour of sleep Associated to obesity and age TX: CPAP, lifestyle modifications, upper airway and craniofacial surgery Somnambulism: sleep walking REM sleep behavior disorder: Being chased or attacked in dreams Deterioration of brain stem May precede Parkinson's up to 10 years Hypnosis Systematic procedure that typically produces a heightened state of suggestibility Associative features Anesthesia Sensory distortions/ hallucinations Disinhibition Post hypnotic suggestions and amnesia may occur Hilgard's dissociative theory: hypnotic induction is said to split the functioning of the executive control system (ECS) into different streams Highway hypnosis: altered mental state in which an automobile driver can drive lengthy distances and respond adequately to external events with no recollection of consciously having done so Meditation Practices that train attention to heighten awareness and bring mental processes under greater voluntary control Transcendental meditation: focused attention Mindfulness meditation: open monitoring Associative features EEG: increase in alpha and theta waves Transcendant experience is not equal to relaxation Correlated with: decrease stress, anxiety, BP; increase immune function, mood, self-esteem, overall health and well-being Decreased parietal lobe activity (where somatosensory system resides) Increased left prefrontal lobe activity Drugs Narcotics E.g. morphine, heroin, oxycodone, codeine, methadone Effects: anxiety reduction, pain relief, drowsiness impaired mental & motor functioning constipation withdrawal: severe diarrhea, increase in infectious diseases used for: analgesic, cough, diarrhea Sedatives: CNS depressants E.g. barbiturates, benzodiazepines Effects: relaxation, anxiety, increased drowsiness quick tolerance/medication backfires impaired mental & physical functioning increased risk of accidents synergistic effect with alcohol withdrawal can be potentially dangerous used for anxiety, sleeping issues Stimulants: increase CNS activity E.g. caffeine, nicotine, cocaine/crack, amphetamines/crank/crystal meth, MDMA (low doses; in high doses, MDMA can have hallucinogenic effects) Effects: euphoria increased energy, alertness, CV arousal and/or CV problems, panic, insomnia, sweating/urination psychosis: when people lose some contact with reality (e.g., cocaine, amphetamines) decreased appetite (cocaine, for example): damaged nasal membranes, increased CV and respiratory problems used for narcolepsy, ADHD (methylphenidate), local anesthetic (cocaine) Hallucinogens: small amount alters sensory/perception E.g. LSD, mescaline (peyote), psilocybin (mushroom), MDMA too (\u201cecstasy\u201d), though in larger dose Effects: euphoria, distortions in sensory & perceptual experiences (e.g., mystical experiences) anxiety, paranoia (\u201cbad trip\u201d) kills 5-HT neurons impaired judgment \u2192 \u2191 risk of accidents Cannabis E.g. marijuana, hashish, THC (Tetrahydrocannabinol, a cannabinoid found in cannabis) Effects: mild euphoria, relaxation, sensory/perceptual distortions (e.g., \u201cslowing of time,\u201d vivid perceptions), increased hunger, esp. for sweets short-term memory impairments, metabolizes slowly decreased IQ in young users persistent memory issues in middle aged users (even after stopping use) increased accident risk used for: TX of nausea & pain, e.g., cancer, glaucoma (ethyl) Alcohol Effects: mild euphoria, relaxation, mood swings, quarrelsomeness 90% student rapes, 95% on violent crimes on campus impairments of cognitive & motor function 21% unplanned sex, 50% fatal vehicle accidents (according to some sources) , ~40% fatal bicycle accidents liver damage (cirrhosis, which is scarring), hypertension, stroke, other heart diseases, neurological issues (e.g., Korsakoff\u2019s syndrome), Korsakoff symptoms include severe memory problems, apathy, walking problems, etc., cancers increased risk of death in general - males: 2x increased mortality, females: 4x increased mortality withdrawal could be fatal delirium tremens\u2014can be fatal in some cases is characterized by \u201cthe shakes\u201d as well as by symptoms of delirium, which include cognitive deficits, changes in CNS arousal, and psychotic features like hallucinations & delusions a standard drink has 0.6 oz. of alcohol 6. Learning Learning refers to the change in a person's behavior to a given situation brought about by repeated experiences in that situation, provided the behavior change cannot be explained on the basis of native response tendencies, maturation, or temporary states of the subject Classical Conditioning (Pavlovian Conditioning) History Pavlov & psychic reflexes demonstration Terms Unconditioned stimulus (US or UCS) naturally elicits a response Unconditioned response (UR) natural response to US Conditioned stimulus (CS) a previously neutral stimulus which, after pairings with a US, attains the ability to elicit the same response Conditioned response (CR) the response to the CS (which looks like the UR, at least on the surface, and not in all cases) Acquisition stimulus contiguity simultaneous presentation (of UCS & CS) tone & meat are presented and ended at same time short-delayed presentation tone begins shortly before meat tone & meat end at same time trace presentation tone is presented & ended right before the meat is presented then ended saliency of stimulus stimulus which is most noticeable is more likely a good potential CS Extinction Weaking asociation by presenting CS without UCS Spontaneous recovery (after a period of non-exposure to CS) Renewal effect (after re-exposure to environment where learning ocurred) Stimulus Generalization and Discrimination Stimulus generalization: when a person generalizes what they have learned from a specific CS to other stimuli which are similar to the original CS e.g., if you have been classically conditioned to be scared of Bozo and then are later scared of all clowns Stimulus discrimination: when a person does NOT generalize what they have learned from a specific CS to other stimuli which are similar to the original CS e.g., if you have been classically conditioned to be scared of Bozo but are not scared of other clowns (so you are discriminating between Bozo and the other clowns) Higher-order Conditioning When a CS functions as a UCS Example: A makes you happy, B provides A so B makes you happy (1st order), C provides B provides A so C makes you happy (2nd order) Biological Influence on Conditioning Conditioned taste aversion one trial extended delay between CS & US presentation food stimuli-nausea associations are likely Evolutionarily adaptative CS: ecologically relevant vs. arbitrary, neutral stimulus Operant Conditioning (Instrumental Learning) History B.F. Skinner (1904 \u2013 1990): demonstrated that organisms repeat those responses that are followed by favorable consequences and organisms tend not to repeat those responses that are followed by negative and/or neutral consequence Skinner box Reinforcement contingencies Cumulative recorder Terms reinforcement: consequence that increases tendency to repeat preceding behavior positive reinforcement: adding something into the situation that increases the tendency to repeat the preceding behavior negative reinforcement: taking something away from the situation that increases the tendency to repeat the preceding behavior punishment: consequence that \u2193 tendency to repeat preceding behavior (positive) punishment: adding something into the situation that decreases the tendency to repeat the preceding behavior (negative) punishment: taking something out of the situation that decreases the tendency to repeat the preceding behavior Acquisition When the connection between the behavior and a consequence is \"aquired\" Shaping: reinforcements fo closer and closer approximations of a desired response Extinction Process where the usual consequence does not follow the emitted behavior Resistance to extinction Renewal effect Stimulus Generalization and Discrimination stimulus generalization: hold onto the association between the stimulus (and alike) and consequence stimulus discrimination: only associate the stimulus (specifically only that stimulus) and consequence Reinforcements Primary reinforcers are those which directly satisfy our biological needs Secondary reinforcers are those which are associated with primary reinforcements (e.g. money) Schedules of Reinforcements continuous reinforcement reinforcement after every single target behavior intermittent reinforcement fixed-ratio schedule reinforcement is given based on a fixed number of responses (e.g., every third response) variable-ratio schedule reinforcement is given based on an average number of responses (e.g., reinforcement is given, on average, 4 responses) fixed-interval schedule reinforcement is given based on the first response given after a fixed amount of time has passed (e.g., reinforcement is given if a rat pulls a lever after 4 seconds have passed) variable-interval schedule reinforcement is given based on the first response given after an average amount of time has passed (e.g., reinforcement is given if a rat pulls a level, on average, after 3 seconds have passed) Special issue concerning positive punishment e.g., corporeal punishment poor-quality parent-child relationship, e.g. increased aggression, delinquency, behavior problems. Long term effects: associated with slowed cognitive development, increased criminal behavior, range of mental health issues (cited in Weiten) correlational data; however, strong evidence for a causal relationship Biological Influence on Conditioning Instinctive drift Operant conditioning is not always successful Operant conditioning which tries to go against natural instinct usually fails Preparedness and Phobias Classical conditioning and operant conditioning are often used together, e.g. phobias classical conditioning establishes the phobia operant conditioning maintains the phobia behavior of avoiding = decreased anxiety = reinforcing = increased likelihood that person will avoid the object of anxiety Cognition in Classical & Operant Conditioning Latent Learning & Cognitive Maps (Edward Tolman, 1930s & 1940s) 1st group: reinforcement was given after every trial (through a maze) -> steadily improved 2nd group: no reinforcements were given -> little improvement 3rd group: reinforcements were given after the 10th trial onward -> sharply improved behavior => learning can take place without reinforcement mental representation of a map is possible Signal Relations - predictive value of conditioned stimulus (Robert Rescorla, 1970s & 1980s) 1st group: a tone signaled a shock every single time -> strong response 2nd group: a tone signaled a shock only half of the time -> weaker response somewhere in the organism\u2019s mind, the predictive value of the environmental cue is being calculated Observational Learning (modeling) History Albert Bandura (1970s, 1980s): suggest that many different cognitive processes could be involved with learning including internal processes which allow one to learn vicariously (so vicarious classical and operant conditioning) Terms cognitive processes which may be involved with this type of learning (attention, retention, reproduction, motivation) 7. Memory Encoding Attention Focusing awareness onto something Divided attention = decreased memory encoding Multi-tasking is really shifting attention between tasks high on impulsivity high on sensation-seeking Levels of processing (\"digesting\" information) Structural encoding (how it looks) Phonemic encoding (how it sounds) Semantic encoding (what it means) Enriching encoding Elaboration Linking stimulus to other information Examples given with a main indolamine Imagery (Paivio's dual-coding theory) Linking verbal and visual cues Retrieval cues Motivation to remember Pay more attention to things that we believe are relevant to us \"Learning styles\" do not exist; \"right/ left brained\" do not exist Storage Sensory memory Duration: ~1/4 second Capacity: large Short-term/ working memory Duration: 10 - 20 seconds/ unlimited with uninterrupted rehearsal Capacity: 7 \u00b1 2 items/ 4 \u00b1 1 items Chunking - creates more room in working memory Capacity may be somewhat flexible (e.g. depending on familiarity/ complexity) Phonological loop (is the speech and sound related component of working memory and holds verbal and auditory information) Episodic buffer (\"workbench\") Working memory capacity (WMC): stable trait, heriditary influence, correlated with IQ Long-term memory Duration: indefinite but not necessarily permanent Capacity: unlimited Recall is critical Retrieval practice Distributed studying Illusions of Competence (e.g. recency effect - items that came last are remembered more easily) Type of long term memory Explicit (things you can talk about) Implicit (procedural memory system: actions, skills, operations) *Moving things from short-term to long-term memory Neurons need time for synaptogenesis (and to build connections) Amnesias Henry Gustav Molaison (H.M.): epileptic patient Could not remember new information (explicit) but could improve on mirror-drawing task (implicit) Semantic dementia (cannot remember the meaning of things) Neocortex of lateral temporal area Types of amnesias Retrograde (forget things before) Anterograde (forget things after) Knowledge & Memory Categories and conceptual hierarchies Schemas Stereotypes are a type of schema Semantic network Retrieval Usually automatic, without much effort/ take conscious effort (e.g. systematic search) Encoding specificity principle Better retrieval cue matches memory -> more likely successful retrieval Reinstate the context: increase chances of retrieval cue to retrieve the memory needed Tip-of-the-tongue phenomena: what comes to mind may be a clue as to the word you are searching for Memory is a reconstruction Loftus: misinformation effect (post-event infromation leads to an alteration of memory) Source monitoring error (make incorrect guess about where the information came from) Forgetting Measuring forgetting = measuring retention Recall: results in a more steep curve Ebbinghaus' Forgetting Curve is particularly steep (b/c they are nonsense words) Recognition: more shallow curve E.g. MCQ questions that serve as a cue for remembering Relearning: even more shallow curve E.g. the less time it takes person to relearn words, the more it indicates the person remembers Reasons for forgetting Ineffective encoding (pseudoforgetting) Never really learnt it Decay Memory traces fade with time Interference Additional information get in the way of remembering other information Amount, complexity and type of information learned affect retention (difficult content = more interference) Proactive: when previously learned information interferes with you learning new information Retroactive: : when newly-learned information interferes with you remembering previous information Retrieval failure Motivated forgetting: Freud - \u201crepressed memories\u201d (where your mind\u2014unconsciously\u2014represses negative events in your unconscious) Motivated forgetting is a controversial idea Memory Trace: Physiology of Memory Neural circuitry of memory Physical changes leading to functional synaptic changes: presynaptic/ postsynaptic Neurogenesis (in the dentate gyrus of the hippocampus) 10. Human Development Physical Conception Egg (23 chromosomes) + sperm (23 chromosomes) Ovulation occurs 2 weeks before menstrual period Ovum lives for 12-24 h Sperm lives for 5-7 days Pregnancy tests Home pregnancy test (urine) Detects human chorionic gonadotropic hormone (HCG) In-clinic pregnancy test (blood) Detects HCG Stages of prenatal development Germinal stage: 0-2 weeks (Zygote) Within 36 hours \u2192 proliferation (refers to the rapid cell division and multiplication) 1 week \u2192 implantation Embryonic stage: 2-8 weeks (Embryo) Recognizably human/ humanoid Cephalocaudal (dev from head to toe) & proximodistal (dev from middle to extremities) Sensitive period of development vital organs are developing most miscarriages happen around this time when errors occur during this time, it can be deadly or very serious 70-80% have \"morning sickness\" Fetal stage: 8-38 weeks (Fetus) 12 weeks: basic structures are completed (though they will continue maturing) Fetus' first movements (called \"quickening\") Placenta has basic parts in place 23-25 weeks: threshold of viability; 24%-72% chance of survival 20-24 weeks birth = 43% neurodevelopmental impairments + 19% sensory deficits at 18-22 months Rest of the weeks: fat deposits/ growth Teratogens (environmental agents which can cause developmental malformations) Maternal malnutrition Increased risk of birth complications & neurological deficits Material stress and emotional Lead to negative hormones which may impact development Increased stillbirth to various disorders Drug exposure e.g. recreational drugs, prescribed drugs, OTC drugs, smoking, alcohol Maternal illness First half of pregnancy: 1-2% risk of birth defects, including scarring of skin, limb defects, eye problems, etc. Second half of pregnancy: probably okay 5 to 21 days before birth: fetus may develop the illness Environmental toxins e.g. radiation exposure, air pollution, flame-retardant materials Fetal origins of adult diseases Prenatal malnutrition & schizophrenia; low birth weight & height disease; bipolar disorder Mental and physical conditions Postnatal development Physical growth is uneven Motor Development 3 mos.: lifts head, chest up with arm support 2.75 mos.: rolls over 5.5 mos.: sits without support 5.75 mos.: stands holding on to something 7.5 mos.: pulls self to stand 9 mos.: cruises (walks holding on to something) 12 mos: walks alone Adolescent growth spurt: next rapid growth Females Males Sometime before growth spurt: secondary sex characteristics Sometime before growth spurt: secondary sex characteristics 9-10 yrs. old: growth spurt 10-12 yrs. old: growth spurt (more intense and longer-lasting than for females) 12-13 yrs. old: puberty (menarche: 1st menstruation) and primary sex characteristics (puberty) 13-14 yrs. old: spermarche (1st ejaculation) and primary sex characteristics (puberty) 14-15 yrs. old: full height 15-16 yrs. old: full height 16 yrs. old: sexual maturation 18 yrs. old: sexual maturation Adulthood: graying hair, thinning/balding decline in sensory/perceptual acuity (e.g. increased farsightedness, loss of hearing) menopause (~51 yrs. old) proportion of fat increases psychological and behavioral factors may be involved with \u201caging well,\u201d not just good genetics (e.g. intelligence, optimism, conscientious, high self-esteem, positive emotions, nutritious diet, exercise, avoiding smoking and substance abuse, regular medical checkups, SLEEP) Emotional Smiling & laughter (~4-6 weeks) One of the first expressions of pleasure Fear ~3 months: wariness, sober stares ~6 months: distress; whimpering; looking away ~7 months: true fear, crying ~14-18 months: separation anxiety peaks Early attachment styles attachment styles in the US secure attachment (60-65%) anxious/ambivalent aka resistant attachment (10-15%) avoidant attachment (20%) disorganized/disorientated attachment (5-10%) Ainsworth Strange Situation: psychological experiment that measures the attachment between an infant and their primary caregiver culture separation anxiety proportion of those who fall into the different types of attachment may vary; economic circumstances may be contributing factor parental style sensitive care \u2192 secure insensitive care (e.g. feeding baby when baby is not hungry) \u2192 avoidant inconsistent care \u2192 anxious/ambivalent aka resistant severe neglect and/or abuse \u2192 disorganized/disoriented Language 1-5 mos.: reflexive communication; cooing 6-18 mos.: babbling 10-13 mos.: first words 12-18 mos.: one word sentences receptive vs. productive vocabulary (understanding more than you can say) overextension (using the same word for different situations) underextension 18-24 mos.: vocabulary spurt & fast mapping towards end of 2 yrs: telegraphic speech (not universal) towards end of 3 yrs.: overregularizations 5 yrs.+: well-developed and complex grammar Personality Biological: genetics & traits/predispositions Psychoanalytic: personality arises as we resolve psychosexual conflicts Neopsychoanalytic (proposed by those who followed Freud, then rejected some of his ideas, and developed their own): personality arises as we resolve psychosocial conflicts Learning/behavioral: personality is a collection of behavioral tendencies/habits Humanistic: people have innate drive to become who they were meant to be Cognitive Jean Piaget: cognitive development inferred that certain cognitive skills were not present until a certain age Vygotsky\u2019s sociocultural theory social interaction is very important for cognitive development whereas Piaget felt cognitive development was due to maturation language acquisition is vital for cognitive development private speech Piaget felt that language acquisition was just a part of cognitive development, not necessarily crucial for it (Williams Syndrome) Teenage brain increased myelination + increased synaptic pruning later maturation of prefrontal cortex early development of subcortical DA/reward system leads to impulsive behavior with decreased inhibition Adults loss of neurons (mostly normal!) + shrinkage of active neurons (mostly after 60) later adulthood: senility/dementia is not normal 85 yrs. + = 33% with dementia 70% = Alzheimer\u2019s disease (memory problems > executive function problems > death in approximately 8-10 yrs.) Genetics may account for 70% of variance? Chronic inflammation associated with increased risk. exercise + cognitive activities, active social activities, decreased cardiovascular disease (CVD) risk, no history of smoking or diabetes, diet low in meats, sweets and high-fat dairy are correlated with \u2193 risk of dementia Nun study suggests high prevalence of positive emotions too memory: fairly stable memory and/or cognition but research is mixed \u2193 episodic memory, in particular problem-solving seems okay if adequate time is given (for the slower brain) speed of processing slows down people who have mentally demanding jobs and/or continue to engage in intellectually challenging activities seem to buffer against cognitive decline programs to increase mental activity have met with mixed results Moral Kohlberg\u2019s moral development theory Major events Search for identity (adolescence) lifetime \u2013 research shows that the search for identity doesn\u2019t just occur during adolescence but occurs throughout a lifetime, from time to time and this is healthy Marcia\u2019s theory of identity statuses: Jeffrey Arnett\u2019s emerging adulthood (18 \u2013 29 yrs.) not adolescent/not adult, possibilities/optimism, self-focused time, continued identity search Marriage: delaying marriage (later 20\u2019s, 30s) (careers, educational requirements, autonomy) 90% still marry 8-14% distressed when transitioning (balancing responsibilities, e.g. work and financial concerns) cohabitation (66% now) more common now, correlated with better outcomes now (unlike the past) expectation of roles men doing more housework/childcare but (44%) women still doing majority, even among highly-paid executive women more equitable housework distribution corre. with greater sex and greater sexual satisfaction. 50% end in divorce Parenthood Delaying parenthood (later 20\u2019s, 30s) Majority still have children Marital satisfaction can suffer after having children (esp. as number of children increase) However, factors such as chore distribution and relationship trust, responsiveness and gratitude can influence Adolescents spend less time in family activities and may have increased conflicts, but the conflicts tend to be about everyday matters. Empty Nest Empty nest syndrome: parents get distressed when children leave the house: myth Aging subjective well-being matters! rates of chronic illness increase protective psychological factors: higher intelligence (greater health, longevity) personality traits like optimism, conscientiousness, high self-esteem, positive emotions behavioral habits (e.g. diet and exercise, smoking & drinking, medical checkups) 2/3 of cancers due to poor diet and/or lack of exercise Death K\u00fcbler \u2013Ross Denial Anger Bargaining Depression Acceptance Recent research = no \u201cstages\u201d and these emotions may not be experienced by all Bereavement cultural differences patterns: absent grief/resilient pattern (50%, most common \u2013 but results challenged by other studies), chronic grief, common grief, depressed-improved pattern, chronic depression 11. Personality Unique collection of traits (distinctiveness) Relatively stable across situations and time Traits: internal dispositions or behavioral tendencies Psychodynamic perspective Freud's psychoanalytic theory Structure of personality Id (primary) Reservoir of psychic energy Pleasure principle Ego (secondary) Decision-making Reality principle Superego Moral component, takes awhile to develop Levels of awareness can vary for each of the different components of personality Conscious Preconscious Unconscious Parapraxes (aka Freudian slips): minor errors in speech, memory, or action that are thought to be caused by unconscious wishes, attitudes, or impulses Internal conflict influences behavior Freud's theory of personality development Stage Age Range Focus of Libido Key Developmental Task Fixation Characteristics Oral Stage Birth to 1 year Mouth Sucking, biting, chewing. Primary conflict: weaning. Dependency, smoking, overeating, nail-biting Anal Stage 1 to 3 years Anus Toilet training. Primary conflict: control over bodily functions. Orderliness, stubbornness, messiness, expulsive behaviors Phallic Stage 3 to 6 years Genitals Oedipus/Electra complex (desire for opposite-sex parent). Identification with same-sex parent. Vanity, recklessness, difficulty with authority Latent Stage 6 to puberty None (dormant) Development of communication and intellectual skills, peer relationships. No major fixations, focus on social and cognitive development Genital Stage Puberty onward Genitals Development of mature sexual relationships. Focus on reproduction and emotional intimacy. Healthy relationships, balanced personality Neopsychodynamic views of personality development Jung's analytical psychology personal unconscious vs collective unconscious Alfrd Adler's individual psychology primary motivation = striving for superiority Erik Erikson's stages of psychosocial development Behavioral perspective Skinner's behavioral/ determinism ideas Focus on environmental factors & observable behavior Personality is therefore a collection of unique response tendencies Bandura's contribution of \"cognition\" to this behavioral perspective Mischel and Person-Situation Controversy Personality traits have much less consistency across situations than people think Humanistic perspective Focus on healthy human quality Freedom Innate drive for personal growth Not determined by primitive biological urges Not dominated by unconscious, irrational urges/conflicts Carl Roger\u2019s Person-Centered Theory Self (aka self-concept) If there is incongruence between self-concept & reality \u2192 distress/anxiety Conditional love = \u2191 risk of incongruence Distress/anxiety may lead people to deny/twist reality to protect their self-concept Maslow\u2019s Theory of Self-actualization Unlike Freud, studied people who were thought to be psychological healthy Biological perspective Hans Eysenck\u2019s PEN theory Genes + learning = personality Heavy emphasis on genetics Variations in conditionability (is one example) Three higher-order traits: Psychoticism Extraversion-introversion (Big Five: sociable, lively, active, assertive, sensation-seeking) Neuroticism Research support for heritability of personality traits Identical twins reared together > identical twins reared apart > fraternal twins reared together 12. Social Psychology Person perception Physical appearance People who are taller, normal weight, make eye contact, have good posture, wear nice clothes are physically attractive -> make more favorable impressions Cognitive schemas Humans evolved to use schemas/ stereotypes/ have biases and notice patterns Society teaches stereotypes and biases -> systemic/ institutional bias Persist in using stereotypes: confirmation bias, illusory correlation, difficult to identify and control them Implicit biases affect an infinite variety of behaviors Consequences of stereotypes Could be wrong Lead to biases/ attitudes/ prejudice Which leads to discrimination Which leads to large inequalities between groups of people Out-group homogeneity effect: perception of out-group members as more similar to one another than are in-group members Diversity vs equality vs equity Diversity: makeup of the group Equality: giving everyone same access to resources/opportunities, etc. Equity: achieving equality by making reparations \u2013 in other words, treating people differently, based on need Attribution (Heider): judgment between external vs. internal cause of behavior (Weiner): Internal-Unstable, Internal-Stable, External-Unstable, External-Stable Attributions influence our behaviors: Liberals on poverty: external attribution \u2192 public assistance Conservatives on poverty: internal attribution \u2192 non-supportive of public assistance Biases in the attribution process (actor vs. observer bias) fundamental attribution error (actors favor external attributions; observers favor internal attributions) self-serving bias (actor favor internal attributions for success and external attributions for failures): tendency increases with time Interpersonal attraction Factors influencing this Physical attractiveness (matching hypothesis: married couples are similar) Similarity (couples and friends) Nature of romantic love Hatfield & Berscheid, 1988: passionate (DA may play a role), companionate R. Sternberg, 1988: passionate, commitment, intimacy combination of the components = different types of love consummate love = high on all components level of each component of love changes over time (e.g. passion decreases over time but more gradually and much more modestly than once thought before) Internet and close relationships Virtual relationships can be intimate and evolve to face-to-face relationships Evolutionary perspective - Physical attractiveness indicative of good health, genes, fertility - Facial symmetry: good external and internal developmental environments - Women's waist-to-hip ratio: reproductive potential - Gender differences: men look for youth; women look for ambition, social status - Peri-ovulation/ ovulation: women prefer more masculine features, dominance Attitudes Three components: cognitive, affective, behavioral Three dimensions: strength, accessibility, ambivalence Mediocre predictors of behavior: strength of attitude, situational constraints Formed by learning Classical conditioning: e.g. transferring affective component from an unconditioned stimulus to a conditioned stimulus Operant conditioning: e.g. openly expressing attitude and being reinforced or punished for it Observational learning: e.g. observing how others attitudes can be reinforced or punished Change someone's attitude Source factors: credibility Message factors: using two-sided arguments, fear, repetition Receiver factors: transient factors matter more than personality factors Channel factors: in-person, TV, radio How do attitudes change: (Festinger): cognitive dissonance may lead to attitude change (but not always); e.g. effort justification (Petty & Cacioppo): Elaboration Likelihood Model central/high elaboration route longer-lasting change more resistant to changing better predictor of behavior peripheral/low elaboration route Social influence on behavior Conformity due to group pressure (e.g. Solomon Asch's studies) normative influence (fear of negative social consequences, being liked) information influence (information for ambiguous situations, being right) replicated in other societies with higher numbers of conformity reactance: hoarding toilet paper Obedience: compliance due to direct command Milgram\u2019s Obedience Study: Yale study, over 65% still obedient Behavior in groups Bystander effect Diffusion of responsibility e.g. Kitty Genovese Group productivity and social loafing increased numbers -> decreased productivity reduced efficiency due to loss of coordination AND \u2193 effort due to diffusion of responsibility smaller group size, new groups, non-anonymized contributions, collectivist society = \u2193 social loafing Group polarization groups sometimes take extreme positions after discussion, esp. if there is a slight bias towards a position (Myers & Bishop, 1970): had two groups divided into high- and low- prejudiced groups to discuss racial issues (Janis) Groupthink groups sometimes make poor decisions heavy emphasis on cohesion, direct pressure to conform","title":"Unc psyc101 notes"},{"location":"unc-psyc101/unc-psyc101-notes/#1-evolution-of-psychology","text":"","title":"1: Evolution of Psychology"},{"location":"unc-psyc101/unc-psyc101-notes/#history-of-psychology","text":"Philosophy (Descartes): Using the ability to reason Physiology (Helmholtz): Using scientific method Significant contributors Wilhem Wundt (founder of psychology) First psychology laboratory, in Europe, 1879 Reaction-time studies Edward Titchener Structuralism: various components to everything (cannot exist by itself) William James Functionalism: adaptiveness and evolution Established 1st psyc textbook, Principles of Psychology Stanley Hall Functionalism Established 1st psyc laboratory in US Sigmund Freud Psychoanalysis theory Unconscious: knowledge gained from working with patients were significant, results of his experimental research not significant John B Watson Behaviorism Overt behavior & environmental factors: behaviors can be taught Facilitated an increase in using animals for research: researcher can exert more control over animals B.F. Skinner Behaviorism Acknowledged biological factors & internal factors, but were considered to be unnecessary to understand/control behavior Free will as an illusion Carl Rogers & Abraham Maslow Humanism: emphasize unique qualities of being human Self-concept/ incongruence, pyramid of needs Noam Chomsky (language) George Miller (memory) Herbert Simon (problem-solving) Roger Sperry (biological bases of behavior)","title":"History of Psychology"},{"location":"unc-psyc101/unc-psyc101-notes/#2-research-methods","text":"","title":"2: Research Methods"},{"location":"unc-psyc101/unc-psyc101-notes/#what-is-research","text":"Process of gaining information in order to come to a conclusion Goals Measurement and description Understanding and prediction Application and control Guiding principles Rationalism Empiricism: taking observations through senses and forming conclusions","title":"What is Research"},{"location":"unc-psyc101/unc-psyc101-notes/#scientific-method","text":"Get to know topic Observation (direct or indirect) Formulate a hypothesis To be stated in terms of an operational definition Design the study Quasi-experiment: looks like an experiment, but independent variable has not been manipulated by experimenter Non-experiment: naturalistic observation, case studies, surveys Experiment: can make causal conclusions Ethics should be considered Collect the data Analyze the data: draw conclusions Descriptive statistics Central tendency (mean, median, mode) Correlation (r = .2: negligible, .5: moderate, .8: very strong, 1: perfect) Inferential statistics (chi-test, F-test), used to tell probability that results were due to chance Report the findings","title":"Scientific Method"},{"location":"unc-psyc101/unc-psyc101-notes/#experiments","text":"To determine causality Manipulate a variable, hold all other variables steady Random assignment: decreases chances that your groups differ from one another before the manipulation Extraneous variables: variables which may influence results though you are not interested in the effects (factor has been \"controlled for\") Confounding variables: variables that influences results and make them unclear","title":"Experiments"},{"location":"unc-psyc101/unc-psyc101-notes/#research-challenges","text":"Sampling bias (size) Experimenter expectation/ bias Participant expectation/ bias Single-blind & double-blind studies","title":"Research Challenges"},{"location":"unc-psyc101/unc-psyc101-notes/#3-biological-bases","text":"","title":"3: Biological Bases"},{"location":"unc-psyc101/unc-psyc101-notes/#terms","text":"Soma: body of the cell which contains all organelles Oligo (small/ a few) + dendro (tree-like branches) Myelin sheath: insulating layer, or sheath that forms around nerves; allows electrical impulses to transmit quickly along the nerve cells Glia (\"glue\" of the brain) Oligodendrocytes (CNS): one cell can create several segments of myelin sheath and cover more than one axon Schwann cells (PNS): one cell creates only one segment of myelin sheath for only one axon Astrocytes: synchronizes communication between neurons, nurtures cells, and removes waste products Microglia: functions as part of immune system, removes waste products and invaders Radial glia: guides migration and growth of immature neurons","title":"Terms"},{"location":"unc-psyc101/unc-psyc101-notes/#types-of-neural-signals","text":"Synapses Axo-dendritic: connection formed between the axon of one neuron and the dendrite of another Axo-somatic: axon-soma Axo-axonic: axon-axon Action potential (electric & chemical signal in axon) \"all or none\" Threshold of excitation must be met to fire an action potential Refractory period - interval of time during which a second action potential can be initiated Absolute: no matter how large stimulus is applied Relative: depends on stimulus size Excitatory postsynaptic potential (EPSP) & inhibitory postsynaptive potential (IPSP) Electrical and chemical signals Only if EPSP > IPSP and reach threshold of excitation, then action potential in the 2nd neuron","title":"Types of neural signals"},{"location":"unc-psyc101/unc-psyc101-notes/#neurotransmitters","text":"At terminal buttons, there are vesicles full of chemicals called neurotransmitters When action potential reaches the terminal buttons, exocytosis is triggered to occur (where the neurotransmitter is released from the vesicle) Neurotransmitter diffuses across synapse from presynaptic neuron to postsynaptic neuron Neurotransmitter finds receptors that it matches and binds to \"binding site\" of receptor Binding causes either an excitatory postsynaptic potential or inhibitory postsynaptic potential Neurotransmitter unbinds from receptor and reuptake/ enzymatic degradation occurs","title":"Neurotransmitters"},{"location":"unc-psyc101/unc-psyc101-notes/#common-neurotransmitters","text":"Agonist (increases activity) vs. antagonist (decreases activity) GABA (inhibitory) vs glutamate (excitatory) Acetylcholine/ ach/ cholinergic Binds with PNS: muscle contractions Binds with CNS: arousal, attention, learning Monoamine -> catecholamine Dopamine/ DA Binds with CNS: movmenets, addictions, mood Norepinephrine/ NE Binds with CNS: mood, arousal Epinephrine/ Epi/ adrenergic (works on adrenaline) Binds with PNS: cardiac contraction Binds with CNS: mood Monoamine -> indolamine Serotonin/ 5-HT/ serotonergic Binds with CNS: sleep/ arousal, mood, eating, aggression, impulsivity Endorphins (endogenous + morphine) Type of neuropeptide to modulate pain","title":"Common Neurotransmitters"},{"location":"unc-psyc101/unc-psyc101-notes/#organization-of-nervous-system","text":"CNS: central nervous system (spinal cord) PNS: peripheral nervous system; lies outside brain and spinal cord Afferent: \"approaching\" the brain Efferent: \"exiting\" the brain","title":"Organization of Nervous System"},{"location":"unc-psyc101/unc-psyc101-notes/#methods-to-study-brain","text":"Lesioning (controlled damage) Via knife cut, electrolytic lesion Stimulation Via electrical stimulation, transcranial magnetic stimulation, chemical stimulation Brain imaging Tools which give structural information: CT scan, MRI Tools which give functional information: PET scan (measures blood flow) Tools which give both: fMRI (measures blood flow and oxygen)","title":"Methods to Study Brain"},{"location":"unc-psyc101/unc-psyc101-notes/#development-of-nervous-system","text":"Neural tube development (~24 days) Neural tube defect: spina bifida, anecephaly Advised to take folic acid which is in prenatal vitamins Neural tube continues to swell and grow Forebrain, mid brain, hindbrain and hollow center Telencephalon, diencephalon, mesencephalon (midbrain), metencephalon, myelencephalon (medulla) Telencephalon grows so much Ventricles and central spinal fluid (CSF) Hollow areas filled with fluid CSF Cushions the brain inside and out","title":"Development of Nervous System"},{"location":"unc-psyc101/unc-psyc101-notes/#brain-physiology-and-anatomy","text":"Medial and lower in the brain -> primitive/ vital functions Higher and outer areas of brain -> highest level of brain functions Hindbrain (very base of the brain) medulla (connection between the brainstem and the spinal cord) - pons (relay signal below neck) cerebellum (controls balance for walking and standing, and other complex motor functions) reticular formation (major integration and relay center for many vital brain systems) ascending fibers: wakefulness/sleep descending fibers: motor movement aka reticular activating system Midbrain visual information: superior colliculi auditory information: inferior colliculi DA-producing neurons: substantia nigra periaqueductal gray: area of brain involved with modulation of pain perception. For example, opioids can be released in this area and this leads to decreased perception of pain. periaqueductal gray: area of brain involved with modulation of pain perception reticular formation Forebrain cerebral hemispheres corpus callosum split-brain research thalamus \"sensory relay station\" since all sensory information goes here before going to primary cortices, exception: olfactory hypothalamus controls pituitary in endocrine system which releases oxytocin to help women give birth and bond emotional limbic system network of different brain structures cerebral cortex (known as gray matter) higher mental functions are done sulcus/ sulci: a groove gyri: bump or ridge fissure: deep groove occipital lobe: houses primary visual cortex temporal lobe: houses primary auditory cortex parietal lobe: houses primary somatosensory cortex frontal lobe: houses primary motor cortex + mirror neurons + prefrontal lobe (executive functions)","title":"Brain Physiology and Anatomy"},{"location":"unc-psyc101/unc-psyc101-notes/#hereditary-studies","text":"Three ways to estimate heritability: Family studies flaw: families do not share just genes, but also environment Twin studies flaw: the assumption that MZ and DZ twins only differ in terms of genes may be invalid; it\u2019s possible that they experience different environments as well Adoption studies twin adoption study method: gather MZ & DZ twins who have been reared apart; compare concordance rate (of the target behavior) between the MZ & DZ twins flaw: sample sizes tend to be too small (esp. with the twin adoption study method) flaw: separating the twins does not ensure that they experience dissimilar environments (e.g., again, if they look alike, they may evoke the same social environment) Epigenetics (heriditary changes in the characteristics of a cell or organism that result from altered gene expression or other effects not involving changes to the DNA sequence itself) marks can be passed down generations","title":"Hereditary studies"},{"location":"unc-psyc101/unc-psyc101-notes/#the-evolutionary-bases-of-behavior","text":"Darwin: traits which provide either survival advantage or reproductive advantage are much more likely to be \u201cselected\u201d over time (via natural selection) Behavioral traits are subject to natural selection as well Population vs. individual organisms","title":"The Evolutionary Bases of Behavior"},{"location":"unc-psyc101/unc-psyc101-notes/#4-sensation-and-perception","text":"","title":"4. Sensation and Perception"},{"location":"unc-psyc101/unc-psyc101-notes/#visual-system","text":"Stimulus: electromagnetic radiation between 480nm - 760nm Properties: wavelength, amplitude, purity (saturation) Anatomy & physiology of the eye Cornea -> pupil/ iris -> lens -> vitreous humor -> retina (bipolar cells -> ganglion cells -> photoreceptors, rods and cones) Transduction: process by which a stimulus is represented neurally Photoreceptors Rods Cones Scotopic Photopic Perceives general form (not detail) Greater visual acuity More numerous than cones Less numerous than rods More in the periphery of the retina More in center of retina and there are only cones in the fovea More thoroughly adapts to the dark Quickly adapts to the dark, but is limited in how much it adapts Receptive field: portion of the visual field which a neuron \"monitors\"","title":"Visual System"},{"location":"unc-psyc101/unc-psyc101-notes/#visual-pathway","text":"After light is transduced by cones/ rods, visual information processed: Bipolar cells Ganglion cells Optic disk (has optic nerves to transfer signals to the brain) Information received by the halves of the retina closer to the nose crosses to the other side of the brain to form the optic chiasm (contralateral connection) dorsal lateral geniculate nucleus of the thalamus primary visual cortex (in occipital lobe) aka V1 aka striate cortex Information received by the halves of the retina farthest from the nose stays on the same side of the brain (ipsilateral connection) dorsal lateral geniculate nucleus of the thalamus primary visual cortex (in occipital lobe) aka V1 aka striate cortex In the primary visual cortex Simple cells: detect orientation of line and location of the line within its receptive field Complex cells: detect orientation of line, movement of line Visual information goes to the WHAT pathway: lower part of temporal lobe, analyzes what the object is WHERE pathway: parietal lobe, analyzes where the object is","title":"Visual Pathway"},{"location":"unc-psyc101/unc-psyc101-notes/#theories-of-color","text":"Trichromatic theory (proposed by Young, refined by Helmholtz) Brain detects 3 main colors, and variations of them will give colors of the rainbow Opponent process theory (proposed by Hering) Neurons that can communicate to the brain that can see one color at one time (seeing one color takes opposing or opposite actions, cannot have two at the same time) Explains complementary afterimages (rebound effect: staring at a waterfall will make things look like they are elevated)","title":"Theories of Color"},{"location":"unc-psyc101/unc-psyc101-notes/#perceiving-form","text":"Bottom-up processing (aka feature detection) Basic visual information are compiled so that visual cortical cells Top-down processing (information is taken as a \"whole\") See structure and patterns in order for us to better understand the environment Gestalt principles: similarity, continuation, closure, proximity, figure/ground, and symmetry & order Stroop effect: naming color when spelt another color (interference of the processes) Depth perception Monocular cues: accomodation of one eye Binocular cues: retinal disparaity used to calculate depth; slight difference in images received by each eye due to horizontal separation","title":"Perceiving Form"},{"location":"unc-psyc101/unc-psyc101-notes/#auditory-system","text":"Stimulus: sound (compression and decompression of molecules) Properties: wavelength, amplitude, purity (timbre, quality of sound) Anatomy of ear: Outer ear (ear canal/ pinna) -> middle ear (ear drum/ tympanic membrane -> ossicles) -> inner eat (oval window of cochlea) Cochlea 3 canals: in the middle canal is the basiclar membrane (with auditory hair cells) Vibration moves the fluid, and basilar membrane moves Auditory hair cells fire action potential Place theory Different waveforms stimulate different areas of the basilar membrane Higher frequencies stimulate basilar membrane areas closest to oval window, vice-versa Frequency theory Basilar membrane mimics the sound waveform Neurons at the end of the basilar membrane fire in synchrony with waveform","title":"Auditory System"},{"location":"unc-psyc101/unc-psyc101-notes/#vestibular-system","text":"Sense of balance Stimulus: gravitational pull Anatomy of vestibular system Located in inner ear near the cochlea Has semiciruclar canals and vestibular sacs","title":"Vestibular System"},{"location":"unc-psyc101/unc-psyc101-notes/#gustatory-system","text":"Stimulus: molecules dissolved in fluid Anatomy of tongue: Papillae = bumps Taste buds (many on sides of papillae) Primary cortex: insular cortex in frontal lobe","title":"Gustatory System"},{"location":"unc-psyc101/unc-psyc101-notes/#olfactory-system","text":"Stimulus: molecules in air Anatomy of nose: Air -> mucous -> olfactory dedrites (transduction occurs) Primary cortex: olfactory bulb (temporal lobe)","title":"Olfactory System"},{"location":"unc-psyc101/unc-psyc101-notes/#somatosensory-system","text":"Stimulus: mechanical, thermal, chemical Anatomical system involed: nerves in th ebody Mechanoreceptors: ruffini endings, merkel\u2019s discs, pacinian corpuscles, meissner\u2019s corpuscle, hair shaft sensory receptor Nociceptors: free nerve endings Thermoreceptors Proprioceptors Pain Stimulus: something noxious or damaging to tissues (exception: some forms of chronic pain) Anatomy of pain system: noniceptors C fibers: slow pathway (e.g., dull, aching) A-delta fibers: fast pathway (e.g., sharp pain of a knife cut) Gate control theory by Melzack and Wall (theory of how we modulate pain) Triggers: central nervous system (brain can send stimulation to close pain gates) Peripheral nervous system (rubbing area around an injury works, because other sematosensory nerves are stimulated in that area, synapses - pain & rubbing - compete to get to the spinal cord, stopping pain)","title":"Somatosensory System"},{"location":"unc-psyc101/unc-psyc101-notes/#5-variations-in-consciousness","text":"","title":"5. Variations in Consciousness"},{"location":"unc-psyc101/unc-psyc101-notes/#behavioral-psychological-description-of-sleep","text":"Alert/ Awake Beta waves 13 - 24 cycles per second Relaxed, drowsy Alpha waves 8 - 12 cycles per second Stage 1 Theta waves 4 - 7 cycles per second Stage 2 Theta waves 4 - 7 cycles per second Stage 3: slow wave sleep (SWS) 0 - 49% delta waves <4 cycles per second Stage 4: slow wave sleep (SWS) Above 50% delta waves <4 cycles per second REM High frequency, low amplitude waves Beta waves, some alpha waves","title":"Behavioral/ Psychological Description of sleep"},{"location":"unc-psyc101/unc-psyc101-notes/#sleep","text":"What drives sleepiness Metabolic processes (mostly active brain) Circadian rhythm Circadian rhythm Regulated by suprachiasmatic nuclues (hypothalamus) SCN -> pineal gland -> melatonin -> increase sleepiness Can be entrained by light","title":"Sleep"},{"location":"unc-psyc101/unc-psyc101-notes/#factors-correlated-with-sleeping-pattern","text":"Age Infants: greater total sleep and amount of REM (50%, compared to 20% in adults) More than 70: 50% decrease in SWS, slight decrease in REM Genetics/ biology Cultural variations","title":"Factors Correlated with Sleeping Pattern"},{"location":"unc-psyc101/unc-psyc101-notes/#effects-of-sleep-deprivation","text":"Complete deprivation: weariness, irritability, paranois, lapses in attention, memory deficits, hallucinations Partial/ restricted deprivation: inconsistent effects, increased sleepiness, impairments of attention, reaction time, motor coordination, decision making, endocrine and immune system function Correlated with increased accidents and higher rates of physical issues Rebound effects of selective REM and SWS deprivation (brain will increasingly insist on sleep stage when deprived) Mortality rate and sleep amounts correlated (greatest mortality when sleep is less than 7h and more than 9h)","title":"Effects of Sleep Deprivation"},{"location":"unc-psyc101/unc-psyc101-notes/#effects-of-sleep","text":"Cognitive: brain development IQ Memory consolidation Insights during REM Energy conservation Marine mammals have the ability to sleep halfway Restore bodily resources Dreams Adults: focused on self Sex, aggression, misfortune Content of waking life spill into dreams (Frued's \"day residue\") Children: more static than storyline Theories of purposes: Frued: wish fulfillment R. Cartwright: problem-solving/ mood-regulation view Hobson: activation-synthesis model","title":"Effects of Sleep"},{"location":"unc-psyc101/unc-psyc101-notes/#sleep-disorders","text":"Hypersomnia: excessive sleepiness for at least 1 month TX: stimulants Insomnia: difficulty initiating or maintain sleep for at least 1 month More common in women, increase with age, variety of negative health conditions correlated TX: teach good sleep hygiene, relaxation training, benzodiazepines, non-benzodiazepines (e.g. Ambien, Sonata, Lunesta), melatonin Narcolepsy: irresistable attacks of refreshing sleep that occur daily over at least 3 months Presence of one or more of: Cataplexy: brief loss of voluntary muscle tone triggered by strong emotions Hypnogogic: Occur when you're falling asleep Hypnopompic hallucinations: Occur when you're waking up Sleep paralysis TX: stimulants, SSRIs Sleep apnea: breathing stops randomly ~10sec/ 10-15 min per hour of sleep Associated to obesity and age TX: CPAP, lifestyle modifications, upper airway and craniofacial surgery Somnambulism: sleep walking REM sleep behavior disorder: Being chased or attacked in dreams Deterioration of brain stem May precede Parkinson's up to 10 years","title":"Sleep Disorders"},{"location":"unc-psyc101/unc-psyc101-notes/#hypnosis","text":"Systematic procedure that typically produces a heightened state of suggestibility Associative features Anesthesia Sensory distortions/ hallucinations Disinhibition Post hypnotic suggestions and amnesia may occur Hilgard's dissociative theory: hypnotic induction is said to split the functioning of the executive control system (ECS) into different streams Highway hypnosis: altered mental state in which an automobile driver can drive lengthy distances and respond adequately to external events with no recollection of consciously having done so","title":"Hypnosis"},{"location":"unc-psyc101/unc-psyc101-notes/#meditation","text":"Practices that train attention to heighten awareness and bring mental processes under greater voluntary control Transcendental meditation: focused attention Mindfulness meditation: open monitoring Associative features EEG: increase in alpha and theta waves Transcendant experience is not equal to relaxation Correlated with: decrease stress, anxiety, BP; increase immune function, mood, self-esteem, overall health and well-being Decreased parietal lobe activity (where somatosensory system resides) Increased left prefrontal lobe activity","title":"Meditation"},{"location":"unc-psyc101/unc-psyc101-notes/#drugs","text":"Narcotics E.g. morphine, heroin, oxycodone, codeine, methadone Effects: anxiety reduction, pain relief, drowsiness impaired mental & motor functioning constipation withdrawal: severe diarrhea, increase in infectious diseases used for: analgesic, cough, diarrhea Sedatives: CNS depressants E.g. barbiturates, benzodiazepines Effects: relaxation, anxiety, increased drowsiness quick tolerance/medication backfires impaired mental & physical functioning increased risk of accidents synergistic effect with alcohol withdrawal can be potentially dangerous used for anxiety, sleeping issues Stimulants: increase CNS activity E.g. caffeine, nicotine, cocaine/crack, amphetamines/crank/crystal meth, MDMA (low doses; in high doses, MDMA can have hallucinogenic effects) Effects: euphoria increased energy, alertness, CV arousal and/or CV problems, panic, insomnia, sweating/urination psychosis: when people lose some contact with reality (e.g., cocaine, amphetamines) decreased appetite (cocaine, for example): damaged nasal membranes, increased CV and respiratory problems used for narcolepsy, ADHD (methylphenidate), local anesthetic (cocaine) Hallucinogens: small amount alters sensory/perception E.g. LSD, mescaline (peyote), psilocybin (mushroom), MDMA too (\u201cecstasy\u201d), though in larger dose Effects: euphoria, distortions in sensory & perceptual experiences (e.g., mystical experiences) anxiety, paranoia (\u201cbad trip\u201d) kills 5-HT neurons impaired judgment \u2192 \u2191 risk of accidents Cannabis E.g. marijuana, hashish, THC (Tetrahydrocannabinol, a cannabinoid found in cannabis) Effects: mild euphoria, relaxation, sensory/perceptual distortions (e.g., \u201cslowing of time,\u201d vivid perceptions), increased hunger, esp. for sweets short-term memory impairments, metabolizes slowly decreased IQ in young users persistent memory issues in middle aged users (even after stopping use) increased accident risk used for: TX of nausea & pain, e.g., cancer, glaucoma (ethyl) Alcohol Effects: mild euphoria, relaxation, mood swings, quarrelsomeness 90% student rapes, 95% on violent crimes on campus impairments of cognitive & motor function 21% unplanned sex, 50% fatal vehicle accidents (according to some sources) , ~40% fatal bicycle accidents liver damage (cirrhosis, which is scarring), hypertension, stroke, other heart diseases, neurological issues (e.g., Korsakoff\u2019s syndrome), Korsakoff symptoms include severe memory problems, apathy, walking problems, etc., cancers increased risk of death in general - males: 2x increased mortality, females: 4x increased mortality withdrawal could be fatal delirium tremens\u2014can be fatal in some cases is characterized by \u201cthe shakes\u201d as well as by symptoms of delirium, which include cognitive deficits, changes in CNS arousal, and psychotic features like hallucinations & delusions a standard drink has 0.6 oz. of alcohol","title":"Drugs"},{"location":"unc-psyc101/unc-psyc101-notes/#6-learning","text":"Learning refers to the change in a person's behavior to a given situation brought about by repeated experiences in that situation, provided the behavior change cannot be explained on the basis of native response tendencies, maturation, or temporary states of the subject","title":"6. Learning"},{"location":"unc-psyc101/unc-psyc101-notes/#classical-conditioning-pavlovian-conditioning","text":"","title":"Classical Conditioning (Pavlovian Conditioning)"},{"location":"unc-psyc101/unc-psyc101-notes/#history","text":"Pavlov & psychic reflexes demonstration","title":"History"},{"location":"unc-psyc101/unc-psyc101-notes/#terms_1","text":"Unconditioned stimulus (US or UCS) naturally elicits a response Unconditioned response (UR) natural response to US Conditioned stimulus (CS) a previously neutral stimulus which, after pairings with a US, attains the ability to elicit the same response Conditioned response (CR) the response to the CS (which looks like the UR, at least on the surface, and not in all cases)","title":"Terms"},{"location":"unc-psyc101/unc-psyc101-notes/#acquisition","text":"stimulus contiguity simultaneous presentation (of UCS & CS) tone & meat are presented and ended at same time short-delayed presentation tone begins shortly before meat tone & meat end at same time trace presentation tone is presented & ended right before the meat is presented then ended saliency of stimulus stimulus which is most noticeable is more likely a good potential CS","title":"Acquisition"},{"location":"unc-psyc101/unc-psyc101-notes/#extinction","text":"Weaking asociation by presenting CS without UCS Spontaneous recovery (after a period of non-exposure to CS) Renewal effect (after re-exposure to environment where learning ocurred)","title":"Extinction"},{"location":"unc-psyc101/unc-psyc101-notes/#stimulus-generalization-and-discrimination","text":"Stimulus generalization: when a person generalizes what they have learned from a specific CS to other stimuli which are similar to the original CS e.g., if you have been classically conditioned to be scared of Bozo and then are later scared of all clowns Stimulus discrimination: when a person does NOT generalize what they have learned from a specific CS to other stimuli which are similar to the original CS e.g., if you have been classically conditioned to be scared of Bozo but are not scared of other clowns (so you are discriminating between Bozo and the other clowns)","title":"Stimulus Generalization and Discrimination"},{"location":"unc-psyc101/unc-psyc101-notes/#higher-order-conditioning","text":"When a CS functions as a UCS Example: A makes you happy, B provides A so B makes you happy (1st order), C provides B provides A so C makes you happy (2nd order)","title":"Higher-order Conditioning"},{"location":"unc-psyc101/unc-psyc101-notes/#biological-influence-on-conditioning","text":"Conditioned taste aversion one trial extended delay between CS & US presentation food stimuli-nausea associations are likely Evolutionarily adaptative CS: ecologically relevant vs. arbitrary, neutral stimulus","title":"Biological Influence on Conditioning"},{"location":"unc-psyc101/unc-psyc101-notes/#operant-conditioning-instrumental-learning","text":"","title":"Operant Conditioning (Instrumental Learning)"},{"location":"unc-psyc101/unc-psyc101-notes/#history_1","text":"B.F. Skinner (1904 \u2013 1990): demonstrated that organisms repeat those responses that are followed by favorable consequences and organisms tend not to repeat those responses that are followed by negative and/or neutral consequence Skinner box Reinforcement contingencies Cumulative recorder","title":"History"},{"location":"unc-psyc101/unc-psyc101-notes/#terms_2","text":"reinforcement: consequence that increases tendency to repeat preceding behavior positive reinforcement: adding something into the situation that increases the tendency to repeat the preceding behavior negative reinforcement: taking something away from the situation that increases the tendency to repeat the preceding behavior punishment: consequence that \u2193 tendency to repeat preceding behavior (positive) punishment: adding something into the situation that decreases the tendency to repeat the preceding behavior (negative) punishment: taking something out of the situation that decreases the tendency to repeat the preceding behavior","title":"Terms"},{"location":"unc-psyc101/unc-psyc101-notes/#acquisition_1","text":"When the connection between the behavior and a consequence is \"aquired\" Shaping: reinforcements fo closer and closer approximations of a desired response","title":"Acquisition"},{"location":"unc-psyc101/unc-psyc101-notes/#extinction_1","text":"Process where the usual consequence does not follow the emitted behavior Resistance to extinction Renewal effect","title":"Extinction"},{"location":"unc-psyc101/unc-psyc101-notes/#stimulus-generalization-and-discrimination_1","text":"stimulus generalization: hold onto the association between the stimulus (and alike) and consequence stimulus discrimination: only associate the stimulus (specifically only that stimulus) and consequence","title":"Stimulus Generalization and Discrimination"},{"location":"unc-psyc101/unc-psyc101-notes/#reinforcements","text":"Primary reinforcers are those which directly satisfy our biological needs Secondary reinforcers are those which are associated with primary reinforcements (e.g. money) Schedules of Reinforcements continuous reinforcement reinforcement after every single target behavior intermittent reinforcement fixed-ratio schedule reinforcement is given based on a fixed number of responses (e.g., every third response) variable-ratio schedule reinforcement is given based on an average number of responses (e.g., reinforcement is given, on average, 4 responses) fixed-interval schedule reinforcement is given based on the first response given after a fixed amount of time has passed (e.g., reinforcement is given if a rat pulls a lever after 4 seconds have passed) variable-interval schedule reinforcement is given based on the first response given after an average amount of time has passed (e.g., reinforcement is given if a rat pulls a level, on average, after 3 seconds have passed) Special issue concerning positive punishment e.g., corporeal punishment poor-quality parent-child relationship, e.g. increased aggression, delinquency, behavior problems. Long term effects: associated with slowed cognitive development, increased criminal behavior, range of mental health issues (cited in Weiten) correlational data; however, strong evidence for a causal relationship","title":"Reinforcements"},{"location":"unc-psyc101/unc-psyc101-notes/#biological-influence-on-conditioning_1","text":"Instinctive drift Operant conditioning is not always successful Operant conditioning which tries to go against natural instinct usually fails Preparedness and Phobias Classical conditioning and operant conditioning are often used together, e.g. phobias classical conditioning establishes the phobia operant conditioning maintains the phobia behavior of avoiding = decreased anxiety = reinforcing = increased likelihood that person will avoid the object of anxiety","title":"Biological Influence on Conditioning"},{"location":"unc-psyc101/unc-psyc101-notes/#cognition-in-classical-operant-conditioning","text":"Latent Learning & Cognitive Maps (Edward Tolman, 1930s & 1940s) 1st group: reinforcement was given after every trial (through a maze) -> steadily improved 2nd group: no reinforcements were given -> little improvement 3rd group: reinforcements were given after the 10th trial onward -> sharply improved behavior => learning can take place without reinforcement mental representation of a map is possible Signal Relations - predictive value of conditioned stimulus (Robert Rescorla, 1970s & 1980s) 1st group: a tone signaled a shock every single time -> strong response 2nd group: a tone signaled a shock only half of the time -> weaker response somewhere in the organism\u2019s mind, the predictive value of the environmental cue is being calculated","title":"Cognition in Classical &amp; Operant Conditioning"},{"location":"unc-psyc101/unc-psyc101-notes/#observational-learning-modeling","text":"","title":"Observational Learning (modeling)"},{"location":"unc-psyc101/unc-psyc101-notes/#history_2","text":"Albert Bandura (1970s, 1980s): suggest that many different cognitive processes could be involved with learning including internal processes which allow one to learn vicariously (so vicarious classical and operant conditioning)","title":"History"},{"location":"unc-psyc101/unc-psyc101-notes/#terms_3","text":"cognitive processes which may be involved with this type of learning (attention, retention, reproduction, motivation)","title":"Terms"},{"location":"unc-psyc101/unc-psyc101-notes/#7-memory","text":"","title":"7. Memory"},{"location":"unc-psyc101/unc-psyc101-notes/#encoding","text":"Attention Focusing awareness onto something Divided attention = decreased memory encoding Multi-tasking is really shifting attention between tasks high on impulsivity high on sensation-seeking Levels of processing (\"digesting\" information) Structural encoding (how it looks) Phonemic encoding (how it sounds) Semantic encoding (what it means) Enriching encoding Elaboration Linking stimulus to other information Examples given with a main indolamine Imagery (Paivio's dual-coding theory) Linking verbal and visual cues Retrieval cues Motivation to remember Pay more attention to things that we believe are relevant to us \"Learning styles\" do not exist; \"right/ left brained\" do not exist","title":"Encoding"},{"location":"unc-psyc101/unc-psyc101-notes/#storage","text":"Sensory memory Duration: ~1/4 second Capacity: large Short-term/ working memory Duration: 10 - 20 seconds/ unlimited with uninterrupted rehearsal Capacity: 7 \u00b1 2 items/ 4 \u00b1 1 items Chunking - creates more room in working memory Capacity may be somewhat flexible (e.g. depending on familiarity/ complexity) Phonological loop (is the speech and sound related component of working memory and holds verbal and auditory information) Episodic buffer (\"workbench\") Working memory capacity (WMC): stable trait, heriditary influence, correlated with IQ Long-term memory Duration: indefinite but not necessarily permanent Capacity: unlimited Recall is critical Retrieval practice Distributed studying Illusions of Competence (e.g. recency effect - items that came last are remembered more easily) Type of long term memory Explicit (things you can talk about) Implicit (procedural memory system: actions, skills, operations) *Moving things from short-term to long-term memory Neurons need time for synaptogenesis (and to build connections)","title":"Storage"},{"location":"unc-psyc101/unc-psyc101-notes/#amnesias","text":"Henry Gustav Molaison (H.M.): epileptic patient Could not remember new information (explicit) but could improve on mirror-drawing task (implicit) Semantic dementia (cannot remember the meaning of things) Neocortex of lateral temporal area Types of amnesias Retrograde (forget things before) Anterograde (forget things after)","title":"Amnesias"},{"location":"unc-psyc101/unc-psyc101-notes/#knowledge-memory","text":"Categories and conceptual hierarchies Schemas Stereotypes are a type of schema Semantic network","title":"Knowledge &amp; Memory"},{"location":"unc-psyc101/unc-psyc101-notes/#retrieval","text":"Usually automatic, without much effort/ take conscious effort (e.g. systematic search) Encoding specificity principle Better retrieval cue matches memory -> more likely successful retrieval Reinstate the context: increase chances of retrieval cue to retrieve the memory needed Tip-of-the-tongue phenomena: what comes to mind may be a clue as to the word you are searching for Memory is a reconstruction Loftus: misinformation effect (post-event infromation leads to an alteration of memory) Source monitoring error (make incorrect guess about where the information came from)","title":"Retrieval"},{"location":"unc-psyc101/unc-psyc101-notes/#forgetting","text":"Measuring forgetting = measuring retention Recall: results in a more steep curve Ebbinghaus' Forgetting Curve is particularly steep (b/c they are nonsense words) Recognition: more shallow curve E.g. MCQ questions that serve as a cue for remembering Relearning: even more shallow curve E.g. the less time it takes person to relearn words, the more it indicates the person remembers Reasons for forgetting Ineffective encoding (pseudoforgetting) Never really learnt it Decay Memory traces fade with time Interference Additional information get in the way of remembering other information Amount, complexity and type of information learned affect retention (difficult content = more interference) Proactive: when previously learned information interferes with you learning new information Retroactive: : when newly-learned information interferes with you remembering previous information Retrieval failure Motivated forgetting: Freud - \u201crepressed memories\u201d (where your mind\u2014unconsciously\u2014represses negative events in your unconscious) Motivated forgetting is a controversial idea","title":"Forgetting"},{"location":"unc-psyc101/unc-psyc101-notes/#memory-trace-physiology-of-memory","text":"Neural circuitry of memory Physical changes leading to functional synaptic changes: presynaptic/ postsynaptic Neurogenesis (in the dentate gyrus of the hippocampus)","title":"Memory Trace: Physiology of Memory"},{"location":"unc-psyc101/unc-psyc101-notes/#10-human-development","text":"","title":"10. Human Development"},{"location":"unc-psyc101/unc-psyc101-notes/#physical","text":"","title":"Physical"},{"location":"unc-psyc101/unc-psyc101-notes/#conception","text":"Egg (23 chromosomes) + sperm (23 chromosomes) Ovulation occurs 2 weeks before menstrual period Ovum lives for 12-24 h Sperm lives for 5-7 days Pregnancy tests Home pregnancy test (urine) Detects human chorionic gonadotropic hormone (HCG) In-clinic pregnancy test (blood) Detects HCG","title":"Conception"},{"location":"unc-psyc101/unc-psyc101-notes/#stages-of-prenatal-development","text":"Germinal stage: 0-2 weeks (Zygote) Within 36 hours \u2192 proliferation (refers to the rapid cell division and multiplication) 1 week \u2192 implantation Embryonic stage: 2-8 weeks (Embryo) Recognizably human/ humanoid Cephalocaudal (dev from head to toe) & proximodistal (dev from middle to extremities) Sensitive period of development vital organs are developing most miscarriages happen around this time when errors occur during this time, it can be deadly or very serious 70-80% have \"morning sickness\" Fetal stage: 8-38 weeks (Fetus) 12 weeks: basic structures are completed (though they will continue maturing) Fetus' first movements (called \"quickening\") Placenta has basic parts in place 23-25 weeks: threshold of viability; 24%-72% chance of survival 20-24 weeks birth = 43% neurodevelopmental impairments + 19% sensory deficits at 18-22 months Rest of the weeks: fat deposits/ growth","title":"Stages of prenatal development"},{"location":"unc-psyc101/unc-psyc101-notes/#teratogens-environmental-agents-which-can-cause-developmental-malformations","text":"Maternal malnutrition Increased risk of birth complications & neurological deficits Material stress and emotional Lead to negative hormones which may impact development Increased stillbirth to various disorders Drug exposure e.g. recreational drugs, prescribed drugs, OTC drugs, smoking, alcohol Maternal illness First half of pregnancy: 1-2% risk of birth defects, including scarring of skin, limb defects, eye problems, etc. Second half of pregnancy: probably okay 5 to 21 days before birth: fetus may develop the illness Environmental toxins e.g. radiation exposure, air pollution, flame-retardant materials Fetal origins of adult diseases Prenatal malnutrition & schizophrenia; low birth weight & height disease; bipolar disorder Mental and physical conditions","title":"Teratogens (environmental agents which can cause developmental malformations)"},{"location":"unc-psyc101/unc-psyc101-notes/#postnatal-development","text":"Physical growth is uneven Motor Development 3 mos.: lifts head, chest up with arm support 2.75 mos.: rolls over 5.5 mos.: sits without support 5.75 mos.: stands holding on to something 7.5 mos.: pulls self to stand 9 mos.: cruises (walks holding on to something) 12 mos: walks alone Adolescent growth spurt: next rapid growth Females Males Sometime before growth spurt: secondary sex characteristics Sometime before growth spurt: secondary sex characteristics 9-10 yrs. old: growth spurt 10-12 yrs. old: growth spurt (more intense and longer-lasting than for females) 12-13 yrs. old: puberty (menarche: 1st menstruation) and primary sex characteristics (puberty) 13-14 yrs. old: spermarche (1st ejaculation) and primary sex characteristics (puberty) 14-15 yrs. old: full height 15-16 yrs. old: full height 16 yrs. old: sexual maturation 18 yrs. old: sexual maturation Adulthood: graying hair, thinning/balding decline in sensory/perceptual acuity (e.g. increased farsightedness, loss of hearing) menopause (~51 yrs. old) proportion of fat increases psychological and behavioral factors may be involved with \u201caging well,\u201d not just good genetics (e.g. intelligence, optimism, conscientious, high self-esteem, positive emotions, nutritious diet, exercise, avoiding smoking and substance abuse, regular medical checkups, SLEEP)","title":"Postnatal development"},{"location":"unc-psyc101/unc-psyc101-notes/#emotional","text":"Smiling & laughter (~4-6 weeks) One of the first expressions of pleasure Fear ~3 months: wariness, sober stares ~6 months: distress; whimpering; looking away ~7 months: true fear, crying ~14-18 months: separation anxiety peaks Early attachment styles attachment styles in the US secure attachment (60-65%) anxious/ambivalent aka resistant attachment (10-15%) avoidant attachment (20%) disorganized/disorientated attachment (5-10%) Ainsworth Strange Situation: psychological experiment that measures the attachment between an infant and their primary caregiver culture separation anxiety proportion of those who fall into the different types of attachment may vary; economic circumstances may be contributing factor parental style sensitive care \u2192 secure insensitive care (e.g. feeding baby when baby is not hungry) \u2192 avoidant inconsistent care \u2192 anxious/ambivalent aka resistant severe neglect and/or abuse \u2192 disorganized/disoriented","title":"Emotional"},{"location":"unc-psyc101/unc-psyc101-notes/#language","text":"1-5 mos.: reflexive communication; cooing 6-18 mos.: babbling 10-13 mos.: first words 12-18 mos.: one word sentences receptive vs. productive vocabulary (understanding more than you can say) overextension (using the same word for different situations) underextension 18-24 mos.: vocabulary spurt & fast mapping towards end of 2 yrs: telegraphic speech (not universal) towards end of 3 yrs.: overregularizations 5 yrs.+: well-developed and complex grammar","title":"Language"},{"location":"unc-psyc101/unc-psyc101-notes/#personality","text":"Biological: genetics & traits/predispositions Psychoanalytic: personality arises as we resolve psychosexual conflicts Neopsychoanalytic (proposed by those who followed Freud, then rejected some of his ideas, and developed their own): personality arises as we resolve psychosocial conflicts Learning/behavioral: personality is a collection of behavioral tendencies/habits Humanistic: people have innate drive to become who they were meant to be","title":"Personality"},{"location":"unc-psyc101/unc-psyc101-notes/#cognitive","text":"Jean Piaget: cognitive development inferred that certain cognitive skills were not present until a certain age Vygotsky\u2019s sociocultural theory social interaction is very important for cognitive development whereas Piaget felt cognitive development was due to maturation language acquisition is vital for cognitive development private speech Piaget felt that language acquisition was just a part of cognitive development, not necessarily crucial for it (Williams Syndrome) Teenage brain increased myelination + increased synaptic pruning later maturation of prefrontal cortex early development of subcortical DA/reward system leads to impulsive behavior with decreased inhibition Adults loss of neurons (mostly normal!) + shrinkage of active neurons (mostly after 60) later adulthood: senility/dementia is not normal 85 yrs. + = 33% with dementia 70% = Alzheimer\u2019s disease (memory problems > executive function problems > death in approximately 8-10 yrs.) Genetics may account for 70% of variance? Chronic inflammation associated with increased risk. exercise + cognitive activities, active social activities, decreased cardiovascular disease (CVD) risk, no history of smoking or diabetes, diet low in meats, sweets and high-fat dairy are correlated with \u2193 risk of dementia Nun study suggests high prevalence of positive emotions too memory: fairly stable memory and/or cognition but research is mixed \u2193 episodic memory, in particular problem-solving seems okay if adequate time is given (for the slower brain) speed of processing slows down people who have mentally demanding jobs and/or continue to engage in intellectually challenging activities seem to buffer against cognitive decline programs to increase mental activity have met with mixed results","title":"Cognitive"},{"location":"unc-psyc101/unc-psyc101-notes/#moral","text":"Kohlberg\u2019s moral development theory","title":"Moral"},{"location":"unc-psyc101/unc-psyc101-notes/#major-events","text":"Search for identity (adolescence) lifetime \u2013 research shows that the search for identity doesn\u2019t just occur during adolescence but occurs throughout a lifetime, from time to time and this is healthy Marcia\u2019s theory of identity statuses: Jeffrey Arnett\u2019s emerging adulthood (18 \u2013 29 yrs.) not adolescent/not adult, possibilities/optimism, self-focused time, continued identity search Marriage: delaying marriage (later 20\u2019s, 30s) (careers, educational requirements, autonomy) 90% still marry 8-14% distressed when transitioning (balancing responsibilities, e.g. work and financial concerns) cohabitation (66% now) more common now, correlated with better outcomes now (unlike the past) expectation of roles men doing more housework/childcare but (44%) women still doing majority, even among highly-paid executive women more equitable housework distribution corre. with greater sex and greater sexual satisfaction. 50% end in divorce Parenthood Delaying parenthood (later 20\u2019s, 30s) Majority still have children Marital satisfaction can suffer after having children (esp. as number of children increase) However, factors such as chore distribution and relationship trust, responsiveness and gratitude can influence Adolescents spend less time in family activities and may have increased conflicts, but the conflicts tend to be about everyday matters. Empty Nest Empty nest syndrome: parents get distressed when children leave the house: myth Aging subjective well-being matters! rates of chronic illness increase protective psychological factors: higher intelligence (greater health, longevity) personality traits like optimism, conscientiousness, high self-esteem, positive emotions behavioral habits (e.g. diet and exercise, smoking & drinking, medical checkups) 2/3 of cancers due to poor diet and/or lack of exercise","title":"Major events"},{"location":"unc-psyc101/unc-psyc101-notes/#death","text":"K\u00fcbler \u2013Ross Denial Anger Bargaining Depression Acceptance Recent research = no \u201cstages\u201d and these emotions may not be experienced by all Bereavement cultural differences patterns: absent grief/resilient pattern (50%, most common \u2013 but results challenged by other studies), chronic grief, common grief, depressed-improved pattern, chronic depression","title":"Death"},{"location":"unc-psyc101/unc-psyc101-notes/#11-personality","text":"Unique collection of traits (distinctiveness) Relatively stable across situations and time Traits: internal dispositions or behavioral tendencies","title":"11. Personality"},{"location":"unc-psyc101/unc-psyc101-notes/#psychodynamic-perspective","text":"Freud's psychoanalytic theory Structure of personality Id (primary) Reservoir of psychic energy Pleasure principle Ego (secondary) Decision-making Reality principle Superego Moral component, takes awhile to develop Levels of awareness can vary for each of the different components of personality Conscious Preconscious Unconscious Parapraxes (aka Freudian slips): minor errors in speech, memory, or action that are thought to be caused by unconscious wishes, attitudes, or impulses Internal conflict influences behavior Freud's theory of personality development Stage Age Range Focus of Libido Key Developmental Task Fixation Characteristics Oral Stage Birth to 1 year Mouth Sucking, biting, chewing. Primary conflict: weaning. Dependency, smoking, overeating, nail-biting Anal Stage 1 to 3 years Anus Toilet training. Primary conflict: control over bodily functions. Orderliness, stubbornness, messiness, expulsive behaviors Phallic Stage 3 to 6 years Genitals Oedipus/Electra complex (desire for opposite-sex parent). Identification with same-sex parent. Vanity, recklessness, difficulty with authority Latent Stage 6 to puberty None (dormant) Development of communication and intellectual skills, peer relationships. No major fixations, focus on social and cognitive development Genital Stage Puberty onward Genitals Development of mature sexual relationships. Focus on reproduction and emotional intimacy. Healthy relationships, balanced personality","title":"Psychodynamic perspective"},{"location":"unc-psyc101/unc-psyc101-notes/#neopsychodynamic-views-of-personality-development","text":"Jung's analytical psychology personal unconscious vs collective unconscious Alfrd Adler's individual psychology primary motivation = striving for superiority Erik Erikson's stages of psychosocial development","title":"Neopsychodynamic views of personality development"},{"location":"unc-psyc101/unc-psyc101-notes/#behavioral-perspective","text":"Skinner's behavioral/ determinism ideas Focus on environmental factors & observable behavior Personality is therefore a collection of unique response tendencies Bandura's contribution of \"cognition\" to this behavioral perspective Mischel and Person-Situation Controversy Personality traits have much less consistency across situations than people think","title":"Behavioral perspective"},{"location":"unc-psyc101/unc-psyc101-notes/#humanistic-perspective","text":"Focus on healthy human quality Freedom Innate drive for personal growth Not determined by primitive biological urges Not dominated by unconscious, irrational urges/conflicts Carl Roger\u2019s Person-Centered Theory Self (aka self-concept) If there is incongruence between self-concept & reality \u2192 distress/anxiety Conditional love = \u2191 risk of incongruence Distress/anxiety may lead people to deny/twist reality to protect their self-concept Maslow\u2019s Theory of Self-actualization Unlike Freud, studied people who were thought to be psychological healthy","title":"Humanistic perspective"},{"location":"unc-psyc101/unc-psyc101-notes/#biological-perspective","text":"Hans Eysenck\u2019s PEN theory Genes + learning = personality Heavy emphasis on genetics Variations in conditionability (is one example) Three higher-order traits: Psychoticism Extraversion-introversion (Big Five: sociable, lively, active, assertive, sensation-seeking) Neuroticism Research support for heritability of personality traits Identical twins reared together > identical twins reared apart > fraternal twins reared together","title":"Biological perspective"},{"location":"unc-psyc101/unc-psyc101-notes/#12-social-psychology","text":"","title":"12. Social Psychology"},{"location":"unc-psyc101/unc-psyc101-notes/#person-perception","text":"Physical appearance People who are taller, normal weight, make eye contact, have good posture, wear nice clothes are physically attractive -> make more favorable impressions Cognitive schemas Humans evolved to use schemas/ stereotypes/ have biases and notice patterns Society teaches stereotypes and biases -> systemic/ institutional bias Persist in using stereotypes: confirmation bias, illusory correlation, difficult to identify and control them Implicit biases affect an infinite variety of behaviors Consequences of stereotypes Could be wrong Lead to biases/ attitudes/ prejudice Which leads to discrimination Which leads to large inequalities between groups of people Out-group homogeneity effect: perception of out-group members as more similar to one another than are in-group members Diversity vs equality vs equity Diversity: makeup of the group Equality: giving everyone same access to resources/opportunities, etc. Equity: achieving equality by making reparations \u2013 in other words, treating people differently, based on need","title":"Person perception"},{"location":"unc-psyc101/unc-psyc101-notes/#attribution","text":"(Heider): judgment between external vs. internal cause of behavior (Weiner): Internal-Unstable, Internal-Stable, External-Unstable, External-Stable Attributions influence our behaviors: Liberals on poverty: external attribution \u2192 public assistance Conservatives on poverty: internal attribution \u2192 non-supportive of public assistance Biases in the attribution process (actor vs. observer bias) fundamental attribution error (actors favor external attributions; observers favor internal attributions) self-serving bias (actor favor internal attributions for success and external attributions for failures): tendency increases with time","title":"Attribution"},{"location":"unc-psyc101/unc-psyc101-notes/#interpersonal-attraction","text":"Factors influencing this Physical attractiveness (matching hypothesis: married couples are similar) Similarity (couples and friends) Nature of romantic love Hatfield & Berscheid, 1988: passionate (DA may play a role), companionate R. Sternberg, 1988: passionate, commitment, intimacy combination of the components = different types of love consummate love = high on all components level of each component of love changes over time (e.g. passion decreases over time but more gradually and much more modestly than once thought before) Internet and close relationships Virtual relationships can be intimate and evolve to face-to-face relationships Evolutionary perspective - Physical attractiveness indicative of good health, genes, fertility - Facial symmetry: good external and internal developmental environments - Women's waist-to-hip ratio: reproductive potential - Gender differences: men look for youth; women look for ambition, social status - Peri-ovulation/ ovulation: women prefer more masculine features, dominance","title":"Interpersonal attraction"},{"location":"unc-psyc101/unc-psyc101-notes/#attitudes","text":"Three components: cognitive, affective, behavioral Three dimensions: strength, accessibility, ambivalence Mediocre predictors of behavior: strength of attitude, situational constraints Formed by learning Classical conditioning: e.g. transferring affective component from an unconditioned stimulus to a conditioned stimulus Operant conditioning: e.g. openly expressing attitude and being reinforced or punished for it Observational learning: e.g. observing how others attitudes can be reinforced or punished Change someone's attitude Source factors: credibility Message factors: using two-sided arguments, fear, repetition Receiver factors: transient factors matter more than personality factors Channel factors: in-person, TV, radio How do attitudes change: (Festinger): cognitive dissonance may lead to attitude change (but not always); e.g. effort justification (Petty & Cacioppo): Elaboration Likelihood Model central/high elaboration route longer-lasting change more resistant to changing better predictor of behavior peripheral/low elaboration route","title":"Attitudes"},{"location":"unc-psyc101/unc-psyc101-notes/#social-influence-on-behavior","text":"Conformity due to group pressure (e.g. Solomon Asch's studies) normative influence (fear of negative social consequences, being liked) information influence (information for ambiguous situations, being right) replicated in other societies with higher numbers of conformity reactance: hoarding toilet paper Obedience: compliance due to direct command Milgram\u2019s Obedience Study: Yale study, over 65% still obedient","title":"Social influence on behavior"},{"location":"unc-psyc101/unc-psyc101-notes/#behavior-in-groups","text":"Bystander effect Diffusion of responsibility e.g. Kitty Genovese Group productivity and social loafing increased numbers -> decreased productivity reduced efficiency due to loss of coordination AND \u2193 effort due to diffusion of responsibility smaller group size, new groups, non-anonymized contributions, collectivist society = \u2193 social loafing Group polarization groups sometimes take extreme positions after discussion, esp. if there is a slight bias towards a position (Myers & Bishop, 1970): had two groups divided into high- and low- prejudiced groups to discuss racial issues (Janis) Groupthink groups sometimes make poor decisions heavy emphasis on cohesion, direct pressure to conform","title":"Behavior in groups"}]}
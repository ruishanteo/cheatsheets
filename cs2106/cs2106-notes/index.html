<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>CS2106 Notes AY23/24 Sem2 - Notes</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <link href="../../style.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Notes</a>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#cs2106-notes-ay2324-sem2" class="nav-link">CS2106 Notes AY23/24 Sem2</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#operating-systems" class="nav-link">Operating Systems</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#operating-system-structure" class="nav-link">Operating System Structure</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#running-oses" class="nav-link">Running OSes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#process-management" class="nav-link">Process Management</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#process-abstraction" class="nav-link">Process Abstraction</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#component-description" class="nav-link">Component Description</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#basic-instruction-execution" class="nav-link">Basic Instruction Execution</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#memory-context" class="nav-link">Memory Context</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#function-call" class="nav-link">Function Call</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#dynamically-allocated-memory" class="nav-link">Dynamically Allocated Memory</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#os-context" class="nav-link">OS Context</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#processes" class="nav-link">Processes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#process-abstraction-in-unix" class="nav-link">Process Abstraction in Unix</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#zombie-process" class="nav-link">Zombie Process</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#unix-system-calls" class="nav-link">Unix System Calls</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#process-scheduling" class="nav-link">Process Scheduling</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#concurrent-execution" class="nav-link">Concurrent Execution</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#process-scheduling-algorithms" class="nav-link">Process Scheduling Algorithms</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#first-come-first-serve-fcfs" class="nav-link">First-Come First-Serve: FCFS</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#shortest-job-first-sjf" class="nav-link">Shortest Job First: SJF</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#shortest-remaining-time-srt" class="nav-link">Shortest Remaining Time: SRT</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#round-robin-rr" class="nav-link">Round Robin: RR</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#priority-scheduling" class="nav-link">Priority Scheduling</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#multi-level-feedback-queue-mlfq" class="nav-link">Multi-level Feedback Queue (MLFQ)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#lottery-scheduling" class="nav-link">Lottery Scheduling</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#scheduling-for-interactive-systems" class="nav-link">Scheduling for Interactive Systems</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#process-alternative-threads" class="nav-link">Process Alternative - Threads</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#motivation-for-thread" class="nav-link">Motivation for Thread</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#process-and-thread" class="nav-link">Process and Thread</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#thread-models" class="nav-link">Thread Models</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#user-thread" class="nav-link">User Thread</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#kernel-thread" class="nav-link">Kernel Thread</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#hybrid-thread-model" class="nav-link">Hybrid Thread Model</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#posix-threads-pthread" class="nav-link">POSIX Threads: pthread</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#inter-process-communication-ipc" class="nav-link">Inter-Process Communication (IPC)</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#message-passing" class="nav-link">Message Passing</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#unix-pipes" class="nav-link">Unix Pipes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#unix-signal" class="nav-link">Unix Signal</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="cs2106-notes-ay2324-sem2">CS2106 Notes AY23/24 Sem2</h1>
<ul>
<li><a href="#cs2106-notes-ay2324-sem2">CS2106 Notes AY23/24 Sem2</a><ul>
<li><a href="#operating-systems">Operating Systems</a><ul>
<li><a href="#operating-system-structure">Operating System Structure</a></li>
<li><a href="#running-oses">Running OSes</a></li>
</ul>
</li>
<li><a href="#process-management">Process Management</a></li>
<li><a href="#process-abstraction">Process Abstraction</a><ul>
<li><a href="#component-description">Component Description</a></li>
<li><a href="#basic-instruction-execution">Basic Instruction Execution</a></li>
<li><a href="#memory-context">Memory Context</a><ul>
<li><a href="#function-call">Function Call</a></li>
<li><a href="#dynamically-allocated-memory">Dynamically Allocated Memory</a></li>
</ul>
</li>
<li><a href="#os-context">OS Context</a><ul>
<li><a href="#processes">Processes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#process-abstraction-in-unix">Process Abstraction in Unix</a><ul>
<li><a href="#zombie-process">Zombie Process</a></li>
<li><a href="#unix-system-calls">Unix System Calls</a></li>
</ul>
</li>
<li><a href="#process-scheduling">Process Scheduling</a><ul>
<li><a href="#concurrent-execution">Concurrent Execution</a></li>
<li><a href="#process-scheduling-algorithms">Process Scheduling Algorithms</a><ul>
<li><a href="#first-come-first-serve-fcfs">First-Come First-Serve: FCFS</a></li>
<li><a href="#shortest-job-first-sjf">Shortest Job First: SJF</a></li>
<li><a href="#shortest-remaining-time-srt">Shortest Remaining Time: SRT</a></li>
<li><a href="#round-robin-rr">Round Robin: RR</a></li>
<li><a href="#priority-scheduling">Priority Scheduling</a></li>
<li><a href="#multi-level-feedback-queue-mlfq">Multi-level Feedback Queue (MLFQ)</a></li>
<li><a href="#lottery-scheduling">Lottery Scheduling</a></li>
</ul>
</li>
<li><a href="#scheduling-for-interactive-systems">Scheduling for Interactive Systems</a></li>
</ul>
</li>
<li><a href="#process-alternative---threads">Process Alternative - Threads</a><ul>
<li><a href="#motivation-for-thread">Motivation for Thread</a></li>
<li><a href="#process-and-thread">Process and Thread</a></li>
<li><a href="#thread-models">Thread Models</a><ul>
<li><a href="#user-thread">User Thread</a></li>
<li><a href="#kernel-thread">Kernel Thread</a></li>
<li><a href="#hybrid-thread-model">Hybrid Thread Model</a></li>
<li><a href="#posix-threads-pthread">POSIX Threads: <code>pthread</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#inter-process-communication-ipc">Inter-Process Communication (IPC)</a><ul>
<li><a href="#message-passing">Message Passing</a></li>
<li><a href="#unix-pipes">Unix Pipes</a></li>
<li><a href="#unix-signal">Unix Signal</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="operating-systems">Operating Systems</h2>
<ul>
<li>Operating system: A program that acts as an intermediary between a computer user and the computer hardware.</li>
<li>Motivation for OS<ol>
<li>Abstraction:<ul>
<li>Hide the different low level details</li>
<li>Present the common high level functionality to user</li>
</ul>
</li>
<li>Resource Allocator:<ul>
<li>Manages all resources: CPU,Memory,Input/Outputdevices</li>
<li>Arbitrate potentially conflicting requests: for efficient and fair resource use</li>
</ul>
</li>
<li>Control Program:<ul>
<li>Controls execution of programs: prevent errors and improper use of the computer and provides security and protection</li>
</ul>
</li>
</ol>
</li>
<li><img alt="viewOfOs" src="../viewOfOs.png" /></li>
<li><img alt="osComponents" src="../osComponents.png" /></li>
<li>OS can protect a user program from other malicious applications</li>
<li>OS manages hardware resources for user programs</li>
</ul>
<h3 id="operating-system-structure">Operating System Structure</h3>
<ul>
<li>A <strong>monolithic</strong> kernel is an operating system architecture where the entire operating system is working in kernel space<ul>
<li><img alt="monolithicKernel" src="../monolithicKernel.png" /></li>
</ul>
</li>
<li>A <strong>microkernel</strong> architecture is an operating system pattern where only basic functionality is provided in the core of the software system<ul>
<li>Inter-Process Communication (IPC)</li>
<li>Address space management</li>
<li>Thread management</li>
<li><img alt="microkernelComponents" src="../microkernelComponents.png" /></li>
</ul>
</li>
<li><strong>Layered systems</strong><ul>
<li>Generalization of monolithic system</li>
<li>Organize the components into hierarchy of layers<ul>
<li>Upper layers make use of the lower layers</li>
<li>Lowest layer is the hardware</li>
<li>Highest layer is the user interface</li>
</ul>
</li>
</ul>
</li>
<li><strong>Client-Server Model</strong><ul>
<li>Variation of microkernel</li>
<li>Two classes of processes:<ul>
<li>Client process request service from server process</li>
<li>Server Process built on top of the microkernel</li>
<li>Client and Server process can be on separate machine!</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="running-oses">Running OSes</h3>
<ul>
<li>Motivation<ul>
<li>Operating system assumes total control of the hardware</li>
<li>Operating system is hard to debug/ monitor</li>
</ul>
</li>
<li>Definition<ul>
<li><strong>Virtual machine</strong>: a software emulation of hardware, also known as hypervisor</li>
<li><img alt="type1Hypervisor" src="../type1Hypervisor.png" /></li>
<li><img alt="type2Hypervisor" src="../type2Hypervisor.png" /></li>
</ul>
</li>
</ul>
<h2 id="process-management">Process Management</h2>
<ul>
<li>Process Abstraction<ul>
<li>Information describing an executing program</li>
<li>Process/ Task/ Job is a dynamic abstracton for execution program</li>
</ul>
</li>
<li>Process Scheduling<ul>
<li>Deciding which process get to execute</li>
</ul>
</li>
<li>Inter-Process Communication &amp; Synchronization<ul>
<li>Passing information between processes</li>
</ul>
</li>
<li>Alternative to Process<ul>
<li>Light-weight process aka Thread</li>
</ul>
</li>
</ul>
<h2 id="process-abstraction">Process Abstraction</h2>
<h3 id="component-description">Component Description</h3>
<ul>
<li>Memory<ul>
<li>Storage for instruction and data</li>
</ul>
</li>
<li>Cache<ul>
<li>Duplicate part of the memory for faster access</li>
<li>Usually split into instruction cache and data cache</li>
</ul>
</li>
<li>Fetch unit<ul>
<li>Loads instruction from memory</li>
<li>Location indicated by a special register: Program Counter (PC)</li>
</ul>
</li>
<li>Functional units<ul>
<li>Carry out the instruction execution</li>
<li>Dedicated to different instruction type</li>
</ul>
</li>
<li>Registers<ul>
<li>Internal storage for the fastest access speed</li>
<li>General purpose registers: accessible by user program</li>
<li>Special register: program counter</li>
</ul>
</li>
</ul>
<h3 id="basic-instruction-execution">Basic Instruction Execution</h3>
<ul>
<li>Instruction X is fetched<ul>
<li>Memory location indicated by Program Counter</li>
</ul>
</li>
<li>Instruction X dispatched to the corresponding Functional Unit<ul>
<li>Read operands if applicable, usually from memory or GPR</li>
</ul>
</li>
<li>Result computed<ul>
<li>Write value if applicable n Usually to memory or GPR</li>
</ul>
</li>
<li>Instruction X is completed<ul>
<li>PC updated for the next instruction</li>
</ul>
</li>
</ul>
<h3 id="memory-context">Memory Context</h3>
<h4 id="function-call">Function Call</h4>
<ul>
<li>Stack memory<ul>
<li>The new memory region to store information during function invocation</li>
<li>Information of function invocation is described by a stack frame</li>
<li>Stack frame contains:<ul>
<li>Return address of the caller</li>
<li>Arguments for the function</li>
<li>Storage for local variables</li>
</ul>
</li>
<li>Top of stack region (first unused location) is indicated by a stack pointer<ul>
<li>Stack frame is added on top when a function is invoked</li>
<li>Stack frame is removed from top when a function call ends</li>
</ul>
</li>
</ul>
</li>
<li>Function call convention (example scheme)<ul>
<li><img alt="stackFrameSetup" src="../stackFrameSetup.png" /></li>
<li><img alt="stackFrameTeardown" src="../stackFrameTeardown.png" /></li>
</ul>
</li>
<li>Frame pointer<ul>
<li>To facilitate the access of various stack frame items</li>
<li>Points to a fixed location in a stack frame</li>
</ul>
</li>
<li>Saved register<ul>
<li>Number of general purpose registers on most processors are limited</li>
<li>When GPRs are exhausted, use memory to hold the GPR value, then reuse GPR, value held can be restored afterwards (known as register spilling)</li>
</ul>
</li>
</ul>
<h4 id="dynamically-allocated-memory">Dynamically Allocated Memory</h4>
<ul>
<li>Acquire new memory space during execution time - malloc()</li>
<li>Observations<ul>
<li>Memory is allocated only at runtime (size is not known during compilation) -&gt; cannot place in data region</li>
<li>No definite deallocation timing (can be explicitly freed by programmer) -&gt; cannot place in stack region</li>
</ul>
</li>
<li>Solution: set up a separate heap memory region</li>
<li><img alt="heapMemory" src="../heapMemory.png" /></li>
<li>Memory context: text, data, stack and heap</li>
<li>Hardware context: general purpose register, program counter, stack pointer, stack frame pointer</li>
</ul>
<h3 id="os-context">OS Context</h3>
<h4 id="processes">Processes</h4>
<ul>
<li>
<p>Process Identification &amp; Process States</p>
<ul>
<li><img alt="processStateModel" src="../processStateModel.png" /></li>
</ul>
</li>
<li>
<p>New</p>
<ul>
<li>New process created</li>
<li>May still be under initialisation</li>
</ul>
</li>
<li>Ready<ul>
<li>Process is waiting to run</li>
</ul>
</li>
<li>Running<ul>
<li>Process being executed on CPU</li>
</ul>
</li>
<li>Blocked<ul>
<li>Process waiting for event</li>
<li>Cannot execute until event is available</li>
</ul>
</li>
<li>
<p>Terminated</p>
<ul>
<li>Process has finished execution, may require OS cleanup</li>
</ul>
</li>
<li>
<p>Process Table &amp; Process Control Block:</p>
<ul>
<li>Entire execution context for a process</li>
<li>Kernel maintains PCB for all processes</li>
<li>Hardware context in PCB is updated only when process swap out</li>
<li>Memory context in PCB is not the actual memory space used in process (points to real memory &amp; contains page table)</li>
<li>PCBs are part of OS memory space</li>
<li>OS context of PCB contains information used for scheduling, e.g. priority, time quantum allocated, etc.</li>
</ul>
</li>
<li>
<p>System calls</p>
<ul>
<li>System calls are dependent on the operating system</li>
<li>
<p>Application program interface (API) to OS</p>
<ul>
<li>Provides way of calling facilities/ services in kernel</li>
<li>Not the same as normal function call (have to change from user mode to kernel mode)</li>
</ul>
</li>
<li>
<p>User program invokes the library call (normal function call, which are programming language dependent)</p>
</li>
<li>Library call (usually in assembly code) places the system call number in a designated location E.g. Register</li>
<li>Library call executes a special instruction to switch from user mode to kernel mode (commonly known as TRAP)</li>
<li>Now in kernel mode, the appropriate system call handler is determined:<ul>
<li>Using the system call number as <strong>index</strong></li>
<li>This step is usually handled by a <strong>dispatcher</strong></li>
</ul>
</li>
<li>System call handler is executed: Carry out the actual request</li>
<li>System call handler ended:<ul>
<li>Control return to the library call</li>
<li>Switch from kernel mode to user mode</li>
</ul>
</li>
<li>
<p>Library call return to the user program: via normal function return mechanism</p>
</li>
<li>
<p><img alt="systemCallMechanism" src="../systemCallMechanism.png" /></p>
</li>
<li>System calls are more expensive than library calls due to context switching</li>
</ul>
</li>
<li>
<p>Exception and Interrupt</p>
<ul>
<li>Exception is <strong>synchronous</strong>: occur due to program execution<ul>
<li>Have to execute an exception handler</li>
<li>Similar to a forced function call</li>
</ul>
</li>
<li>Interrupt is <strong>asynchronous</strong>: events that occur independent of program execution<ul>
<li>Program execution is suspended</li>
<li>Have to execute an interrupt handler</li>
</ul>
</li>
<li><img alt="exceptionInterruptHandler" src="../exceptionInterruptHandler.png" /></li>
</ul>
</li>
</ul>
<h2 id="process-abstraction-in-unix">Process Abstraction in Unix</h2>
<ul>
<li>Identification<ul>
<li>PID: process ID</li>
</ul>
</li>
<li>Information<ul>
<li>Process state: running, sleeping, stopped, zombie</li>
<li>Parent PID</li>
<li>Cumulative CPU time</li>
<li>Command: <code>ps</code> (process status)</li>
</ul>
</li>
<li>Creation:<ul>
<li><code>fork()</code><ul>
<li><code># include &lt;unistd.h&gt;</code></li>
<li><code>int fork();</code></li>
<li>Returns: PID of newly created process for parent and 0 for child</li>
<li>Child process is a duplicate of current executable image</li>
<li>Both parent and child processes continue executing after <code>fork()</code></li>
</ul>
</li>
<li><code>exec()</code><ul>
<li>Replace current executing process image with a new one</li>
<li><code># include &lt;unistd.h&gt;</code></li>
<li><code>int execl( const char *path, const char *arg0 ... NULL)</code></li>
<li>Path: location of executable</li>
<li>e.g. <code>execl( "/bin/ls", "ls", "-l", NULL);</code> = <code>ls -l</code></li>
</ul>
</li>
</ul>
</li>
<li>Termination<ul>
<li><code>#include &lt;stdlib.h&gt;</code></li>
<li><code>void exit( int status );</code></li>
<li>0 = Normal Termination (successful execution)</li>
<li>No return</li>
<li>Most system resources used by processes are released on exit (files)</li>
<li>Some resources are not releaseable (PID &amp; status, process accounting info)</li>
</ul>
</li>
<li>Parent-Child Synchronisation<ul>
<li><code>#include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt;</code></li>
<li><code>int wait( int *status );</code></li>
<li>Returns the PID of the terminated child process status (passed by address)</li>
<li>Parent process blocks until at least one child terminates</li>
</ul>
</li>
<li><img alt="processInteractionInUnix" src="../processInteractionInUnix.png" /></li>
<li><code>wait()</code> creates zombie processes</li>
</ul>
<h3 id="zombie-process">Zombie Process</h3>
<ul>
<li>Parent process terminates before child process:<ul>
<li>init process becomes "pseudo" parent of child processes</li>
<li>Child termination sends signal to init, which utilizes wait() to cleanup</li>
</ul>
</li>
<li>Child process terminates before parent but parent did not call wait:<ul>
<li>Child process become a zombie process</li>
<li>Can fill up process table</li>
<li>May need a reboot to clear the table on older Unix implementations</li>
</ul>
</li>
</ul>
<h3 id="unix-system-calls">Unix System Calls</h3>
<p><img alt="summaryOfUnixCalls" src="../summaryOfUnixCalls.png" /></p>
<h2 id="process-scheduling">Process Scheduling</h2>
<ul>
<li>Time quantum is always an integer multiple of interval between timer interrupt</li>
<li>Given the same period of time, smaller interval between timer interrupt lengthen task turn-around time<ul>
<li>Shorter ITI -&gt; More Timer Interrupt -&gt; less time spent on actual user process</li>
</ul>
</li>
</ul>
<h3 id="concurrent-execution">Concurrent Execution</h3>
<ul>
<li>Concurrent processes<ul>
<li>Logical concept to cover multitasked processes</li>
<li><img alt="simplisticConcurrency" src="../simplisticConcurrency.png" /></li>
<li><img alt="interleavedContextSwitch" src="../interleavedContextSwitch.png" /></li>
</ul>
</li>
<li>Terminology<ul>
<li>Scheduler: Part of the OS that makes scheduling decision</li>
<li>Scheduling algorithm: The algorithm used by scheduler</li>
</ul>
</li>
<li>Processing environment<ul>
<li>Batch processing<ul>
<li>No user: no interaction required, no need to be responsive</li>
</ul>
</li>
<li>Interactive<ul>
<li>With active user interacting with system</li>
<li>Should be responsive, consistent in response time</li>
</ul>
</li>
<li>Real time processing<ul>
<li>Have deadline to meet</li>
<li>Usually periodic process</li>
</ul>
</li>
</ul>
</li>
<li>Criteria for all processing environments<ul>
<li>Fairness<ul>
<li>Should get a fair share of CPU time</li>
<li>No starvation</li>
</ul>
</li>
<li>Balance<ul>
<li>All parts of computing system should be utilised</li>
</ul>
</li>
</ul>
</li>
<li>Types of scheduling policies<ul>
<li>Non-preemptive (cooperative)<ul>
<li>A process stayed scheduled in running state until it blocks or gives up the CPU voluntarily</li>
</ul>
</li>
<li>Preemptive<ul>
<li>A process is given a fixed time quota to run (possible to block or give up early)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="process-scheduling-algorithms">Process Scheduling Algorithms</h3>
<ul>
<li>Criteria for batch processing<ul>
<li><strong>Turnaround time</strong>: Total time taken, i.e. finish-arrival time</li>
<li><strong>Waiting time</strong>: Time spent waiting for CPU</li>
<li><strong>Throughput</strong>: Number of tasks finished per unit time i.e. Rate of task completion</li>
<li><strong>CPU utilization</strong>: Percentage of time when CPU is working on a task</li>
</ul>
</li>
</ul>
<h4 id="first-come-first-serve-fcfs">First-Come First-Serve: FCFS</h4>
<ul>
<li>Tasks are stored on a First-In-First-Out (FIFO) queue based on arrival time</li>
<li>Pick the first task in queue to run until the task is done OR the task is blocked</li>
<li>Blocked task is removed from the FIFO queue<ul>
<li>When it is ready again, it is placed at the back of queue</li>
<li>i.e. just like a newly arrive task</li>
</ul>
</li>
<li>Guaranteed to have no starvation:<ul>
<li>The number of tasks in front of task X in FIFO is always decreasing -&gt; task X will get its chance eventually</li>
</ul>
</li>
<li>Shortcomings<ul>
<li><strong>Convoy effect</strong>: FCFS algorithm is non-preemptive in nature, that is, once CPU time has been allocated to a process, other processes can get CPU time only after the current process has finished</li>
</ul>
</li>
</ul>
<h4 id="shortest-job-first-sjf">Shortest Job First: SJF</h4>
<ul>
<li>Select task with the smallest total CPU time</li>
<li>Need to know total CPU time for a task in advance</li>
<li>Given a fixed set of tasks, average waiting time is minimised</li>
<li>Starvation is possible: biased towards short jobs, such that long job may never get a chance</li>
<li><img alt="predictingCpuTime" src="../predictingCpuTime.png" /></li>
</ul>
<h4 id="shortest-remaining-time-srt">Shortest Remaining Time: SRT</h4>
<ul>
<li>Select job with shortest remaining (or expected) time</li>
<li>New job with shorter remaining time can preempt currently running job</li>
<li>Provide good service for short job even when it arrives late</li>
</ul>
<h4 id="round-robin-rr">Round Robin: RR</h4>
<ul>
<li>Tasks are stored in a FIFO queue</li>
<li>Pick the first task from queue front to run until:<ul>
<li>A fixed time slice (quantum) elapsed</li>
<li>The task gives up the CPU voluntarily</li>
</ul>
</li>
<li>The task is then placed at the end of queue to wait for another turn<ul>
<li>Blocked task will be moved to other queue to wait for its request</li>
</ul>
</li>
<li>Basically a preemptive version of FCFS</li>
<li>Response time guarantee:<ul>
<li>Given n tasks and quantum q</li>
<li>Time before a task get CPU is bounded by (n-1)q</li>
</ul>
</li>
<li>Timer interrupt needed:<ul>
<li>For scheduler to check on quantum expiry</li>
</ul>
</li>
<li>The choice of time quantum duration is important:<ul>
<li>Big quantum: Better CPU utilization but longer waiting time</li>
<li>Small quantum: Bigger overhead (worse CPU utilization) but shorter waiting time</li>
</ul>
</li>
</ul>
<h4 id="priority-scheduling">Priority Scheduling</h4>
<ul>
<li>Assign a priority value to all tasks, select task with highest priority value</li>
<li>Variants<ul>
<li>Preemptive version: higher priority process can preempt running process with lower priority</li>
<li>Non-preemptive version: late coming high priority process has to wait for next round of scheduling</li>
</ul>
</li>
<li>Shortcomings<ul>
<li>Low priority process can starve (worse in preemptive variant)</li>
</ul>
</li>
<li>Possible solutions<ul>
<li>Decrease the priority of currently running process after every time quantum</li>
<li>Give the current running process a time quantum</li>
</ul>
</li>
<li><strong>Priority Inversion</strong>: Priority inversion is a situation that can occur when a low-priority task is holding a resource such as a semaphore for which a higher-priority task is waiting</li>
</ul>
<h4 id="multi-level-feedback-queue-mlfq">Multi-level Feedback Queue (MLFQ)</h4>
<ul>
<li>If Priority(A) &gt; Priority(B) -&gt; A runs</li>
<li>If Priority(A) == Priority(B) -&gt; A and B runs in RR</li>
<li>Priority Setting/Changing rules:<ol>
<li>New job -&gt; Highest priority</li>
<li>If a job fully utilized its time slice -&gt; priority reduced</li>
<li>If a job give up / blocks before it finishes the time slice -&gt; priority retained</li>
</ol>
</li>
<li>Favours IO intensive process</li>
<li>Exploitations:<ul>
<li>Change of heart: A process with a lengthy CPU-intensive phase followed by I/O-intensive phase. The process can sink to the lowest priority during the CPU intensive phase. With the low priority, the process may not receive CPU time in a timely fashion, which degrades the responsiveness.<ul>
<li>Timely boost: All processes in the system will be moved to the highest priority level periodically.</li>
<li>By periodically boosting the priority of all processes (essentially treat all process as “new” and hence have highest priority), a process with different behavior phases may get a chance to be treated correctly even after it has sunk to the lowest priority.</li>
</ul>
</li>
<li>Gaming the system: A process repeatedly gives up CPU just before the time quantum lapses.<ul>
<li>Accounting matters: The CPU usage of a process is now accumulated across time quanta. Once the CPU usage exceeds a single time quantum, the priority of the task will be decremented.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="lottery-scheduling">Lottery Scheduling</h4>
<ul>
<li>Give out “lottery tickets” to processes for various system resources</li>
<li>When a scheduling decision is needed, a lottery ticket is chosen randomly among eligible tickets</li>
<li>Responsive: a newly created process can participate in the next lottery</li>
<li>A process can be given Y lottery tickets to distribute to its child process</li>
<li>An important process can be given more lottery tickets</li>
<li>Each resource can have its own set of tickets<ul>
<li>Different proportion of usage per resource per task</li>
</ul>
</li>
</ul>
<h3 id="scheduling-for-interactive-systems">Scheduling for Interactive Systems</h3>
<ul>
<li>
<p>Criteria for Interactive Environment</p>
<ul>
<li><strong>Response time</strong>: Time between request and response by system</li>
<li><strong>Predictability</strong>: Variation in response time, lesser variation -&gt; more predictable</li>
<li>Preemptive scheduling algorithms are used to ensure good response time<ul>
<li>Scheduler needs to run periodically</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Interval of timer interrupt (ITI)</p>
<ul>
<li>OS scheduler is triggered every timer interrupt</li>
</ul>
</li>
<li>Time Quantum<ul>
<li>Execution duration given to a process</li>
<li>Could be constant or variable among the processes</li>
<li>Must be multiples of interval of timer interrupt</li>
<li>Large range of values</li>
</ul>
</li>
</ul>
<h2 id="process-alternative-threads">Process Alternative - Threads</h2>
<h3 id="motivation-for-thread">Motivation for Thread</h3>
<ul>
<li>Process is expensive:<ul>
<li>Process creation under the fork() model: duplicate memory space, duplicate most of the process context etc</li>
<li>Context switch: Requires saving/restoration of process information</li>
</ul>
</li>
<li>It is hard for independent processes to communicate with each other:<ul>
<li>Independent memory space -&gt; no easy way to pass information</li>
<li>Requires Inter-Process Communication (IPC)</li>
</ul>
</li>
<li>Thread is invented to overcome the problems with process model<ul>
<li>Started out as a "quick hack" and eventually matured to be very popular mechanism</li>
</ul>
</li>
<li>Basic Idea:<ul>
<li>A traditional process has a single thread of control: only one instruction of the whole program is executing at any time</li>
<li>Add more threads of control to the same process: multiple parts of the programs is executing at the same time conceptually</li>
</ul>
</li>
</ul>
<h3 id="process-and-thread">Process and Thread</h3>
<ul>
<li>A single proces can have multiple threads: multithreaded process</li>
<li>Threads in the same process shares<ul>
<li>Memory context: text, data, heap</li>
<li>OS context: process id, files</li>
</ul>
</li>
<li>Unique information needed for each thread<ul>
<li>Identification (usually thread id)</li>
<li>Registers (general purpose and special)</li>
<li>Stack</li>
</ul>
</li>
<li><img alt="processAndThread" src="../processAndThread.png" /></li>
<li>Context Switch<ul>
<li>Process context switch involves:<ul>
<li>OS Context</li>
<li>Hardware Context</li>
<li>Memory Context</li>
</ul>
</li>
<li>Thread switch within the same process involves:</li>
<li>Hardware context: Registers, "Stack" (actually just changing FP and SP registers)</li>
</ul>
</li>
<li>Threads: Benefits<ul>
<li>Economy<ul>
<li>Multiple threads in the same process requires much less resources to manage compared to multiple processes</li>
</ul>
</li>
<li>Resource sharing<ul>
<li>Threads share most of the resources of a process</li>
<li>No need for additional mechanism for passing information around</li>
</ul>
</li>
<li>Responsiveness<ul>
<li>Multithreaded programs can appear much more responsive</li>
</ul>
</li>
<li>Scability<ul>
<li>Multithreaded program can take advantage of multiple CPUs</li>
</ul>
</li>
</ul>
</li>
<li>Threads: Problems<ul>
<li>System call concurrency<ul>
<li>Parallel execution of multiple threads -&gt; parallel system call possible</li>
</ul>
</li>
<li>Process behaviour<ul>
<li>fork() duplicate process, and thread behaviour is OS specific (the other threads may or may not get duplicated)</li>
<li>If a single thread calls exit() in a multithreaded program, it typically terminates the entire process, not just the thread that called exit()</li>
<li>When a single thread calls exec(), it replaces the entire process image with a new program. This includes all threads. The new program starts with a single thread, and the previous threads of the calling process are terminated</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="thread-models">Thread Models</h3>
<h4 id="user-thread">User Thread</h4>
<ul>
<li>Thread is implemented as a user library; kernel is not aware of the threads in the process</li>
<li><img alt="userThread" src="../userThread.png" /></li>
<li>Advantages:<ul>
<li>Can have multithreaded program on ANY OS</li>
<li>Thread operations are just library calls</li>
<li>Generally more configurable and flexible<ul>
<li>e.g. Customized thread scheduling policy</li>
</ul>
</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>OS is not aware of threads, scheduling is performed at process level (can never exploit multi-core processors)</li>
<li>One thread blocked -&gt; Process blocked -&gt; All threads blocked</li>
<li>Cannot exploit multiple CPUs!</li>
</ul>
</li>
</ul>
<h4 id="kernel-thread">Kernel Thread</h4>
<ul>
<li>Thread is implemented in the OS<ul>
<li>Thread operation is handled as system calls</li>
</ul>
</li>
<li>Thread-level scheduling is possible<ul>
<li>Kernel schedule by threads, instead of by process</li>
</ul>
</li>
<li><img alt="kernelThread" src="../kernelThread.png" /></li>
<li>Advantages:<ul>
<li>Kernel can schedule on thread levels:<ul>
<li>More than 1 thread in the same process can run simultaneously on multiple CPUs</li>
</ul>
</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>Thread operations is now a system call!<ul>
<li>Slower and more resource intensive</li>
</ul>
</li>
<li>Generally less flexible:<ul>
<li>Used by all multithreaded programs</li>
<li>If implemented with many features, expensive, overkill for simple program</li>
<li>If implemented with few features, not flexible enough for some programs</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="hybrid-thread-model">Hybrid Thread Model</h4>
<ul>
<li>Have both kernel and user threads<ul>
<li>OS schedule on kernel threads only</li>
<li>User thread can bind to a kernel thread</li>
</ul>
</li>
<li>If we use a 1-to-1 binding in a hybrid thread model, the end result is the same as a pure kernel-thread model as each user thread is bounded to a kernel thread that can be scheduled</li>
<li>Offer great flexibility<ul>
<li>Can limit the concurrency of any process/ user</li>
</ul>
</li>
</ul>
<h4 id="posix-threads-pthread">POSIX Threads: <code>pthread</code></h4>
<ul>
<li>Header file: <code># include &lt;pthread.h&gt;</code></li>
<li>Compilation: <code>gcc XXX.c -lpthread</code></li>
<li>Datatypes<ul>
<li><code>pthread_t</code>: Data type to represent a thread id</li>
<li><code>pthread_attr</code>: Data type to represent attributes of a thread</li>
</ul>
</li>
<li>Creation syntax<ul>
<li>Returns (0 = success; !0 = errors)</li>
<li>Parameters:<ul>
<li>tidCreated: Thread Id for the created thread</li>
<li>threadAttributes: Control the behavior of the new thread</li>
<li>startRoutine: Function pointer to the function to be executed by thread</li>
<li>argForStartRoutine: Arguments for the startRoutine function</li>
</ul>
</li>
</ul>
</li>
<li>Pthread can start on any function as long as the function signature is void<em> f(void</em>)</li>
</ul>
<pre><code class="language-c">int pthread_create(
    pthread_t* tidCreated,
    const pthread_attr_t* threadAttributes,
    void* (*startRoutine) (void*),
    void* argForStartRoutine );
</code></pre>
<ul>
<li>Termination syntax<ul>
<li>Parameters:<ul>
<li>exitValue: Value to be returned to whoever synchronize with
    this thread (more later)</li>
</ul>
</li>
<li>If pthread_exit()is not used, a pthread will terminate
    automatically at the end of the startRoutine</li>
</ul>
</li>
</ul>
<pre><code class="language-c">    int pthread_exit( void* exitValue );
</code></pre>
<ul>
<li>Join<ul>
<li>To wait for the termination of another pthread</li>
<li>Returns (0 = success; !0 = errors)</li>
<li>Parameters:<ul>
<li>threadID: TID of the pthread to wait for</li>
<li>status: Exit value returned by the target pthread</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-c">    int pthread_join( pthread_t threadID, void **status );
</code></pre>
<h2 id="inter-process-communication-ipc">Inter-Process Communication (IPC)</h2>
<ul>
<li>General Idea:<ul>
<li>Process P1 creates a shared memory region M</li>
<li>Process P2 attaches M to its own memory space</li>
<li>P1 and P2 can now communicate using M</li>
<li>Any writes to M can be seen by all other parties (behaves similar to normal memory region)</li>
<li>Same model for multiple processes sharing the same memory region</li>
</ul>
</li>
</ul>
<pre><code>
Process P1

1. Create M (implict attach)
2. Read/Write to M

</code></pre>
<pre><code>
Process P2

1. Attach M
2. Read/Write to M

</code></pre>
<ul>
<li>Master program</li>
</ul>
<pre><code class="language-c">int main() {
    int shmid, i, *shm;

    // Create shared memory region
    shmid = shmget( IPC_PRIVATE, 40, IPC_CREAT | 0600);

    if (shmid == -1) {
        printf(&quot;Cannot create shared memory!\n&quot;); exit(1);
    } else
        printf(&quot;Shared Memory Id = %d\n&quot;, shmid);

    // Attach shared memory region
    shm = (int*) shmat( shmid, NULL, 0 );
    if (shm == (int*) -1) {
        printf(&quot;Cannot attach shared memory!\n&quot;);
        exit(1);
    }

    // First element is used as control value
    shm[0] = 0;

    while(shm[0] == 0) {
        sleep(3);
    }

    for (i = 0; i &lt; 3; i++){
        printf(&quot;Read %d from shared memory.\n&quot;, shm[i+1]);
    }

    // Detach and destroy shared memory region
    shmdt( (char*) shm);
    shmctl( shmid, IPC_RMID, 0);
    return 0;
}
</code></pre>
<ul>
<li>Slave program</li>
</ul>
<pre><code class="language-c">//similar header files
int main() {
    int shmid, i, input, *shm;

    printf(&quot;Shared memory id for attachment: &quot;);
    scanf(&quot;%d&quot;, &amp;shmid);

    // Attach to shared memory region
    shm = (int*)shmat( shmid, NULL, 0);
    if (shm == (int*)-1) {
        printf(&quot;Error: Cannot attach!\n&quot;);
        exit(1);
    }

    // Write 3 values
    for (i = 0; i &lt; 3; i++){
        scanf(&quot;%d&quot;, &amp;input);
        shm[i+1] = input;
    }

    // Let master program know we are done!
    shm[0] = 1;

    // Detach shared memory region
    shmdt( (char*)shm );
    return 0;
}
</code></pre>
<ul>
<li>Advantages<ul>
<li>Efficient: only create and attach involve OS</li>
<li>Ease of use: shared memory region behaves the same as normal memory</li>
</ul>
</li>
<li>Disadvantages<ul>
<li>Synchronisation: shared resource means there is a need to synchronise access</li>
</ul>
</li>
</ul>
<h3 id="message-passing">Message Passing</h3>
<ul>
<li>Process P1 prepares a message M and send it to Process P2</li>
<li>Process P2 receives the message M</li>
<li>
<p>Message sending and receiving are usually provided as system calls</p>
</li>
<li>
<p>Naming scheme</p>
<ul>
<li>Direct communication<ul>
<li>Sender/ receiver of message explicitly name the other party</li>
</ul>
</li>
<li>Indirect communication<ul>
<li>Messages are sent to/ received from message storage</li>
</ul>
</li>
</ul>
</li>
<li>Synchronisation behaviours<ul>
<li>Blocking primitives (synchronous)<ul>
<li>Sender/ receiver is blocked until message is received/ arrived</li>
</ul>
</li>
<li>Non-blocking primitives (asynchronous)<ul>
<li>Sender: resume operation immediately</li>
<li>Receiver: either receive the message or some indication that message is not ready</li>
</ul>
</li>
</ul>
</li>
<li>Advantages<ul>
<li>Portable: can be easily implemented</li>
<li>Easier synchronisation</li>
</ul>
</li>
<li>Disadvantages<ul>
<li>Inefficient (requires OS intervention)</li>
<li>Harder to use, messages are limited in size or format</li>
</ul>
</li>
</ul>
<h3 id="unix-pipes">Unix Pipes</h3>
<ul>
<li><img alt="communicationChannels" src="../communicationChannels.png" /></li>
<li>Piping in shell<ul>
<li>"|" symbol to link the input/output channels of one process to another (known as piping)</li>
<li>Output of a process goes directly into another as input</li>
</ul>
</li>
<li>Pipe functions as circular bounded byte buffer with implicit synchronization:<ul>
<li>Writers wait when buffer is full</li>
<li>Readers wait when buffer is empty</li>
</ul>
</li>
<li>Variants<ul>
<li>Half-duplex: unidirectional, one write end and one read end</li>
<li>Full-duplex: bidirectional, read/ write for both ends</li>
</ul>
</li>
<li>System calls<ul>
<li><code>#include &lt;unistd.h&gt;</code></li>
<li><code>int pipe( int fd[] )</code></li>
<li>Returns 0 to indicate success; !0 for errors</li>
</ul>
</li>
</ul>
<h3 id="unix-signal">Unix Signal</h3>
<ul>
<li>A form of inter-process communication<ul>
<li>An asynchronous notification regarding an event</li>
<li>Sent to a process/thread</li>
</ul>
</li>
<li>Recipient of the signal must handle the signal by<ul>
<li>A default set of handlers</li>
<li>User supplied handler</li>
</ul>
</li>
<li>E.g. kill, stop, continue, memory error, arithmetic error</li>
<li>A process can install user-define handler for multiple different signals.<ul>
<li>[True]</li>
</ul>
</li>
<li>We can install user-define handler for all signals.<ul>
<li>[False: The "kill -9" i.e. SIGKIL is not captureable]</li>
</ul>
</li>
<li>A parent process can force the child processes to execute any part of their code by sending signal to them.<ul>
<li>[False: Only the signal handler can be triggered.]</li>
</ul>
</li>
<li>The "kill" signal (sent by the "kill" command) is different from the "interrupt" signal (sent by pressing "ctrl-c").<ul>
<li>[True]</li>
</ul>
</li>
</ul></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/jquery-3.6.0.min.js"></script>
        <script src="../../js/bootstrap.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
